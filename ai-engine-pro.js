"use strict";const AIEnginePro={version:"1.6.9",isReady:!1,db:null,config:{horizons:[2,5,10,15,30,60,120,240],minConfidence:.3,ensembleThreshold:.4,learningRate:.03,decayRate:.995,maxLongTermPatterns:2e3,maxMarketCycles:100,optimizationInterval:36e5,featureThreshold:.1,minValidationsToLearn:6,autoMaxHorizon:15,minValidationsToLearnAuto:4,maxPending:25,sessionAware:!0,volatilityAware:!0,breakoutAware:!0,debugMode:!0},models:{momentum:{name:"Momentum",weight:1,accuracy:.5,features:["rsi","stoch_rsi","momentum","rsi_divergence","price_momentum"],predictions:0,correct:0},trend:{name:"Trend",weight:1,accuracy:.5,features:["ema_cross","macd","adx","supertrend","price_momentum"],predictions:0,correct:0},volume:{name:"Volume",weight:1,accuracy:.5,features:["volume","obv","cvd","whale_flow"],predictions:0,correct:0},structure:{name:"Structure",weight:1,accuracy:.5,features:["support_resistance","order_blocks","fvg","liquidity"],predictions:0,correct:0},patterns:{name:"Patterns",weight:1,accuracy:.5,features:["candlestick_patterns","chart_patterns","divergences","price_momentum"],predictions:0,correct:0},mtf:{name:"MTF",weight:1.2,accuracy:.5,features:["mtf_1m","mtf_5m","mtf_15m","mtf_1h","mtf_4h"],predictions:0,correct:0}},features:{derived:{rsi_momentum:{weight:1,formula:"rsi_change_rate"},macd_acceleration:{weight:1,formula:"macd_histogram_change"},volume_trend:{weight:1,formula:"volume_ma_ratio"},volatility_regime:{weight:1,formula:"atr_percentile"},whale_pressure:{weight:1.2,formula:"whale_buy_sell_ratio"},order_imbalance:{weight:1.1,formula:"bid_ask_imbalance"},mtf_alignment:{weight:1.3,formula:"timeframe_confluence"},trend_strength:{weight:1,formula:"adx_slope"},momentum_divergence:{weight:1.2,formula:"price_rsi_divergence"},liquidity_zones:{weight:1.1,formula:"nearby_liquidity"}},stats:{}},predictions:{pending:[],completed:[],byHorizon:{2:{total:0,correct:0,accuracy:.5},5:{total:0,correct:0,accuracy:.5},10:{total:0,correct:0,accuracy:.5},15:{total:0,correct:0,accuracy:.5},30:{total:0,correct:0,accuracy:.5},60:{total:0,correct:0,accuracy:.5},120:{total:0,correct:0,accuracy:.5},240:{total:0,correct:0,accuracy:.5}}},memory:{patterns:[],marketCycles:[],correlations:{},regimeHistory:[],significantEvents:[]},performance:{daily:{},weekly:{},overall:{totalPredictions:0,correctPredictions:0,accuracy:0,profitFactor:1,sharpeRatio:0,maxDrawdown:0}},async init(){console.log("[AI-PRO] Initializing AI Engine PRO v"+this.version+" with Auto-Prediction");let e=0;for(;!window.AILearning?.isInitialized&&e<50;)await new Promise(e=>setTimeout(e,100)),e++;return window.AILearning?.isInitialized?(this.db=window.AILearning.db,this.db||console.warn("[AI-PRO] Firestore not available, using local mode"),this.initializeHorizons(),this.validateFeatures(),await this.loadState(),this.startOptimizationLoop(),this.hookIntoBase(),this.startAutoPrediction(),this._sessionStart=Date.now(),this._sessionPredictions=0,this._lastPredictionTime=null,this._lastVerification=null,this.isReady=!0,console.log("[AI-PRO] âœ“ AI Engine PRO ready"),console.log("[AI-PRO] Models:",Object.keys(this.models).length),console.log("[AI-PRO] Features:",Object.keys(this.features.derived).length),console.log("[AI-PRO] Horizons:",this.config.horizons.join(", ")+" min"),console.log("[AI-PRO] Min confidence:",100*this.config.minConfidence+"%"),console.log("[AI-PRO] Ensemble threshold:",100*this.config.ensembleThreshold+"%"),setTimeout(()=>{const e=window.state||{};console.log("[AI-PRO] ðŸ“Š State check:",{price:e.price,hasIndicators:!!e.indicators,indicatorCount:Object.keys(e.indicators||{}).length,indicatorSample:Object.keys(e.indicators||{}).slice(0,8)})},3e3),!0):(console.error("[AI-PRO] Base AILearning not ready"),!1)},initializeHorizons(){for(const e of this.config.horizons)this.predictions.byHorizon[e]||(this.predictions.byHorizon[e]={total:0,correct:0,accuracy:.5},console.log(`[AI-PRO] Initialized horizon: ${e}min`))},validateFeatures(){const e=new Set;for(const t of Object.values(this.models))t.features.forEach(t=>e.add(t));Object.keys(this.features.derived).forEach(t=>e.add(t));const t=[],i=[];for(const n of e)this.hasFeatureMapping(n)?t.push(n):i.push(n);this.config.debugMode&&(console.log(`[AI-PRO] Features mapped: ${t.length}/${e.size}`),i.length>0&&console.warn("[AI-PRO] Unmapped features:",i.join(", ")))},hasFeatureMapping:e=>["rsi","stoch_rsi","momentum","rsi_divergence","price_momentum","ema_cross","macd","adx","supertrend","volume","obv","cvd","whale_flow","support_resistance","order_blocks","fvg","liquidity","candlestick_patterns","chart_patterns","divergences","mtf_1m","mtf_5m","mtf_15m","mtf_1h","mtf_4h","rsi_momentum","macd_acceleration","volume_trend","volatility_regime","whale_pressure","order_imbalance","mtf_alignment","trend_strength","momentum_divergence","liquidity_zones"].includes(e),hookIntoBase(){const e=window.AILearning.recordPrediction.bind(window.AILearning),t=window.AILearning.complete.bind(window.AILearning);window.AILearning.recordPrediction=t=>{const i=e(t);return this.recordProPrediction(t,i),i},window.AILearning.complete=e=>{t(e),this.updateProModels(e)},console.log("[AI-PRO] Hooked into base AILearning")},generateEnsemblePrediction(e){const t={BULL:0,BEAR:0,NEUTRAL:0},i={};let n=0;for(const[o,r]of Object.entries(this.models)){const s=this.getModelPrediction(o,r,e);i[o]=s;const a=r.weight*r.accuracy;t[s.direction]+=a*s.confidence,n+=a}for(const e of Object.keys(t))t[e]=n>0?t[e]/n:.33;let o="NEUTRAL",r=.35;const s=Math.max(t.BULL,t.BEAR,t.NEUTRAL);t.BULL>=t.BEAR&&t.BULL>=.8*t.NEUTRAL?(o="BULL",r=.35+.6*t.BULL):t.BEAR>=t.BULL&&t.BEAR>=.8*t.NEUTRAL?(o="BEAR",r=.35+.6*t.BEAR):r=.3+.3*s;const a=this.config.sessionAware?this.getSessionContext():null,c=this.config.volatilityAware?this.getVolatilityScore(e):null,l=null!=c?this.getVolatilityConfidenceMultiplier(c):1,u=this.config.breakoutAware?this.detectBreakoutContext(e):null,d=this.detectMarketRegime(e);r*=this.getRegimeConfidenceMultiplier(d),a&&(r*=this.getSessionConfidenceMultiplier(a)),r*=l,u&&"FAKE_BREAKOUT_RISK"===u.classification&&(r*=.92);const h=this.queryLongTermMemory(e);return h.found&&(r=(r+h.confidence)/2,h.direction!==o&&h.confidence>.7&&(r*=.85)),r=Math.max(.2,Math.min(.95,r)),{direction:o,confidence:r,votes:t,modelPredictions:i,regime:d,patternMatch:h,session:a,volScore:c,breakout:u,timestamp:Date.now()}},getModelPrediction(e,t,i){let n=0,o=0,r=0;for(const e of t.features){const t=this.getFeatureValue(e,i);if(null==t)continue;const s=window.AILearning?.getWeight?.(e)||1;t>0?n+=t*s:t<0&&(o+=Math.abs(t)*s),r++}if(0===r){const e=this.getFeatureValue("price_momentum",i)||0;return e>.01?{direction:"BULL",confidence:.4+.3*e,featureCount:1}:e<-.01?{direction:"BEAR",confidence:.4+.3*Math.abs(e),featureCount:1}:{direction:"NEUTRAL",confidence:.35,featureCount:0}}const s=n+o;if(0===s)return{direction:"NEUTRAL",confidence:.4,featureCount:r};const a=n/s,c=o/s;let l="NEUTRAL",u=.4;return a>.52?(l="BULL",u=.4+1.2*(a-.5)):c>.52&&(l="BEAR",u=.4+1.2*(c-.5)),{direction:l,confidence:Math.min(.95,u),featureCount:r}},getFeatureValue(e,t){const i=t.indicators||{},n=t,o={rsi:()=>((i.rsi?.value??i.rsi??50)-50)/50,stoch_rsi:()=>((i.stochRsi?.value??i.stochRsi??50)-50)/50,momentum:()=>{const e=i.momentum;return e?"bull"===e.signal?1:"bear"===e.signal?-1:0:0},rsi_divergence:()=>{const e=i.divergence||n.divergence;return e?"bullish"===e.type?1:"bearish"===e.type?-1:0:0},ema_cross:()=>{const e=i.ema;return e?"bull"===e.signal?1:"bear"===e.signal?-1:0:0},macd:()=>{const e=i.macd;if(!e)return 0;const t=e.histogram??e.hist??0;return t>0?Math.min(1,10*t):Math.max(-1,10*t)},adx:()=>{const e=i.adx;if(!e)return 0;const t=(e.value??e.adx??20)>25?1:.5;return"bull"===e.trend?t:"bear"===e.trend?-t:0},supertrend:()=>{const e=i.supertrend;return e?"bull"===e.signal?1:"bear"===e.signal?-1:0:0},volume:()=>{const e=n.volume||{};return"increasing"===e.trend?.5:"decreasing"===e.trend?-.5:0},obv:()=>{const e=i.obv;return e?"bull"===e.signal?1:"bear"===e.signal?-1:0:0},cvd:()=>{const e=n.cvd??0;return Math.tanh(e/1e6)},whale_flow:()=>{const e=n.whaleFlow||{buy:0,sell:0},t=(e.buy||0)-(e.sell||0);return Math.tanh(t/1e5)},support_resistance:()=>{const e=n.supportResistance||{};return e.nearSupport?.7:e.nearResistance?-.7:0},order_blocks:()=>{const e=n.orderBlocks||{};return e.bullish?.5:e.bearish?-.5:0},fvg:()=>{const e=n.fvg||{};return e.bullish?.3:e.bearish?-.3:0},liquidity:()=>{const e=n.liquidity||{},t=e.buyLiquidity||e.buy||0,i=e.sellLiquidity||e.sell||0;return 0===t&&0===i?0:t>i?.4:-.4},candlestick_patterns:()=>{const e=n.patterns||[];let t=0;return e.forEach(e=>{"bullish"!==e.type&&"bullish"!==e.bias||(t+=.3),"bearish"!==e.type&&"bearish"!==e.bias||(t-=.3)}),Math.max(-1,Math.min(1,t))},chart_patterns:()=>{const e=n.chartPattern;return e?"bullish"===e.bias?.6:"bearish"===e.bias?-.6:0:0},divergences:()=>{const e=n.divergence||i.divergence;return e?"bullish"===e.type?.8:"bearish"===e.type?-.8:0:0},mtf_1m:()=>this.getMTFValue(n,"1m"),mtf_5m:()=>this.getMTFValue(n,"5m"),mtf_15m:()=>this.getMTFValue(n,"15m"),mtf_1h:()=>this.getMTFValue(n,"1h"),mtf_4h:()=>this.getMTFValue(n,"4h"),rsi_momentum:()=>{const e=i.rsi?.value??50,t=i.rsi?.prev??e;return Math.tanh((e-t)/10)},macd_acceleration:()=>{const e=i.macd;if(!e)return 0;const t=e.histogram??0,n=e.prevHistogram??t;return Math.tanh(20*(t-n))},volume_trend:()=>{const e=n.volume||{},t=e.ratio??e.volumeRatio??1;return Math.tanh(2*(t-1))},volatility_regime:()=>{const e=n.atr??0,t=n.atrAvg??e;return 0===t?0:Math.tanh(2*(e/t-1))},whale_pressure:()=>{const e=n.whaleFlow||{buy:0,sell:0},t=(e.buy||0)-(e.sell||0),i=(e.buy||0)+(e.sell||0);return 0===i?0:t/i},order_imbalance:()=>{const e=n.orderbook||n.depth||{},t=e.bidVolume??e.bids??0,i=e.askVolume??e.asks??0,o=t+i;return 0===o?0:(t-i)/o},mtf_alignment:()=>{const e=n.mtf||{};let t=0,i=0,o=0;for(const n of["1m","5m","15m","1h","4h"]){const r=e[n]?.signal;"bull"===r?(t++,o++):"bear"===r?(i++,o++):r&&o++}return 0===o?0:(t-i)/o},trend_strength:()=>{const e=i.adx;if(!e)return 0;const t=e.value??20,n=(t-(e.prev??t))/10;return("bull"===e.trend?1:"bear"===e.trend?-1:0)*Math.min(1,t/40)*(1+n)},momentum_divergence:()=>{const e=n.divergence||i.divergence;if(e)return"bullish"===e.type?.9:"bearish"===e.type?-.9:0;const t=i.rsi?.value??50,o=n.price??0,r=n.prevPrice??o;return o>r&&t<40?.5:o<r&&t>60?-.5:0},liquidity_zones:()=>{const e=n.liquidity||{},t=e.nearBuyZone??!1,i=e.nearSellZone??!1;return t&&!i?.6:i&&!t?-.6:0}};if("price_momentum"===e){const e=n.price||0,t=n.prevPrice||e;if(e>0&&t>0){const i=(e-t)/t;return Math.tanh(100*i)}return 0}const r=o[e];if(r)try{return r()}catch(t){return this.config.debugMode&&console.warn(`[AI-PRO] Feature error: ${e}`,t.message),null}return null},getMTFValue(e,t){const i=(e.mtf||{})[t];return i?"bull"===i.signal?1:"bear"===i.signal?-1:0:0},detectMarketRegime(e){const t=e.indicators||{},i=t.adx?.value??20,n=t.adx?.trend??"neutral",o=e.volatility??"normal",r=e.price??0,s=t.ema?.ema20??r;if("high"===o||e.atr&&e.atrAvg&&e.atr>1.5*e.atrAvg)return"volatile";if(i>25){if("bull"===n||r>s)return"trending_up";if("bear"===n||r<s)return"trending_down"}return"ranging"},getRegimeConfidenceMultiplier:e=>({trending_up:1.1,trending_down:1.1,ranging:.95,volatile:.9}[e]||1),getSessionContext(){const e=(new Date).getUTCHours();return e>=0&&e<8?"ASIA":e>=8&&e<16?"EUROPE":"US"},getSessionConfidenceMultiplier:e=>({ASIA:.95,EUROPE:1.02,US:1.02}[e]||1),getVolatilityScore(e){const t=e.atr,i=e.atrAvg;if(!t||!i||i<=0)return"high"===e.volatility?.85:"low"===e.volatility?.25:.5;const n=t/i;return Math.max(0,Math.min(1,(n-.5)/1.5))},getVolatilityBucket:e=>e>=.75?"HIGH":e<=.35?"LOW":"NORMAL",getVolatilityConfidenceMultiplier:e=>e>=.8?.92:e>=.65?.96:e<=.25?1.02:1,detectBreakoutContext(e){const t=e||{},i=t.price||0,n=t.supportResistance||{},o=t.indicators||{},r=this.getVolatilityScore(t),s=n.resistance||n.r1||n.R1||null,a=n.support||n.s1||n.S1||null,c=o.obv?.value??t.obv,l=t.cvd,u=t.lastCandle||t.candle||null;let d=null;if(u&&null!=u.high&&null!=u.low){const e=Math.max(1e-9,u.high-u.low);d=(e-Math.abs((u.close||0)-(u.open||0)))/e}const h=t.atr||null,m=e=>{if(!e||!i)return null;const t=h&&h>0?h:.002*i;return Math.abs(i-e)/t},g=s?m(s):null,f=a?m(a):null;let p=0,y="NONE";null!=d&&d>.55&&(p+=.25),r>=.75&&(p+=.25),(null!=c&&c<0||null!=l&&l<0)&&(p+=.2),null!=g&&g<1.5&&(p+=.2,y="AT_RESISTANCE"),null!=f&&f<1.5&&(p+=.2,y="AT_SUPPORT"),p=Math.max(0,Math.min(1,p));const b=1-p;let v="NEUTRAL";return p>=.6?v="FAKE_BREAKOUT_RISK":b>=.65&&(null!=g||null!=f)&&(v="CONTINUATION_LIKELY"),{risk:p,quality:b,tag:y,classification:v}},queryLongTermMemory(e){const t=this.detectMarketRegime(e),i=this.extractFeatureVector(e),n=this.config.sessionAware?this.getSessionContext():null,o=this.config.volatilityAware?this.getVolatilityScore(e):null,r=null!=o?this.getVolatilityBucket(o):null;let s=null,a=0;for(const e of this.memory.patterns){if(e.regime!==t)continue;let o=1;n&&e.session&&e.session!==n&&(o*=.9),r&&e.volBucket&&e.volBucket!==r&&(o*=.9);const c=this.calculateSimilarity(i,e.features)*o;c>a&&c>.72&&(a=c,s=e)}return s?{found:!0,confidence:a*s.successRate,direction:s.direction,occurrences:s.occurrences,avgReturn:s.avgReturn,session:s.session||null,volBucket:s.volBucket||null,lastOutcome:s.lastOutcome||null}:{found:!1}},extractFeatureVector(e){const t={},i=new Set;for(const e of Object.values(this.models))e.features.forEach(e=>i.add(e));Object.keys(this.features.derived).forEach(e=>i.add(e));for(const n of i){const i=this.getFeatureValue(n,e);null==i||isNaN(i)||(t[n]=i)}return this.config.debugMode&&0===Object.keys(t).length&&console.warn("[AI-PRO] Empty feature vector - check market state"),t},calculateSimilarity(e,t){const i=Object.keys(e).filter(i=>void 0!==t[i]&&null!==e[i]&&null!==t[i]&&!isNaN(e[i])&&!isNaN(t[i]));if(0===i.length)return 0;let n=0;for(const o of i)n+=1-Math.abs(e[o]-t[o]);return n/i.length},storeInLongTermMemory(e,t){const i=this.config.sessionAware?e.session||this.getSessionContext():null,n=this.config.volatilityAware?e.volScore??this.getVolatilityScore(this.getCurrentMarketState()):null,o=null!=n?this.getVolatilityBucket(n):null,r=e.breakout||null,s={id:Date.now().toString(36),regime:e.regime,direction:e.direction,features:e.features||{},session:i,volBucket:o,breakoutTag:r?.classification||null,successCount:t.success?1:0,failCount:t.success?0:1,successRate:t.success?1:0,occurrences:1,avgReturn:t.priceChange||0,lastOutcome:t.success?"POS":"NEG",timestamp:Date.now()},a=this.memory.patterns.find(e=>e.regime===s.regime&&this.calculateSimilarity(e.features,s.features)>.85);a?(a.occurrences++,a.successCount=(a.successCount||0)+(t.success?1:0),a.failCount=(a.failCount||0)+(t.success?0:1),a.successRate=a.successCount/a.occurrences,a.avgReturn=(a.avgReturn*(a.occurrences-1)+(t.priceChange||0))/a.occurrences,a.timestamp=Date.now(),a.lastOutcome=t.success?"POS":"NEG",i&&(a.session=i),o&&(a.volBucket=o),this.config.debugMode&&console.log(`[AI-PRO] Pattern updated: ${a.id} (${a.occurrences} occ, ${(100*a.successRate).toFixed(1)}% win)`)):(this.memory.patterns.push(s),this.config.debugMode&&console.log(`[AI-PRO] New pattern stored: ${s.id} (${s.direction})`),this.memory.patterns.length>this.config.maxLongTermPatterns&&(this.memory.patterns.sort((e,t)=>{const i=e.successRate*Math.log(e.occurrences+1);return t.successRate*Math.log(t.occurrences+1)-i}),this.memory.patterns=this.memory.patterns.slice(0,this.config.maxLongTermPatterns)))},recordProPrediction(e,t){const i=this.getCurrentMarketState(),n=this.generateEnsemblePrediction(i),o={id:"pro_"+t,baseId:t,timestamp:Date.now(),price:window.state?.price||0,ensemble:n,features:this.extractFeatureVector(i),regime:n.regime,verifications:[],outcome:null};this.predictions.pending.push(o);for(const e of this.config.horizons)setTimeout(()=>this.verifyProPrediction(o.id,e),6e4*e);return n.confidence>.75&&console.log(`[AI-PRO] High confidence ${n.direction}: ${(100*n.confidence).toFixed(1)}%`),o.id},verifyProPrediction(e,t){const i=this.predictions.pending.find(t=>t.id===e);if(!i||!window.state?.price||!i.price)return;const n=(window.state.price-i.price)/i.price*100,o=i.ensemble.direction,r="NEUTRAL"===o?.05:.1,s="BULL"===o&&n>r||"BEAR"===o&&n<-r||"NEUTRAL"===o&&Math.abs(n)<.15;i.verifications.push({horizon:t,priceChange:n,success:s,timestamp:Date.now()}),this._lastVerification={horizon:t,priceChange:n.toFixed(3),success:s,timestamp:Date.now()},this.predictions.byHorizon[t]&&(this.predictions.byHorizon[t].total++,s&&this.predictions.byHorizon[t].correct++,this.predictions.byHorizon[t].accuracy=this.predictions.byHorizon[t].correct/this.predictions.byHorizon[t].total);const a=this.config.autoMaxHorizon||15,c=Math.max(...this.config.horizons);(i.isAuto&&t===a||!i.isAuto&&t===c)&&this.completeProPrediction(i)},rescheduleVerifications(e){if(!e||!e.id||!e.timestamp)return;const t=Date.now(),i=(e.timestamp,e.verifications?e.verifications.map(e=>e.horizon):[]),n=e.isAuto?this.config.horizons.filter(e=>e<=(this.config.autoMaxHorizon||15)):this.config.horizons;for(const o of n){if(i.includes(o))continue;const n=e.timestamp+6e4*o-t;n>0?setTimeout(()=>this.verifyProPrediction(e.id,o),n):n>-3e5&&setTimeout(()=>this.verifyProPrediction(e.id,o),1e3)}},completeProPrediction(e){const t=e.verifications||[],i=Math.min(this.config.minValidationsToLearn,this.config.horizons.length),n=Math.min(this.config.minValidationsToLearnAuto||4,this.config.horizons.length),o=e&&e.isAuto?n:i,r=Math.max(...this.config.horizons);let s=0,a=0,c=0;for(const e of t){const t=.5+e.horizon/r;a+=t,e.success&&(s+=t),c+=e.priceChange}const l=a>0?s/a:0,u=l>=.55,d=t.length?c/t.length:0,h=t.filter(e=>e.success).length;e.outcome={success:u,avgPriceChange:d,successRate:t.length?h/t.length:0,successRateWeighted:l,completedAt:Date.now()},this.updateModelWeights(e,u);const m=e.ensemble?.confidence||0,g=e.ensemble?.breakout;(m>=.7||Math.abs(d)>=.35||g&&"NEUTRAL"!==g.classification)&&t.length>=o&&(e.session=e.ensemble?.session,e.volScore=e.ensemble?.volScore,e.breakout=e.ensemble?.breakout,this.storeInLongTermMemory(e,{success:u,priceChange:d})),this.predictions.completed.push(e),this.predictions.pending=this.predictions.pending.filter(t=>t.id!==e.id),this.updatePerformance(e),this.predictions.completed.length>500&&(this.predictions.completed=this.predictions.completed.slice(-500)),this.performance.overall.totalPredictions%10==0&&this.saveState()},updateModelWeights(e,t){const i=this.config.learningRate;for(const[n,o]of Object.entries(e.ensemble.modelPredictions)){const r=this.models[n];if(!r)continue;const s=t&&o.direction===e.ensemble.direction||!t&&o.direction!==e.ensemble.direction;r.predictions++,s&&r.correct++;const a=r.correct/r.predictions;r.accuracy=.9*r.accuracy+.1*a,r.predictions>=20&&(r.accuracy>.55?r.weight=Math.min(2,r.weight+i):r.accuracy<.45&&(r.weight=Math.max(.3,r.weight-i)))}},updateProModels(e){if(e.outcome?.success)for(const t of Object.keys(e.indicators||{}))for(const e of Object.values(this.models))e.features.includes(t)&&(e.accuracy=.98*e.accuracy+.02)},updatePerformance(e){const t=this.performance.overall;t.totalPredictions++,e.outcome.success&&t.correctPredictions++,t.accuracy=t.correctPredictions/t.totalPredictions;const i=(new Date).toISOString().split("T")[0];this.performance.daily[i]||(this.performance.daily[i]={total:0,correct:0,returns:[]});const n=this.performance.daily[i];n.total++,e.outcome.success&&n.correct++,n.returns.push(e.outcome.avgPriceChange);const o=Object.keys(this.performance.daily).sort();for(;o.length>30;)delete this.performance.daily[o.shift()]},startOptimizationLoop(){setInterval(()=>this.runOptimization(),this.config.optimizationInterval),setTimeout(()=>this.runOptimization(),3e5)},runOptimization(){console.log("[AI-PRO] Running auto-optimization...");const e=this.predictions.completed.slice(-50);if(e.length>=20){const t=e.filter(e=>e.outcome.success).length/e.length;t<.45?this.config.learningRate=Math.min(.1,1.2*this.config.learningRate):t>.6&&(this.config.learningRate=Math.max(.01,.9*this.config.learningRate))}this.memory.patterns=this.memory.patterns.filter(e=>e.occurrences>=3||Date.now()-e.timestamp<864e5);const t=Object.entries(this.predictions.byHorizon).filter(([e,t])=>t.total>=10).sort(([e,t],[i,n])=>n.accuracy-t.accuracy)[0];t&&console.log(`[AI-PRO] Best horizon: ${t[0]}min (${(100*t[1].accuracy).toFixed(1)}%)`),this.saveState(),console.log("[AI-PRO] Optimization complete. Accuracy:",(100*this.performance.overall.accuracy).toFixed(1)+"%"),console.log("[AI-PRO] Memory patterns:",this.memory.patterns.length),console.log("[AI-PRO] Pending predictions:",this.predictions.pending.length)},startAutoPrediction(){setInterval(()=>{this.generateAutoPrediction()},6e4),setTimeout(()=>{console.log("[AI-PRO] ðŸš€ Generating FIRST auto-prediction..."),this.generateAutoPrediction()},5e3),setTimeout(()=>{console.log("[AI-PRO] ðŸš€ Generating SECOND auto-prediction..."),this.generateAutoPrediction()},15e3),console.log("[AI-PRO] Auto-prediction started (every 1 min, first in 5s)")},generateAutoPrediction(){if(console.log("[AI-PRO] === Auto-prediction attempt ==="),!this.isReady)return void console.log("[AI-PRO] âŒ Skipping: not ready");const e=window.state?.price;if(!e)return void console.log("[AI-PRO] âŒ Skipping: no price data (window.state.price =",e,")");console.log("[AI-PRO] âœ“ Price available:",e);const t=this.config.maxPending||25;if(this.predictions.pending.length>=t)return void console.log("[AI-PRO] â¸ Skipping: too many pending ("+this.predictions.pending.length+"/"+t+")");const i=this.getCurrentMarketState();console.log("[AI-PRO] Market state:",{price:i.price,hasIndicators:!!i.indicators&&Object.keys(i.indicators||{}).length>0,indicatorKeys:Object.keys(i.indicators||{}).slice(0,5)});const n=this.generateEnsemblePrediction(i);if(console.log("[AI-PRO] Ensemble result:",{direction:n.direction,confidence:(100*n.confidence).toFixed(1)+"%",threshold:100*this.config.minConfidence+"%",passes:n.confidence>=this.config.minConfidence}),n.confidence<.15)return void console.log("[AI-PRO] âŒ Skipping: extremely low confidence");const o="auto_"+Date.now().toString(36)+Math.random().toString(36).substr(2,5),r={id:o,baseId:null,timestamp:Date.now(),price:window.state.price,ensemble:n,features:this.extractFeatureVector(i),regime:n.regime,verifications:[],outcome:null,isAuto:!0};this.predictions.pending.push(r),this._sessionPredictions=(this._sessionPredictions||0)+1,this._lastPredictionTime=Date.now();const s=this.config.horizons.filter(e=>e<=(this.config.autoMaxHorizon||15));for(const e of s)setTimeout(()=>this.verifyProPrediction(o,e),6e4*e);console.log(`[AI-PRO] ðŸŽ¯ Auto-prediction #${this._sessionPredictions}: ${n.direction} @ ${(100*n.confidence).toFixed(1)}% | Price: ${window.state.price.toFixed(4)} | Pending: ${this.predictions.pending.length}`)},async loadState(){if(this.db)try{const{doc:e,getDoc:t}=window.AILearning.firestore,i=await t(e(this.db,"ai","pro_models"));if(i.exists()){const e=i.data();for(const[t,i]of Object.entries(e))this.models[t]&&Object.assign(this.models[t],i)}const n=await t(e(this.db,"ai","pro_memory"));if(n.exists()){const e=n.data();this.memory.patterns=e.patterns||[],this.memory.correlations=e.correlations||{}}const o=await t(e(this.db,"ai","pro_performance"));o.exists()&&Object.assign(this.performance,o.data());const r=await t(e(this.db,"ai","pro_horizons"));if(r.exists()){const e=r.data();for(const[t,i]of Object.entries(e))this.predictions.byHorizon[t]&&Object.assign(this.predictions.byHorizon[t],i)}const s=await t(e(this.db,"ai","pro_pending"));if(s.exists()){const e=s.data();if(e.pending&&Array.isArray(e.pending)){const t=Date.now(),i=this.config.maxPending||25,n=e.pending.filter(e=>e&&"object"==typeof e&&e.timestamp&&t-e.timestamp<18e6).sort((e,t)=>(e.timestamp||0)-(t.timestamp||0)).slice(-i);let o=0;for(const e of n)e.id||(e.id=`restored_${e.timestamp||t}_${Math.random().toString(36).slice(2,9)}`),"boolean"!=typeof e.isAuto&&(e.isAuto=!0),this.predictions.pending.push(e),this.rescheduleVerifications(e),o++;e.pending.length>i&&console.log(`[AI-PRO] Pending trimmed on load: ${e.pending.length} -> ${o}`),o>0&&console.log(`[AI-PRO] Restored ${o} pending predictions`)}}return console.log("[AI-PRO] State loaded from Firestore"),void console.log("[AI-PRO] Memory patterns:",this.memory.patterns.length)}catch(e){console.warn("[AI-PRO] Firestore load failed:",e)}try{const e=localStorage.getItem("ai_pro_state");if(e){const t=JSON.parse(e);if(t.models&&Object.assign(this.models,t.models),t.memory&&Object.assign(this.memory,t.memory),t.performance&&Object.assign(this.performance,t.performance),t.horizons)for(const[e,i]of Object.entries(t.horizons))this.predictions.byHorizon[e]&&Object.assign(this.predictions.byHorizon[e],i);console.log("[AI-PRO] State loaded from localStorage")}}catch(e){}},async saveState(){if(this.db&&window.AILearning?.user)try{const{doc:e,setDoc:t}=window.AILearning.firestore,i={};for(const[e,t]of Object.entries(this.models))i[e]={weight:t.weight,accuracy:t.accuracy,predictions:t.predictions,correct:t.correct};await t(e(this.db,"ai","pro_models"),i),await t(e(this.db,"ai","pro_memory"),{patterns:this.memory.patterns.slice(-500),correlations:this.memory.correlations,updatedAt:(new Date).toISOString()}),await t(e(this.db,"ai","pro_performance"),this.performance),await t(e(this.db,"ai","pro_horizons"),this.predictions.byHorizon);const n=this.config.maxPending||25;await t(e(this.db,"ai","pro_pending"),{pending:this.predictions.pending.slice(-n),updatedAt:Date.now()})}catch(e){console.warn("[AI-PRO] Firestore save failed:",e)}try{localStorage.setItem("ai_pro_state",JSON.stringify({models:this.models,memory:{patterns:this.memory.patterns.slice(-100),correlations:this.memory.correlations},performance:this.performance,horizons:this.predictions.byHorizon}))}catch(e){}},deriveIndicatorsFromState(e,t,i){try{const n=this._getCandlesFromState(e),o=n.length?n[n.length-1]:e.lastCandle||e.candle||e.lastOHLC||null;if(!n.length)return{indicators:e.indicators||{},volume:e.volume,atr:e.atr,atrAvg:e.atrAvg,volatility:e.volatility,lastCandle:o};const r=n.map(e=>this._getCandleClose(e)).filter(e=>Number.isFinite(e)),s=(n.map(e=>this._getCandleHigh(e)).filter(e=>Number.isFinite(e)),n.map(e=>this._getCandleLow(e)).filter(e=>Number.isFinite(e)),n.map(e=>this._getCandleVol(e)).filter(e=>Number.isFinite(e)));if(r.length<20)return{indicators:e.indicators||{},volume:e.volume,atr:e.atr,atrAvg:e.atrAvg,volatility:e.volatility,lastCandle:o};const a=this._calcRSI(r,14),c=this._calcStochRSI(r,14,14),l=this._calcEMA(r,9),u=this._calcEMA(r,21),d=this._calcEMA(r,20),h=this._calcMACD(r,12,26,9),m=this._calcATR(n,14),g=this._calcATR(n,50),f=Number.isFinite(t)?t:r[r.length-1],p=Number.isFinite(m)&&f>0?m/f:0,y=p>.012?"high":p>.006?"normal":"low",b=Math.min(10,r.length-1),v=r[r.length-1-b]||r[0],A=v&&0!==v?(r[r.length-1]-v)/v*100:0,_=this._calcOBV(n),w=l>1.0005*u?"bull":l<.9995*u?"bear":"neutral",P=f>0?Math.abs(l-u)/f:0,R=Math.max(8,Math.min(55,18+800*P)),M="neutral"===w?f>d?"bull":"bear":w;let O=null;if(r.length>=25){const e=r[r.length-1],t=r[r.length-11],i=this._calcRSI(r.slice(0,r.length),14),n=this._calcRSI(r.slice(0,r.length-10),14);Number.isFinite(e)&&Number.isFinite(t)&&Number.isFinite(i)&&Number.isFinite(n)&&(e<t&&i>n?O={type:"bullish"}:e>t&&i<n&&(O={type:"bearish"}))}const I=s.length?s[s.length-1]:this._getCandleVol(o)||0,C=s.slice(-20),S=C.length?C.reduce((e,t)=>e+t,0)/C.length:I,F={ratio:S>0?I/S:1,trend:I>1.1*S?"increasing":I<.9*S?"decreasing":"stable"},L=Object.assign({},e.indicators||{});return null==L.rsi&&(L.rsi={value:a}),"number"==typeof L.rsi&&(L.rsi={value:L.rsi}),null==L.stochRsi&&(L.stochRsi={value:c}),"number"==typeof L.stochRsi&&(L.stochRsi={value:L.stochRsi}),null==L.macd&&(L.macd={histogram:h.histogram,signal:h.histogram>=0?"bull":"bear"}),"number"==typeof L.macd&&(L.macd={histogram:L.macd,signal:L.macd>=0?"bull":"bear"}),null==L.ema&&(L.ema={emaFast:l,emaSlow:u,ema20:d,signal:w}),null==L.adx&&(L.adx={value:R,trend:w}),null==L.supertrend&&(L.supertrend={signal:M}),null==L.obv&&(L.obv=_),null==L.momentum&&(L.momentum={value:A,signal:A>=0?"bull":"bear"}),O&&null==L.divergence&&(L.divergence=O),"number"!=typeof e.prevPrice&&Number.isFinite(i),{indicators:L,volume:e.volume||F,atr:Number.isFinite(e.atr)?e.atr:m,atrAvg:Number.isFinite(e.atrAvg)?e.atrAvg:g,volatility:e.volatility||y,lastCandle:o}}catch(t){return{indicators:e.indicators||{},volume:e.volume,atr:e.atr,atrAvg:e.atrAvg,volatility:e.volatility,lastCandle:e.lastCandle||e.candle||e.lastOHLC||null}}},_getCandlesFromState:e=>Array.isArray(e.candles)&&e.candles.length?e.candles:Array.isArray(e.ohlc)&&e.ohlc.length?e.ohlc:Array.isArray(e.ohlcHistory)&&e.ohlcHistory.length?e.ohlcHistory:[],_getCandleClose(e){return e?this._num(e.close??e.c??e.C??e[4],NaN):NaN},_getCandleHigh(e){return e?this._num(e.high??e.h??e.H??e[2],NaN):NaN},_getCandleLow(e){return e?this._num(e.low??e.l??e.L??e[3],NaN):NaN},_getCandleVol(e){return e?this._num(e.volume??e.v??e.V??e[5],NaN):NaN},_num(e,t=0){const i="string"==typeof e?parseFloat(e):e;return Number.isFinite(i)?i:t},_calcEMA(e,t){if(!Array.isArray(e)||0===e.length)return NaN;const i=2/(Math.max(2,0|t)+1);let n=e[0];for(let t=1;t<e.length;t++){const o=e[t];Number.isFinite(o)&&(n=o*i+n*(1-i))}return n},_calcRSI(e,t=14){if(!Array.isArray(e)||e.length<t+2)return 50;const i=Math.max(2,0|t);let n=0,o=0;for(let t=e.length-i;t<e.length;t++){const i=e[t-1],r=e[t];if(!Number.isFinite(i)||!Number.isFinite(r))continue;const s=r-i;s>=0?n+=s:o-=s}const r=o/i;if(0===r)return 100;const s=100-100/(1+n/i/r);return Math.max(0,Math.min(100,s))},_calcMACD(e,t=12,i=26,n=9){if(!Array.isArray(e)||e.length<i+n)return{histogram:0};const o=this._calcEMA(e,t)-this._calcEMA(e,i),r=Math.min(60,e.length),s=[];for(let n=e.length-r;n<e.length;n++){const o=e.slice(0,n+1);s.push(this._calcEMA(o,t)-this._calcEMA(o,i))}return{histogram:o-this._calcEMA(s,n)}},_calcATR(e,t=14){if(!Array.isArray(e)||e.length<3)return NaN;const i=Math.max(2,0|t);let n=0,o=0;for(let t=Math.max(1,e.length-i);t<e.length;t++){const i=e[t],r=e[t-1],s=this._getCandleHigh(i),a=this._getCandleLow(i),c=this._getCandleClose(r);if(![s,a,c].every(Number.isFinite))continue;n+=Math.max(s-a,Math.abs(s-c),Math.abs(a-c)),o++}return o?n/o:NaN},_calcStochRSI(e,t=14,i=14){if(!Array.isArray(e)||e.length<t+i+2)return 50;const n=[];for(let i=t+1;i<e.length;i++)n.push(this._calcRSI(e.slice(0,i+1),t));const o=n.slice(-i),r=o[o.length-1],s=Math.min(...o),a=Math.max(...o);if(a===s)return 50;const c=(r-s)/(a-s)*100;return Math.max(0,Math.min(100,c))},_calcOBV(e){if(!Array.isArray(e)||e.length<3)return{value:0,signal:"neutral",slope:0};let t=0;for(let i=1;i<e.length;i++){const n=this._getCandleClose(e[i-1]),o=this._getCandleClose(e[i]),r=this._getCandleVol(e[i]);[n,o,r].every(Number.isFinite)&&(o>n?t+=r:o<n&&(t-=r))}const i=Math.min(10,e.length-2);let n=0;for(let t=e.length-i;t<e.length;t++){const i=this._getCandleClose(e[t-1]),o=this._getCandleClose(e[t]),r=this._getCandleVol(e[t]);[i,o,r].every(Number.isFinite)&&(o>i?n+=r:o<i&&(n-=r))}return{value:t,signal:n>0?"bull":n<0?"bear":"neutral",slope:n}},getCurrentMarketState(){const e=window.state||{},t="number"==typeof e.price?e.price:"number"==typeof e.currentPrice?e.currentPrice:"number"==typeof e.lastPrice?e.lastPrice:0,i="number"==typeof e.prevPrice?e.prevPrice:"number"==typeof this._lastPriceSeen?this._lastPriceSeen:t;Number.isFinite(t)&&(this._lastPriceSeen=t);const n=Date.now();if(!this._derivedCache||n-this._derivedCache.ts>750){const o=this.deriveIndicatorsFromState(e,t,i);this._derivedCache=Object.assign({ts:n},o)}const o=this._derivedCache||{};return{price:t,prevPrice:i,indicators:o.indicators||e.indicators||{},indicatorKeys:Object.keys(o.indicators||e.indicators||{}),volume:o.volume||e.volume,cvd:e.cvd,whaleFlow:e.whaleFlow,supportResistance:e.supportResistance,orderBlocks:e.orderBlocks,fvg:e.fvg,liquidity:e.liquidity,patterns:e.patterns,chartPattern:e.chartPattern,divergence:e.divergence||o.indicators&&o.indicators.divergence||null,mtf:e.mtf,volatility:o.volatility||e.volatility,atr:o.atr??e.atr,atrAvg:o.atrAvg??e.atrAvg,lastCandle:o.lastCandle||e.lastCandle||e.candle||e.lastOHLC||null,orderbook:e.orderbook||e.depth||null}},getPrediction(){const e=this.getCurrentMarketState();return this.generateEnsemblePrediction(e)},getModelStats(){const e={};for(const[t,i]of Object.entries(this.models))e[t]={weight:i.weight.toFixed(2),accuracy:(100*i.accuracy).toFixed(1)+"%",predictions:i.predictions};return e},getStats(){const e=this.performance?.overall||{accuracy:0,totalPredictions:0,correctPredictions:0},t=this.performance?.daily||{},i=this.predictions?.byHorizon||{},n={};for(const[e,t]of Object.entries(i))n[e]={accuracy:"number"==typeof t?.accuracy?t.accuracy:0,total:"number"==typeof t?.total?t.total:0,correct:"number"==typeof t?.correct?t.correct:0};const o=Array.isArray(this.config.shortHorizons)?this.config.shortHorizons:[2,5,10,15];let r=0,s=0;for(const e of o){const t=i?.[e];t&&(r+="number"==typeof t.total?t.total:0,s+="number"==typeof t.correct?t.correct:0)}const a={...e};0===(a.totalPredictions||0)&&r>0&&(a.totalPredictions=r,a.correctPredictions=s,a.accuracy=s/r);const c=this.predictions?.completed?.length||0,l=this.performance?.overall?.totalPredictions||0,u=r,d=Math.max(c,l,u),h=this._sessionStart||Date.now(),m=Math.max(0,Math.floor((Date.now()-h)/6e4));return{overall:a,daily:t,session:{predictions:this._sessionPredictions||0,uptime:m,lastVerification:this._lastVerification||null},horizons:n,memory:{patterns:this.memory?.patterns?.length||0,pending:this.predictions?.pending?.length||0,completed:d},models:"function"==typeof this.getModelStats?this.getModelStats():{}}},forceSave(){return this.saveState()},debugFeatures(){const e=this.getCurrentMarketState(),t=this.extractFeatureVector(e);return console.log("[AI-PRO] Feature vector:",t),console.log("[AI-PRO] Features extracted:",Object.keys(t).length),t}};"loading"===document.readyState?document.addEventListener("DOMContentLoaded",()=>{setTimeout(()=>AIEnginePro.init(),2e3)}):setTimeout(()=>AIEnginePro.init(),2e3),window.AIEnginePro=AIEnginePro,console.log("[AI-PRO] AI Engine PRO v1.6.9 loaded (always-active mode)");