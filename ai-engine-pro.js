"use strict";const AIEnginePro={version:"1.6.9",__okrtBuild:"2026-01-18.quota-nomerge",isReady:!1,db:null,config:{horizons:[2,5,10,15,30,60,120,240],minConfidence:.3,ensembleThreshold:.4,learningRate:.03,decayRate:.995,maxLongTermPatterns:2e3,maxMarketCycles:100,optimizationInterval:36e5,featureThreshold:.1,minValidationsToLearn:6,autoMaxHorizon:15,minValidationsToLearnAuto:4,maxPending:25,sessionAware:!0,volatilityAware:!0,breakoutAware:!0,debugMode:!0},models:{momentum:{name:"Momentum",weight:1,accuracy:.5,features:["rsi","stoch_rsi","momentum","rsi_divergence","price_momentum"],predictions:0,correct:0},trend:{name:"Trend",weight:1,accuracy:.5,features:["ema_cross","macd","adx","supertrend","price_momentum"],predictions:0,correct:0},volume:{name:"Volume",weight:1,accuracy:.5,features:["volume","obv","cvd","whale_flow"],predictions:0,correct:0},structure:{name:"Structure",weight:1,accuracy:.5,features:["support_resistance","order_blocks","fvg","liquidity"],predictions:0,correct:0},patterns:{name:"Patterns",weight:1,accuracy:.5,features:["candlestick_patterns","chart_patterns","divergences","price_momentum"],predictions:0,correct:0},mtf:{name:"MTF",weight:1.2,accuracy:.5,features:["mtf_1m","mtf_5m","mtf_15m","mtf_1h","mtf_4h"],predictions:0,correct:0}},features:{derived:{rsi_momentum:{weight:1,formula:"rsi_change_rate"},macd_acceleration:{weight:1,formula:"macd_histogram_change"},volume_trend:{weight:1,formula:"volume_ma_ratio"},volatility_regime:{weight:1,formula:"atr_percentile"},whale_pressure:{weight:1.2,formula:"whale_buy_sell_ratio"},order_imbalance:{weight:1.1,formula:"bid_ask_imbalance"},mtf_alignment:{weight:1.3,formula:"timeframe_confluence"},trend_strength:{weight:1,formula:"adx_slope"},momentum_divergence:{weight:1.2,formula:"price_rsi_divergence"},liquidity_zones:{weight:1.1,formula:"nearby_liquidity"}},stats:{}},predictions:{pending:[],completed:[],byHorizon:{2:{total:0,correct:0,accuracy:.5},5:{total:0,correct:0,accuracy:.5},10:{total:0,correct:0,accuracy:.5},15:{total:0,correct:0,accuracy:.5},30:{total:0,correct:0,accuracy:.5},60:{total:0,correct:0,accuracy:.5},120:{total:0,correct:0,accuracy:.5},240:{total:0,correct:0,accuracy:.5}}},memory:{patterns:[],marketCycles:[],correlations:{},regimeHistory:[],significantEvents:[]},performance:{daily:{},weekly:{},overall:{totalPredictions:0,correctPredictions:0,accuracy:0,profitFactor:1,sharpeRatio:0,maxDrawdown:0}},async init(){console.log("[AI-PRO] Initializing AI Engine PRO v"+this.version+" with Auto-Prediction");let attempts=0;for(;!window.AILearning?.isInitialized&&attempts<50;)await new Promise(r=>setTimeout(r,100)),attempts++;return window.AILearning?.isInitialized?(this.db=window.AILearning.db,this.db||console.warn("[AI-PRO] Firestore not available, using local mode"),this.initializeHorizons(),this.validateFeatures(),await this.loadState(),this.startOptimizationLoop(),this.hookIntoBase(),this.startAutoPrediction(),this._sessionStart=Date.now(),this._sessionPredictions=0,this._lastPredictionTime=null,this._lastVerification=null,this.isReady=!0,console.log("[AI-PRO] âœ“ AI Engine PRO ready"),console.log("[AI-PRO] Models:",Object.keys(this.models).length),console.log("[AI-PRO] Features:",Object.keys(this.features.derived).length),console.log("[AI-PRO] Horizons:",this.config.horizons.join(", ")+" min"),console.log("[AI-PRO] Min confidence:",100*this.config.minConfidence+"%"),console.log("[AI-PRO] Ensemble threshold:",100*this.config.ensembleThreshold+"%"),setTimeout(()=>{const s=window.state||{};console.log("[AI-PRO] ðŸ“Š State check:",{price:s.price,hasIndicators:!!s.indicators,indicatorCount:Object.keys(s.indicators||{}).length,indicatorSample:Object.keys(s.indicators||{}).slice(0,8)})},3e3),!0):(console.error("[AI-PRO] Base AILearning not ready"),!1)},initializeHorizons(){for(const h of this.config.horizons)this.predictions.byHorizon[h]||(this.predictions.byHorizon[h]={total:0,correct:0,accuracy:.5},console.log(`[AI-PRO] Initialized horizon: ${h}min`))},validateFeatures(){const allFeatures=new Set;for(const model of Object.values(this.models))model.features.forEach(f=>allFeatures.add(f));Object.keys(this.features.derived).forEach(f=>allFeatures.add(f));const mapped=[],unmapped=[];for(const feature of allFeatures)this.hasFeatureMapping(feature)?mapped.push(feature):unmapped.push(feature);this.config.debugMode&&(console.log(`[AI-PRO] Features mapped: ${mapped.length}/${allFeatures.size}`),unmapped.length>0&&console.warn("[AI-PRO] Unmapped features:",unmapped.join(", ")))},hasFeatureMapping(feature){const mappedFeatures=void 0;return["rsi","stoch_rsi","momentum","rsi_divergence","price_momentum","ema_cross","macd","adx","supertrend","volume","obv","cvd","whale_flow","support_resistance","order_blocks","fvg","liquidity","candlestick_patterns","chart_patterns","divergences","mtf_1m","mtf_5m","mtf_15m","mtf_1h","mtf_4h","rsi_momentum","macd_acceleration","volume_trend","volatility_regime","whale_pressure","order_imbalance","mtf_alignment","trend_strength","momentum_divergence","liquidity_zones"].includes(feature)},hookIntoBase(){const originalRecordPrediction=window.AILearning.recordPrediction.bind(window.AILearning),originalComplete=window.AILearning.complete.bind(window.AILearning);window.AILearning.recordPrediction=pred=>{const id=originalRecordPrediction(pred);return this.recordProPrediction(pred,id),id},window.AILearning.complete=p=>{originalComplete(p),this.updateProModels(p)},console.log("[AI-PRO] Hooked into base AILearning")},generateEnsemblePrediction(marketState){const votes={BULL:0,BEAR:0,NEUTRAL:0},modelPredictions={};let totalWeight=0;for(const[modelName,model]of Object.entries(this.models)){const prediction=this.getModelPrediction(modelName,model,marketState);modelPredictions[modelName]=prediction;const weight=model.weight*model.accuracy;votes[prediction.direction]+=weight*prediction.confidence,totalWeight+=weight}for(const dir of Object.keys(votes))votes[dir]=totalWeight>0?votes[dir]/totalWeight:.33;let direction="NEUTRAL",confidence=.35;const maxVote=Math.max(votes.BULL,votes.BEAR,votes.NEUTRAL);votes.BULL>=votes.BEAR&&votes.BULL>=.8*votes.NEUTRAL?(direction="BULL",confidence=.35+.6*votes.BULL):votes.BEAR>=votes.BULL&&votes.BEAR>=.8*votes.NEUTRAL?(direction="BEAR",confidence=.35+.6*votes.BEAR):confidence=.3+.3*maxVote;const session=this.config.sessionAware?this.getSessionContext():null,volScore=this.config.volatilityAware?this.getVolatilityScore(marketState):null,volMultiplier=null!=volScore?this.getVolatilityConfidenceMultiplier(volScore):1,breakout=this.config.breakoutAware?this.detectBreakoutContext(marketState):null,regime=this.detectMarketRegime(marketState),regimeMultiplier=void 0;confidence*=this.getRegimeConfidenceMultiplier(regime),session&&(confidence*=this.getSessionConfidenceMultiplier(session)),confidence*=volMultiplier,breakout&&"FAKE_BREAKOUT_RISK"===breakout.classification&&(confidence*=.92);const patternMatch=this.queryLongTermMemory(marketState);return patternMatch.found&&(confidence=(confidence+patternMatch.confidence)/2,patternMatch.direction!==direction&&patternMatch.confidence>.7&&(confidence*=.85)),confidence=Math.max(.2,Math.min(.95,confidence)),{direction:direction,confidence:confidence,votes:votes,modelPredictions:modelPredictions,regime:regime,patternMatch:patternMatch,session:session,volScore:volScore,breakout:breakout,timestamp:Date.now()}},getModelPrediction(modelName,model,marketState){let bullScore=0,bearScore=0,featureCount=0;for(const feature of model.features){const value=this.getFeatureValue(feature,marketState);if(null==value)continue;const weight=window.AILearning?.getWeight?.(feature)||1;value>0?bullScore+=value*weight:value<0&&(bearScore+=Math.abs(value)*weight),featureCount++}if(0===featureCount){const priceMom=this.getFeatureValue("price_momentum",marketState)||0;return priceMom>.01?{direction:"BULL",confidence:.4+.3*priceMom,featureCount:1}:priceMom<-.01?{direction:"BEAR",confidence:.4+.3*Math.abs(priceMom),featureCount:1}:{direction:"NEUTRAL",confidence:.35,featureCount:0}}const total=bullScore+bearScore;if(0===total)return{direction:"NEUTRAL",confidence:.4,featureCount:featureCount};const bullProb=bullScore/total,bearProb=bearScore/total;let direction="NEUTRAL",confidence=.4;return bullProb>.52?(direction="BULL",confidence=.4+1.2*(bullProb-.5)):bearProb>.52&&(direction="BEAR",confidence=.4+1.2*(bearProb-.5)),{direction:direction,confidence:Math.min(.95,confidence),featureCount:featureCount}},getFeatureValue(feature,marketState){const indicators=marketState.indicators||{},s=marketState,featureMap={rsi:()=>{const rsi=void 0;return((indicators.rsi?.value??indicators.rsi??50)-50)/50},stoch_rsi:()=>{const stoch=void 0;return((indicators.stochRsi?.value??indicators.stochRsi??50)-50)/50},momentum:()=>{const m=indicators.momentum;return m?"bull"===m.signal?1:"bear"===m.signal?-1:0:0},rsi_divergence:()=>{const div=indicators.divergence||s.divergence;return div?"bullish"===div.type?1:"bearish"===div.type?-1:0:0},ema_cross:()=>{const ema=indicators.ema;return ema?"bull"===ema.signal?1:"bear"===ema.signal?-1:0:0},macd:()=>{const macd=indicators.macd;if(!macd)return 0;const hist=macd.histogram??macd.hist??0;return hist>0?Math.min(1,10*hist):Math.max(-1,10*hist)},adx:()=>{const adx=indicators.adx;if(!adx)return 0;const value=void 0,strength=(adx.value??adx.adx??20)>25?1:.5;return"bull"===adx.trend?strength:"bear"===adx.trend?-strength:0},supertrend:()=>{const st=indicators.supertrend;return st?"bull"===st.signal?1:"bear"===st.signal?-1:0:0},volume:()=>{const vol=s.volume||{};return"increasing"===vol.trend?.5:"decreasing"===vol.trend?-.5:0},obv:()=>{const obv=indicators.obv;return obv?"bull"===obv.signal?1:"bear"===obv.signal?-1:0:0},cvd:()=>{const cvd=s.cvd??0;return Math.tanh(cvd/1e6)},whale_flow:()=>{const whales=s.whaleFlow||{buy:0,sell:0},net=(whales.buy||0)-(whales.sell||0);return Math.tanh(net/1e5)},support_resistance:()=>{const sr=s.supportResistance||{};return sr.nearSupport?.7:sr.nearResistance?-.7:0},order_blocks:()=>{const ob=s.orderBlocks||{};return ob.bullish?.5:ob.bearish?-.5:0},fvg:()=>{const fvg=s.fvg||{};return fvg.bullish?.3:fvg.bearish?-.3:0},liquidity:()=>{const liq=s.liquidity||{},buy=liq.buyLiquidity||liq.buy||0,sell=liq.sellLiquidity||liq.sell||0;return 0===buy&&0===sell?0:buy>sell?.4:-.4},candlestick_patterns:()=>{const patterns=s.patterns||[];let score=0;return patterns.forEach(p=>{"bullish"!==p.type&&"bullish"!==p.bias||(score+=.3),"bearish"!==p.type&&"bearish"!==p.bias||(score-=.3)}),Math.max(-1,Math.min(1,score))},chart_patterns:()=>{const pattern=s.chartPattern;return pattern?"bullish"===pattern.bias?.6:"bearish"===pattern.bias?-.6:0:0},divergences:()=>{const div=s.divergence||indicators.divergence;return div?"bullish"===div.type?.8:"bearish"===div.type?-.8:0:0},mtf_1m:()=>this.getMTFValue(s,"1m"),mtf_5m:()=>this.getMTFValue(s,"5m"),mtf_15m:()=>this.getMTFValue(s,"15m"),mtf_1h:()=>this.getMTFValue(s,"1h"),mtf_4h:()=>this.getMTFValue(s,"4h"),rsi_momentum:()=>{const rsi=indicators.rsi?.value??50,prevRsi=indicators.rsi?.prev??rsi;return Math.tanh((rsi-prevRsi)/10)},macd_acceleration:()=>{const macd=indicators.macd;if(!macd)return 0;const hist=macd.histogram??0,prevHist=macd.prevHistogram??hist;return Math.tanh(20*(hist-prevHist))},volume_trend:()=>{const vol=s.volume||{},ratio=vol.ratio??vol.volumeRatio??1;return Math.tanh(2*(ratio-1))},volatility_regime:()=>{const atr=s.atr??0,atrAvg=s.atrAvg??atr;return 0===atrAvg?0:Math.tanh(2*(atr/atrAvg-1))},whale_pressure:()=>{const whales=s.whaleFlow||{buy:0,sell:0},net=(whales.buy||0)-(whales.sell||0),total=(whales.buy||0)+(whales.sell||0);return 0===total?0:net/total},order_imbalance:()=>{const ob=s.orderbook||s.depth||{},bidVol=ob.bidVolume??ob.bids??0,askVol=ob.askVolume??ob.asks??0,total=bidVol+askVol;return 0===total?0:(bidVol-askVol)/total},mtf_alignment:()=>{const mtf=s.mtf||{};let bullCount=0,bearCount=0,total=0;for(const tf of["1m","5m","15m","1h","4h"]){const signal=mtf[tf]?.signal;"bull"===signal?(bullCount++,total++):"bear"===signal?(bearCount++,total++):signal&&total++}return 0===total?0:(bullCount-bearCount)/total},trend_strength:()=>{const adx=indicators.adx;if(!adx)return 0;const value=adx.value??20,prevValue=void 0,slope=(value-(adx.prev??value))/10,dir=void 0;return("bull"===adx.trend?1:"bear"===adx.trend?-1:0)*Math.min(1,value/40)*(1+slope)},momentum_divergence:()=>{const div=s.divergence||indicators.divergence;if(div)return"bullish"===div.type?.9:"bearish"===div.type?-.9:0;const rsi=indicators.rsi?.value??50,price=s.price??0,prevPrice=s.prevPrice??price;return price>prevPrice&&rsi<40?.5:price<prevPrice&&rsi>60?-.5:0},liquidity_zones:()=>{const liq=s.liquidity||{},nearBuy=liq.nearBuyZone??!1,nearSell=liq.nearSellZone??!1;return nearBuy&&!nearSell?.6:nearSell&&!nearBuy?-.6:0}};if("price_momentum"===feature){const price=s.price||0,prevPrice=s.prevPrice||price;if(price>0&&prevPrice>0){const change=(price-prevPrice)/prevPrice;return Math.tanh(100*change)}return 0}const fn=featureMap[feature];if(fn)try{const value=void 0;return fn()}catch(e){return this.config.debugMode&&console.warn(`[AI-PRO] Feature error: ${feature}`,e.message),null}return null},getMTFValue(state,timeframe){const mtf=void 0,tf=(state.mtf||{})[timeframe];return tf?"bull"===tf.signal?1:"bear"===tf.signal?-1:0:0},detectMarketRegime(marketState){const indicators=marketState.indicators||{},adx=indicators.adx?.value??20,adxTrend=indicators.adx?.trend??"neutral",volatility=marketState.volatility??"normal",price=marketState.price??0,ema20=indicators.ema?.ema20??price;if("high"===volatility||marketState.atr&&marketState.atrAvg&&marketState.atr>1.5*marketState.atrAvg)return"volatile";if(adx>25){if("bull"===adxTrend||price>ema20)return"trending_up";if("bear"===adxTrend||price<ema20)return"trending_down"}return"ranging"},getRegimeConfidenceMultiplier(regime){const multipliers=void 0;return{trending_up:1.1,trending_down:1.1,ranging:.95,volatile:.9}[regime]||1},getSessionContext(){const h=(new Date).getUTCHours();return h>=0&&h<8?"ASIA":h>=8&&h<16?"EUROPE":"US"},getSessionConfidenceMultiplier(session){const m=void 0;return{ASIA:.95,EUROPE:1.02,US:1.02}[session]||1},getVolatilityScore(marketState){const atr=marketState.atr,atrAvg=marketState.atrAvg;if(!atr||!atrAvg||atrAvg<=0)return"high"===marketState.volatility?.85:"low"===marketState.volatility?.25:.5;const ratio=atr/atrAvg;return Math.max(0,Math.min(1,(ratio-.5)/1.5))},getVolatilityBucket:volScore=>volScore>=.75?"HIGH":volScore<=.35?"LOW":"NORMAL",getVolatilityConfidenceMultiplier:volScore=>volScore>=.8?.92:volScore>=.65?.96:volScore<=.25?1.02:1,detectBreakoutContext(marketState){const s=marketState||{},price=s.price||0,sr=s.supportResistance||{},indicators=s.indicators||{},volScore=this.getVolatilityScore(s),resistance=sr.resistance||sr.r1||sr.R1||null,support=sr.support||sr.s1||sr.S1||null,obv=indicators.obv?.value??s.obv,cvd=s.cvd,candle=s.lastCandle||s.candle||null;let wickRatio=null;if(candle&&null!=candle.high&&null!=candle.low){const range=Math.max(1e-9,candle.high-candle.low),body=void 0;wickRatio=(range-Math.abs((candle.close||0)-(candle.open||0)))/range}const atr=s.atr||null,proximity=level=>{if(!level||!price)return null;const denom=atr&&atr>0?atr:.002*price;return Math.abs(price-level)/denom},nearRes=resistance?proximity(resistance):null,nearSup=support?proximity(support):null;let risk=0,tag="NONE";const volConfWeak=void 0;null!=wickRatio&&wickRatio>.55&&(risk+=.25),volScore>=.75&&(risk+=.25),(null!=obv&&obv<0||null!=cvd&&cvd<0)&&(risk+=.2),null!=nearRes&&nearRes<1.5&&(risk+=.2,tag="AT_RESISTANCE"),null!=nearSup&&nearSup<1.5&&(risk+=.2,tag="AT_SUPPORT"),risk=Math.max(0,Math.min(1,risk));const quality=1-risk;let classification="NEUTRAL";return risk>=.6?classification="FAKE_BREAKOUT_RISK":quality>=.65&&(null!=nearRes||null!=nearSup)&&(classification="CONTINUATION_LIKELY"),{risk:risk,quality:quality,tag:tag,classification:classification}},queryLongTermMemory(marketState){const regime=this.detectMarketRegime(marketState),features=this.extractFeatureVector(marketState),session=this.config.sessionAware?this.getSessionContext():null,volScore=this.config.volatilityAware?this.getVolatilityScore(marketState):null,volBucket=null!=volScore?this.getVolatilityBucket(volScore):null;let bestMatch=null,bestSimilarity=0;for(const pattern of this.memory.patterns){if(pattern.regime!==regime)continue;let contextPenalty=1;session&&pattern.session&&pattern.session!==session&&(contextPenalty*=.9),volBucket&&pattern.volBucket&&pattern.volBucket!==volBucket&&(contextPenalty*=.9);const similarity=void 0,scoredSimilarity=this.calculateSimilarity(features,pattern.features)*contextPenalty;scoredSimilarity>bestSimilarity&&scoredSimilarity>.72&&(bestSimilarity=scoredSimilarity,bestMatch=pattern)}return bestMatch?{found:!0,confidence:bestSimilarity*bestMatch.successRate,direction:bestMatch.direction,occurrences:bestMatch.occurrences,avgReturn:bestMatch.avgReturn,session:bestMatch.session||null,volBucket:bestMatch.volBucket||null,lastOutcome:bestMatch.lastOutcome||null}:{found:!1}},extractFeatureVector(marketState){const vector={},allFeatures=new Set;for(const model of Object.values(this.models))model.features.forEach(f=>allFeatures.add(f));Object.keys(this.features.derived).forEach(f=>allFeatures.add(f));for(const feature of allFeatures){const value=this.getFeatureValue(feature,marketState);null==value||isNaN(value)||(vector[feature]=value)}return this.config.debugMode&&0===Object.keys(vector).length&&console.warn("[AI-PRO] Empty feature vector - check market state"),vector},calculateSimilarity(v1,v2){const keys=Object.keys(v1).filter(k=>void 0!==v2[k]&&null!==v1[k]&&null!==v2[k]&&!isNaN(v1[k])&&!isNaN(v2[k]));if(0===keys.length)return 0;let similarity=0;for(const key of keys)similarity+=1-Math.abs(v1[key]-v2[key]);return similarity/keys.length},storeInLongTermMemory(prediction,outcome){const session=this.config.sessionAware?prediction.session||this.getSessionContext():null,volScore=this.config.volatilityAware?prediction.volScore??this.getVolatilityScore(this.getCurrentMarketState()):null,volBucket=null!=volScore?this.getVolatilityBucket(volScore):null,breakout=prediction.breakout||null,pattern={id:Date.now().toString(36),regime:prediction.regime,direction:prediction.direction,features:prediction.features||{},session:session,volBucket:volBucket,breakoutTag:breakout?.classification||null,successCount:outcome.success?1:0,failCount:outcome.success?0:1,successRate:outcome.success?1:0,occurrences:1,avgReturn:outcome.priceChange||0,lastOutcome:outcome.success?"POS":"NEG",timestamp:Date.now()},similar=this.memory.patterns.find(p=>p.regime===pattern.regime&&this.calculateSimilarity(p.features,pattern.features)>.85);similar?(similar.occurrences++,similar.successCount=(similar.successCount||0)+(outcome.success?1:0),similar.failCount=(similar.failCount||0)+(outcome.success?0:1),similar.successRate=similar.successCount/similar.occurrences,similar.avgReturn=(similar.avgReturn*(similar.occurrences-1)+(outcome.priceChange||0))/similar.occurrences,similar.timestamp=Date.now(),similar.lastOutcome=outcome.success?"POS":"NEG",session&&(similar.session=session),volBucket&&(similar.volBucket=volBucket),this.config.debugMode&&console.log(`[AI-PRO] Pattern updated: ${similar.id} (${similar.occurrences} occ, ${(100*similar.successRate).toFixed(1)}% win)`)):(this.memory.patterns.push(pattern),this.config.debugMode&&console.log(`[AI-PRO] New pattern stored: ${pattern.id} (${pattern.direction})`),this.memory.patterns.length>this.config.maxLongTermPatterns&&(this.memory.patterns.sort((a,b)=>{const scoreA=a.successRate*Math.log(a.occurrences+1),scoreB=void 0;return b.successRate*Math.log(b.occurrences+1)-scoreA}),this.memory.patterns=this.memory.patterns.slice(0,this.config.maxLongTermPatterns)))},recordProPrediction(pred,baseId){const marketState=this.getCurrentMarketState(),ensemble=this.generateEnsemblePrediction(marketState),proPrediction={id:"pro_"+baseId,baseId:baseId,timestamp:Date.now(),price:window.state?.price||0,ensemble:ensemble,features:this.extractFeatureVector(marketState),regime:ensemble.regime,verifications:[],outcome:null};this.predictions.pending.push(proPrediction);for(const horizon of this.config.horizons)setTimeout(()=>this.verifyProPrediction(proPrediction.id,horizon),6e4*horizon);return ensemble.confidence>.75&&console.log(`[AI-PRO] High confidence ${ensemble.direction}: ${(100*ensemble.confidence).toFixed(1)}%`),proPrediction.id},verifyProPrediction(id,horizon){const pred=this.predictions.pending.find(p=>p.id===id);if(!pred||!window.state?.price||!pred.price)return;const priceChange=(window.state.price-pred.price)/pred.price*100,direction=pred.ensemble.direction,threshold="NEUTRAL"===direction?.05:.1,success="BULL"===direction&&priceChange>threshold||"BEAR"===direction&&priceChange<-threshold||"NEUTRAL"===direction&&Math.abs(priceChange)<.15;pred.verifications.push({horizon:horizon,priceChange:priceChange,success:success,timestamp:Date.now()}),this._lastVerification={horizon:horizon,priceChange:priceChange.toFixed(3),success:success,timestamp:Date.now()},this.predictions.byHorizon[horizon]&&(this.predictions.byHorizon[horizon].total++,success&&this.predictions.byHorizon[horizon].correct++,this.predictions.byHorizon[horizon].accuracy=this.predictions.byHorizon[horizon].correct/this.predictions.byHorizon[horizon].total);const autoMax=this.config.autoMaxHorizon||15,fullMax=Math.max(...this.config.horizons);(pred.isAuto&&horizon===autoMax||!pred.isAuto&&horizon===fullMax)&&this.completeProPrediction(pred)},rescheduleVerifications(pred){if(!pred||!pred.id||!pred.timestamp)return;const now=Date.now(),elapsed=now-pred.timestamp,verified=pred.verifications?pred.verifications.map(v=>v.horizon):[],horizonsToVerify=pred.isAuto?this.config.horizons.filter(h=>h<=(this.config.autoMaxHorizon||15)):this.config.horizons;for(const horizon of horizonsToVerify){if(verified.includes(horizon))continue;const targetTime=void 0,delay=pred.timestamp+6e4*horizon-now;delay>0?setTimeout(()=>this.verifyProPrediction(pred.id,horizon),delay):delay>-3e5&&setTimeout(()=>this.verifyProPrediction(pred.id,horizon),1e3)}},completeProPrediction(pred){const verifs=pred.verifications||[],baseMinValidations=Math.min(this.config.minValidationsToLearn,this.config.horizons.length),autoMinValidations=Math.min(this.config.minValidationsToLearnAuto||4,this.config.horizons.length),minValidations=pred&&pred.isAuto?autoMinValidations:baseMinValidations,maxH=Math.max(...this.config.horizons);let wSuccess=0,wTotal=0,sumChange=0;for(const v of verifs){const w=.5+v.horizon/maxH;wTotal+=w,v.success&&(wSuccess+=w),sumChange+=v.priceChange}const successRateW=wTotal>0?wSuccess/wTotal:0,success=successRateW>=.55,avgPriceChange=verifs.length?sumChange/verifs.length:0,successCount=verifs.filter(v=>v.success).length;pred.outcome={success:success,avgPriceChange:avgPriceChange,successRate:verifs.length?successCount/verifs.length:0,successRateWeighted:successRateW,completedAt:Date.now()},this.updateModelWeights(pred,success);const c=pred.ensemble?.confidence||0,br=pred.ensemble?.breakout,mustLearn=void 0;(c>=.7||Math.abs(avgPriceChange)>=.35||br&&"NEUTRAL"!==br.classification)&&verifs.length>=minValidations&&(pred.session=pred.ensemble?.session,pred.volScore=pred.ensemble?.volScore,pred.breakout=pred.ensemble?.breakout,this.storeInLongTermMemory(pred,{success:success,priceChange:avgPriceChange})),this.predictions.completed.push(pred),this.predictions.pending=this.predictions.pending.filter(p=>p.id!==pred.id),this.updatePerformance(pred),this.predictions.completed.length>500&&(this.predictions.completed=this.predictions.completed.slice(-500)),this.performance.overall.totalPredictions%10==0&&this.saveState()},updateModelWeights(pred,overallSuccess){const lr=this.config.learningRate;for(const[modelName,modelPred]of Object.entries(pred.ensemble.modelPredictions)){const model=this.models[modelName];if(!model)continue;const modelCorrect=overallSuccess&&modelPred.direction===pred.ensemble.direction||!overallSuccess&&modelPred.direction!==pred.ensemble.direction;model.predictions++,modelCorrect&&model.correct++;const newAccuracy=model.correct/model.predictions;model.accuracy=.9*model.accuracy+.1*newAccuracy,model.predictions>=20&&(model.accuracy>.55?model.weight=Math.min(2,model.weight+lr):model.accuracy<.45&&(model.weight=Math.max(.3,model.weight-lr)))}},updateProModels(basePrediction){if(basePrediction.outcome?.success)for(const ind of Object.keys(basePrediction.indicators||{}))for(const model of Object.values(this.models))model.features.includes(ind)&&(model.accuracy=.98*model.accuracy+.02)},updatePerformance(pred){const perf=this.performance.overall;perf.totalPredictions++,pred.outcome.success&&perf.correctPredictions++,perf.accuracy=perf.correctPredictions/perf.totalPredictions;const today=(new Date).toISOString().split("T")[0];this.performance.daily[today]||(this.performance.daily[today]={total:0,correct:0,returns:[]});const daily=this.performance.daily[today];daily.total++,pred.outcome.success&&daily.correct++,daily.returns.push(pred.outcome.avgPriceChange);const keys=Object.keys(this.performance.daily).sort();for(;keys.length>30;)delete this.performance.daily[keys.shift()]},startOptimizationLoop(){setInterval(()=>this.runOptimization(),this.config.optimizationInterval),setTimeout(()=>this.runOptimization(),3e5)},runOptimization(){console.log("[AI-PRO] Running auto-optimization...");const recentPredictions=this.predictions.completed.slice(-50);if(recentPredictions.length>=20){const recentAccuracy=recentPredictions.filter(p=>p.outcome.success).length/recentPredictions.length;recentAccuracy<.45?this.config.learningRate=Math.min(.1,1.2*this.config.learningRate):recentAccuracy>.6&&(this.config.learningRate=Math.max(.01,.9*this.config.learningRate))}this.memory.patterns=this.memory.patterns.filter(p=>p.occurrences>=3||Date.now()-p.timestamp<864e5);const bestHorizon=Object.entries(this.predictions.byHorizon).filter(([_,stats])=>stats.total>=10).sort(([_,a],[__,b])=>b.accuracy-a.accuracy)[0];bestHorizon&&console.log(`[AI-PRO] Best horizon: ${bestHorizon[0]}min (${(100*bestHorizon[1].accuracy).toFixed(1)}%)`),this.saveState(),console.log("[AI-PRO] Optimization complete. Accuracy:",(100*this.performance.overall.accuracy).toFixed(1)+"%"),console.log("[AI-PRO] Memory patterns:",this.memory.patterns.length),console.log("[AI-PRO] Pending predictions:",this.predictions.pending.length)},startAutoPrediction(){const AUTO_PREDICT_INTERVAL=6e4;setInterval(()=>{this.generateAutoPrediction()},6e4),setTimeout(()=>{console.log("[AI-PRO] ðŸš€ Generating FIRST auto-prediction..."),this.generateAutoPrediction()},5e3),setTimeout(()=>{console.log("[AI-PRO] ðŸš€ Generating SECOND auto-prediction..."),this.generateAutoPrediction()},15e3),console.log("[AI-PRO] Auto-prediction started (every 1 min, first in 5s)")},generateAutoPrediction(){if(console.log("[AI-PRO] === Auto-prediction attempt ==="),!this.isReady)return void console.log("[AI-PRO] âŒ Skipping: not ready");const price=window.state?.price;if(!price)return void console.log("[AI-PRO] âŒ Skipping: no price data (window.state.price =",price,")");console.log("[AI-PRO] âœ“ Price available:",price);const maxPending=this.config.maxPending||25;this.predictions.pending.length>=maxPending&&this._okrtEnforcePendingCap(Math.max(0,maxPending-1),18e6);const marketState=this.getCurrentMarketState();console.log("[AI-PRO] Market state:",{price:marketState.price,hasIndicators:!!marketState.indicators&&Object.keys(marketState.indicators||{}).length>0,indicatorKeys:Object.keys(marketState.indicators||{}).slice(0,5)});const ensemble=this.generateEnsemblePrediction(marketState);if(console.log("[AI-PRO] Ensemble result:",{direction:ensemble.direction,confidence:(100*ensemble.confidence).toFixed(1)+"%",threshold:100*this.config.minConfidence+"%",passes:ensemble.confidence>=this.config.minConfidence}),ensemble.confidence<.15)return void console.log("[AI-PRO] âŒ Skipping: extremely low confidence");const predId="auto_"+Date.now().toString(36)+Math.random().toString(36).substr(2,5),proPrediction={id:predId,baseId:null,timestamp:Date.now(),price:window.state.price,ensemble:ensemble,features:this.extractFeatureVector(marketState),regime:ensemble.regime,verifications:[],outcome:null,isAuto:!0};this.predictions.pending.push(proPrediction),this._sessionPredictions=(this._sessionPredictions||0)+1,this._lastPredictionTime=Date.now();const horizonsToVerify=this.config.horizons.filter(h=>h<=(this.config.autoMaxHorizon||15));for(const horizon of horizonsToVerify)setTimeout(()=>this.verifyProPrediction(predId,horizon),6e4*horizon);console.log(`[AI-PRO] ðŸŽ¯ Auto-prediction #${this._sessionPredictions}: ${ensemble.direction} @ ${(100*ensemble.confidence).toFixed(1)}% | Price: ${window.state.price.toFixed(4)} | Pending: ${this.predictions.pending.length}`)},_getUidSafe(){try{return window.AILearning?.auth?.currentUser?.uid||("string"==typeof window.AILearning?.user?window.AILearning.user:window.AILearning?.user?.uid)||null}catch(e){return null}},_userDocRef(docId){try{const uid=this._getUidSafe();if(!uid||!this.db||!window.AILearning?.firestore?.doc)return null;const{doc:doc}=window.AILearning.firestore;return doc(this.db,"aiUsers",uid,"engine",docId)}catch(e){return null}},_stableStringify(value){const seen=new WeakSet,norm=v=>{if(null==v)return v;if("object"!=typeof v)return v;if(seen.has(v))return null;if(seen.add(v),Array.isArray(v))return v.map(norm);const out={};for(const k of Object.keys(v).sort())"updatedAt"!==k&&"_updatedAt"!==k&&"lastSavedAt"!==k&&(out[k]=norm(v[k]));return out};return JSON.stringify(norm(value))},_sig(obj){try{return this._stableStringify(obj)}catch(e){return""}},_sanitizeState(){try{const allowedModels=["momentum","trend","volume","structure","patterns","mtf"];for(const name of allowedModels){const m=this.models?.[name];if(!m)continue;const w=Number(m.weight);m.weight=Number.isFinite(w)&&w>=0?Math.min(100,w):1;const acc=Number(m.accuracy);m.accuracy=Number.isFinite(acc)&&acc>=0&&acc<=1?acc:.5;const pred=Number(m.predictions);m.predictions=Number.isFinite(pred)&&pred>=0?Math.floor(pred):0;const cor=Number(m.correct);m.correct=Number.isFinite(cor)&&cor>=0?Math.floor(cor):0}const allowedHorizons=[2,5,10,15,30,60,120,240];this.predictions=this.predictions||{},this.predictions.byHorizon=this.predictions.byHorizon||{};for(const h of allowedHorizons){const o=this.predictions.byHorizon[h]||this.predictions.byHorizon[String(h)]||{},total=Number(o.total),correct=Number(o.correct),accuracy=Number(o.accuracy),safeTotal=Number.isFinite(total)&&total>=0?total:0,safeCorrect=Number.isFinite(correct)&&correct>=0?correct:0,safeAcc=Number.isFinite(accuracy)&&accuracy>=0&&accuracy<=1?accuracy:safeTotal>0?safeCorrect/safeTotal:.5;this.predictions.byHorizon[h]={total:safeTotal,correct:safeCorrect,accuracy:safeAcc}}Array.isArray(this.predictions.pending)||(this.predictions.pending=[]);for(const p of this.predictions.pending)p&&!Number.isFinite(Number(p.timestamp))&&(p.timestamp=Date.now());Array.isArray(this.memory?.patterns)||(this.memory.patterns=[]),("object"!=typeof this.memory?.correlations||null===this.memory.correlations||Array.isArray(this.memory.correlations))&&(this.memory.correlations={})}catch(e){}},_okrtEnforcePendingCap(cap=25,maxAgeMs=18e6){try{if(!this.predictions||!Array.isArray(this.predictions.pending))return;const now=Date.now();let pending=this.predictions.pending.filter(p=>p&&"object"==typeof p&&p.timestamp&&now-p.timestamp<maxAgeMs);if(pending.sort((a,b)=>(a.timestamp||0)-(b.timestamp||0)),pending.length>cap){const dropped=pending.length-cap;pending=pending.slice(-cap),console.log(`[AI-PRO] Pending cap: dropped ${dropped} oldest (kept ${pending.length}, cap ${cap})`)}this.predictions.pending=pending}catch(e){}},async _maybeSetDoc(docId,data){const now=Date.now();if(this._fsDisabledUntil&&now<this._fsDisabledUntil)return!1;const ref=this._userDocRef(docId);if(!ref||!window.AILearning?.firestore?.setDoc)return!1;this._lastDocSigs=this._lastDocSigs||{};const sig=this._sig(data);if(sig&&this._lastDocSigs[docId]===sig)return!1;try{const{setDoc:setDoc}=window.AILearning.firestore,strictNoMerge=void 0;return new Set(["pro_models","pro_memory","pro_horizons","pro_pending"]).has(docId)?await setDoc(ref,data):await setDoc(ref,data,{merge:!0}),sig&&(this._lastDocSigs[docId]=sig),!0}catch(e){const code=void 0;throw("permission-denied"===(e?.code||"")||String(e?.message||"").includes("Missing or insufficient permissions"))&&(this._fsDisabledUntil=now+12e4),e}},async loadState(){if(this.db)try{const{getDoc:getDoc}=window.AILearning.firestore,modelsRef=this._userDocRef("pro_models");if(modelsRef){const modelsDoc=await getDoc(modelsRef);if(modelsDoc.exists()){const savedModels=modelsDoc.data(),allowed=["momentum","trend","volume","structure","patterns","mtf"];for(const name of allowed){const data=savedModels?.[name];data&&this.models?.[name]&&Object.assign(this.models[name],data)}}}const memoryRef=this._userDocRef("pro_memory");if(memoryRef){const memDoc=await getDoc(memoryRef);if(memDoc.exists()){const savedMemory=memDoc.data()||{};savedMemory.patterns&&Array.isArray(savedMemory.patterns)&&(this.memory.patterns=savedMemory.patterns),savedMemory.correlations&&"object"==typeof savedMemory.correlations&&(this.memory.correlations=savedMemory.correlations)}}const perfRef=this._userDocRef("pro_performance");if(perfRef){const perfDoc=await getDoc(perfRef);if(perfDoc.exists()){const savedPerf=perfDoc.data();savedPerf&&"object"==typeof savedPerf&&Object.assign(this.performance,savedPerf)}}const horizonsRef=this._userDocRef("pro_horizons");if(horizonsRef){const hDoc=await getDoc(horizonsRef);if(hDoc.exists()){const savedH=hDoc.data()||{},allowed=["2","5","10","15","30","60","120","240"];for(const h of allowed){const data=savedH?.[h];data&&this.predictions.byHorizon?.[h]&&Object.assign(this.predictions.byHorizon[h],data),data&&this.predictions.byHorizon?.[Number(h)]&&Object.assign(this.predictions.byHorizon[Number(h)],data)}}}const pendingRef=this._userDocRef("pro_pending");if(pendingRef){const pendingDoc=await getDoc(pendingRef);if(pendingDoc.exists()){const savedPending=pendingDoc.data()||{};if(savedPending.pending&&Array.isArray(savedPending.pending)){const now=Date.now(),MAX_PENDING=this.config.maxPending||25,recent=savedPending.pending.filter(p=>p&&"object"==typeof p&&p.timestamp&&now-p.timestamp<18e6).sort((a,b)=>(a.timestamp||0)-(b.timestamp||0)).slice(-MAX_PENDING);let restored=0;this.predictions.pending=[];for(const pred of recent)pred.id||(pred.id=`restored_${pred.timestamp||now}_${Math.random().toString(36).slice(2,9)}`),"boolean"!=typeof pred.isAuto&&(pred.isAuto=!0),this.predictions.pending.push(pred),this.rescheduleVerifications(pred),restored++;savedPending.pending.length>MAX_PENDING&&console.log(`[AI-PRO] Pending trimmed on load: ${savedPending.pending.length} -> ${restored}`)}}}return this._sanitizeState(),this._okrtEnforcePendingCap(25,18e6),void console.log("[AI-PRO] State loaded from Firestore (scoped)")}catch(e){console.warn("[AI-PRO] Firestore load failed (scoped), using localStorage:",e)}try{const stateStr=localStorage.getItem("ai_pro_state");if(stateStr){const state=JSON.parse(stateStr);if(state.models)for(const[name,data]of Object.entries(state.models))this.models[name]&&Object.assign(this.models[name],data);if(state.memory&&Object.assign(this.memory,state.memory),state.performance&&Object.assign(this.performance,state.performance),state.horizons)for(const[h,data]of Object.entries(state.horizons))this.predictions.byHorizon[h]&&Object.assign(this.predictions.byHorizon[h],data),this.predictions.byHorizon[Number(h)]&&Object.assign(this.predictions.byHorizon[Number(h)],data);if(state.pending&&Array.isArray(state.pending)){this.predictions.pending=state.pending;for(const pred of this.predictions.pending)this.rescheduleVerifications(pred)}this._sanitizeState(),this._okrtEnforcePendingCap(25,18e6),console.log("[AI-PRO] State loaded from localStorage")}}catch(e){}},async saveState(){try{localStorage.setItem("ai_pro_state",JSON.stringify({models:this.models,memory:{patterns:(this.memory?.patterns||[]).slice(-100),correlations:this.memory?.correlations||{}},performance:this.performance,horizons:this.predictions.byHorizon,pending:(this.predictions?.pending||[]).slice(-25)}))}catch(e){}if(!this.db)return;const uid=void 0;if(!this._getUidSafe())return;const now=Date.now();if(!(this._fsDisabledUntil&&now<this._fsDisabledUntil))try{this._sanitizeState(),this._okrtEnforcePendingCap(25,18e6);const allowedModels=["momentum","trend","volume","structure","patterns","mtf"],modelsData={};for(const name of allowedModels){const m=this.models&&this.models[name]?this.models[name]:{},w=Number(m.weight),a=Number(m.accuracy),p=Number(m.predictions),c=Number(m.correct);modelsData[name]={weight:Number.isFinite(w)?Math.max(0,Math.min(100,w)):1,accuracy:Number.isFinite(a)?Math.max(0,Math.min(1,a)):.5,predictions:Number.isFinite(p)?Math.max(0,Math.floor(p)):0,correct:Number.isFinite(c)?Math.max(0,Math.floor(c)):0}}const memoryData={patterns:(this.memory?.patterns||[]).slice(-500),correlations:this.memory?.correlations||{},updatedAt:(new Date).toISOString()},performanceData=this.performance,allowedHorizons=["2","5","10","15","30","60","120","240"],horizonsData={};for(const h of allowedHorizons){const v=this.predictions?.byHorizon?.[h]??this.predictions?.byHorizon?.[Number(h)]??{},total=Number(v.total),correct=Number(v.correct),accuracy=Number(v.accuracy),safeTotal=Number.isFinite(total)&&total>=0?total:0,safeCorrect=Number.isFinite(correct)&&correct>=0?correct:0,safeAcc=Number.isFinite(accuracy)&&accuracy>=0&&accuracy<=1?accuracy:safeTotal>0?safeCorrect/safeTotal:.5;horizonsData[h]={total:safeTotal,correct:safeCorrect,accuracy:safeAcc}}const pendingData=void 0,writes=[["pro_models",modelsData],["pro_memory",memoryData],["pro_performance",performanceData],["pro_horizons",horizonsData],["pro_pending",{pending:(this.predictions?.pending||[]).slice(-25),updatedAt:Date.now()}]];for(const[docId,data]of writes)try{await this._maybeSetDoc(docId,data)}catch(e){console.warn(`[AI-PRO] Firestore save failed (${docId}):`,e)}}catch(e){console.warn("[AI-PRO] Firestore save failed (scoped):",e)}},deriveIndicatorsFromState(s,price,prevPrice){try{const candles=this._getCandlesFromState(s),lastCandle=candles.length?candles[candles.length-1]:s.lastCandle||s.candle||s.lastOHLC||null;if(!candles.length)return{indicators:s.indicators||{},volume:s.volume,atr:s.atr,atrAvg:s.atrAvg,volatility:s.volatility,lastCandle:lastCandle};const closes=candles.map(c=>this._getCandleClose(c)).filter(v=>Number.isFinite(v)),highs=candles.map(c=>this._getCandleHigh(c)).filter(v=>Number.isFinite(v)),lows=candles.map(c=>this._getCandleLow(c)).filter(v=>Number.isFinite(v)),vols=candles.map(c=>this._getCandleVol(c)).filter(v=>Number.isFinite(v));if(closes.length<20)return{indicators:s.indicators||{},volume:s.volume,atr:s.atr,atrAvg:s.atrAvg,volatility:s.volatility,lastCandle:lastCandle};const rsi=this._calcRSI(closes,14),stochRsi=this._calcStochRSI(closes,14,14),emaFast=this._calcEMA(closes,9),emaSlow=this._calcEMA(closes,21),ema20=this._calcEMA(closes,20),macd=this._calcMACD(closes,12,26,9),atr=this._calcATR(candles,14),atrAvg=this._calcATR(candles,50),priceRef=Number.isFinite(price)?price:closes[closes.length-1],volRatio=Number.isFinite(atr)&&priceRef>0?atr/priceRef:0,volatility=volRatio>.012?"high":volRatio>.006?"normal":"low",lookback=Math.min(10,closes.length-1),base=closes[closes.length-1-lookback]||closes[0],momentum=base&&0!==base?(closes[closes.length-1]-base)/base*100:0,obvObj=this._calcOBV(candles),emaTrend=emaFast>1.0005*emaSlow?"bull":emaFast<.9995*emaSlow?"bear":"neutral",trendStrength=priceRef>0?Math.abs(emaFast-emaSlow)/priceRef:0,adx=Math.max(8,Math.min(55,18+800*trendStrength)),supertrendSignal="neutral"===emaTrend?priceRef>ema20?"bull":"bear":emaTrend;let divergence=null;if(closes.length>=25){const p0=closes[closes.length-1],p1=closes[closes.length-11],r0=this._calcRSI(closes.slice(0,closes.length),14),r1=this._calcRSI(closes.slice(0,closes.length-10),14);Number.isFinite(p0)&&Number.isFinite(p1)&&Number.isFinite(r0)&&Number.isFinite(r1)&&(p0<p1&&r0>r1?divergence={type:"bullish"}:p0>p1&&r0<r1&&(divergence={type:"bearish"}))}const lastVol=vols.length?vols[vols.length-1]:this._getCandleVol(lastCandle)||0,avgVolWindow=vols.slice(-20),avgVol=avgVolWindow.length?avgVolWindow.reduce((a,b)=>a+b,0)/avgVolWindow.length:lastVol,volObj={ratio:avgVol>0?lastVol/avgVol:1,trend:lastVol>1.1*avgVol?"increasing":lastVol<.9*avgVol?"decreasing":"stable"},indicators=Object.assign({},s.indicators||{});return null==indicators.rsi&&(indicators.rsi={value:rsi}),"number"==typeof indicators.rsi&&(indicators.rsi={value:indicators.rsi}),null==indicators.stochRsi&&(indicators.stochRsi={value:stochRsi}),"number"==typeof indicators.stochRsi&&(indicators.stochRsi={value:indicators.stochRsi}),null==indicators.macd&&(indicators.macd={histogram:macd.histogram,signal:macd.histogram>=0?"bull":"bear"}),"number"==typeof indicators.macd&&(indicators.macd={histogram:indicators.macd,signal:indicators.macd>=0?"bull":"bear"}),null==indicators.ema&&(indicators.ema={emaFast:emaFast,emaSlow:emaSlow,ema20:ema20,signal:emaTrend}),null==indicators.adx&&(indicators.adx={value:adx,trend:emaTrend}),null==indicators.supertrend&&(indicators.supertrend={signal:supertrendSignal}),null==indicators.obv&&(indicators.obv=obvObj),null==indicators.momentum&&(indicators.momentum={value:momentum,signal:momentum>=0?"bull":"bear"}),divergence&&null==indicators.divergence&&(indicators.divergence=divergence),"number"!=typeof s.prevPrice&&Number.isFinite(prevPrice),{indicators:indicators,volume:s.volume||volObj,atr:Number.isFinite(s.atr)?s.atr:atr,atrAvg:Number.isFinite(s.atrAvg)?s.atrAvg:atrAvg,volatility:s.volatility||volatility,lastCandle:lastCandle}}catch(e){return{indicators:s.indicators||{},volume:s.volume,atr:s.atr,atrAvg:s.atrAvg,volatility:s.volatility,lastCandle:s.lastCandle||s.candle||s.lastOHLC||null}}},_getCandlesFromState:s=>Array.isArray(s.candles)&&s.candles.length?s.candles:Array.isArray(s.ohlc)&&s.ohlc.length?s.ohlc:Array.isArray(s.ohlcHistory)&&s.ohlcHistory.length?s.ohlcHistory:[],_getCandleClose(c){return c?this._num(c.close??c.c??c.C??c[4],NaN):NaN},_getCandleHigh(c){return c?this._num(c.high??c.h??c.H??c[2],NaN):NaN},_getCandleLow(c){return c?this._num(c.low??c.l??c.L??c[3],NaN):NaN},_getCandleVol(c){return c?this._num(c.volume??c.v??c.V??c[5],NaN):NaN},_num(v,fallback=0){const n="string"==typeof v?parseFloat(v):v;return Number.isFinite(n)?n:fallback},_calcEMA(values,period){if(!Array.isArray(values)||0===values.length)return NaN;const p=void 0,k=2/(Math.max(2,0|period)+1);let ema=values[0];for(let i=1;i<values.length;i++){const v=values[i];Number.isFinite(v)&&(ema=v*k+ema*(1-k))}return ema},_calcRSI(closes,period=14){if(!Array.isArray(closes)||closes.length<period+2)return 50;const p=Math.max(2,0|period);let gain=0,loss=0;for(let i=closes.length-p;i<closes.length;i++){const prev=closes[i-1],cur=closes[i];if(!Number.isFinite(prev)||!Number.isFinite(cur))continue;const ch=cur-prev;ch>=0?gain+=ch:loss-=ch}const avgGain=void 0,avgLoss=loss/p;if(0===avgLoss)return 100;const rs=void 0,rsi=100-100/(1+gain/p/avgLoss);return Math.max(0,Math.min(100,rsi))},_calcMACD(closes,fast=12,slow=26,signal=9){if(!Array.isArray(closes)||closes.length<slow+signal)return{histogram:0};const emaFast=void 0,emaSlow=void 0,macdLine=this._calcEMA(closes,fast)-this._calcEMA(closes,slow),sampleN=Math.min(60,closes.length),macdSeries=[];for(let i=closes.length-sampleN;i<closes.length;i++){const slice=closes.slice(0,i+1);macdSeries.push(this._calcEMA(slice,fast)-this._calcEMA(slice,slow))}const signalLine=void 0,histogram=void 0;return{histogram:macdLine-this._calcEMA(macdSeries,signal)}},_calcATR(candles,period=14){if(!Array.isArray(candles)||candles.length<3)return NaN;const p=Math.max(2,0|period),start=void 0;let sumTR=0,count=0;for(let i=Math.max(1,candles.length-p);i<candles.length;i++){const c=candles[i],prev=candles[i-1],high=this._getCandleHigh(c),low=this._getCandleLow(c),prevClose=this._getCandleClose(prev);if(![high,low,prevClose].every(Number.isFinite))continue;const tr=void 0;sumTR+=Math.max(high-low,Math.abs(high-prevClose),Math.abs(low-prevClose)),count++}return count?sumTR/count:NaN},_calcStochRSI(closes,rsiPeriod=14,stochPeriod=14){if(!Array.isArray(closes)||closes.length<rsiPeriod+stochPeriod+2)return 50;const rsiSeries=[];for(let i=rsiPeriod+1;i<closes.length;i++)rsiSeries.push(this._calcRSI(closes.slice(0,i+1),rsiPeriod));const window=rsiSeries.slice(-stochPeriod),rsiLast=window[window.length-1],minRsi=Math.min(...window),maxRsi=Math.max(...window);if(maxRsi===minRsi)return 50;const stoch=(rsiLast-minRsi)/(maxRsi-minRsi)*100;return Math.max(0,Math.min(100,stoch))},_calcOBV(candles){if(!Array.isArray(candles)||candles.length<3)return{value:0,signal:"neutral",slope:0};let obv=0;for(let i=1;i<candles.length;i++){const prevClose=this._getCandleClose(candles[i-1]),close=this._getCandleClose(candles[i]),vol=this._getCandleVol(candles[i]);[prevClose,close,vol].every(Number.isFinite)&&(close>prevClose?obv+=vol:close<prevClose&&(obv-=vol))}const n=Math.min(10,candles.length-2);let obv2=0;for(let i=candles.length-n;i<candles.length;i++){const prevClose=this._getCandleClose(candles[i-1]),close=this._getCandleClose(candles[i]),vol=this._getCandleVol(candles[i]);[prevClose,close,vol].every(Number.isFinite)&&(close>prevClose?obv2+=vol:close<prevClose&&(obv2-=vol))}const slope=obv2,signal=void 0;return{value:obv,signal:obv2>0?"bull":obv2<0?"bear":"neutral",slope:obv2}},getCurrentMarketState(){const s=window.state||{},price="number"==typeof s.price?s.price:"number"==typeof s.currentPrice?s.currentPrice:"number"==typeof s.lastPrice?s.lastPrice:0,prevPrice="number"==typeof s.prevPrice?s.prevPrice:"number"==typeof this._lastPriceSeen?this._lastPriceSeen:price;Number.isFinite(price)&&(this._lastPriceSeen=price);const now=Date.now();if(!this._derivedCache||now-this._derivedCache.ts>750){const derived=this.deriveIndicatorsFromState(s,price,prevPrice);this._derivedCache=Object.assign({ts:now},derived)}const d=this._derivedCache||{};return{price:price,prevPrice:prevPrice,indicators:d.indicators||s.indicators||{},indicatorKeys:Object.keys(d.indicators||s.indicators||{}),volume:d.volume||s.volume,cvd:s.cvd,whaleFlow:s.whaleFlow,supportResistance:s.supportResistance,orderBlocks:s.orderBlocks,fvg:s.fvg,liquidity:s.liquidity,patterns:s.patterns,chartPattern:s.chartPattern,divergence:s.divergence||d.indicators&&d.indicators.divergence||null,mtf:s.mtf,volatility:d.volatility||s.volatility,atr:d.atr??s.atr,atrAvg:d.atrAvg??s.atrAvg,lastCandle:d.lastCandle||s.lastCandle||s.candle||s.lastOHLC||null,orderbook:s.orderbook||s.depth||null}},getPrediction(){const marketState=this.getCurrentMarketState();return this.generateEnsemblePrediction(marketState)},getModelStats(){const stats={};for(const[name,model]of Object.entries(this.models))stats[name]={weight:model.weight.toFixed(2),accuracy:(100*model.accuracy).toFixed(1)+"%",predictions:model.predictions};return stats},getStats(){const baseOverall=this.performance?.overall||{accuracy:0,totalPredictions:0,correctPredictions:0},daily=this.performance?.daily||{},byH=this.predictions?.byHorizon||{},horizons={};for(const[h,hs]of Object.entries(byH))horizons[h]={accuracy:"number"==typeof hs?.accuracy?hs.accuracy:0,total:"number"==typeof hs?.total?hs.total:0,correct:"number"==typeof hs?.correct?hs.correct:0};const shortHs=Array.isArray(this.config.shortHorizons)?this.config.shortHorizons:[2,5,10,15];let shortTotal=0,shortCorrect=0;for(const h of shortHs){const hs=byH?.[h];hs&&(shortTotal+="number"==typeof hs.total?hs.total:0,shortCorrect+="number"==typeof hs.correct?hs.correct:0)}const overall={...baseOverall};0===(overall.totalPredictions||0)&&shortTotal>0&&(overall.totalPredictions=shortTotal,overall.correctPredictions=shortCorrect,overall.accuracy=shortCorrect/shortTotal);const completedLong=this.predictions?.completed?.length||0,completedPerf=this.performance?.overall?.totalPredictions||0,completedShort=shortTotal,completed=Math.max(completedLong,completedPerf,completedShort),startedAt=this._sessionStart||Date.now(),uptimeMin=Math.max(0,Math.floor((Date.now()-startedAt)/6e4)),session=void 0;return{overall:overall,daily:daily,session:{predictions:this._sessionPredictions||0,uptime:uptimeMin,lastVerification:this._lastVerification||null},horizons:horizons,memory:{patterns:this.memory?.patterns?.length||0,pending:this.predictions?.pending?.length||0,completed:completed},models:"function"==typeof this.getModelStats?this.getModelStats():{}}},forceSave(){return this.saveState()},debugFeatures(){const state=this.getCurrentMarketState(),vector=this.extractFeatureVector(state);return console.log("[AI-PRO] Feature vector:",vector),console.log("[AI-PRO] Features extracted:",Object.keys(vector).length),vector}};"loading"===document.readyState?document.addEventListener("DOMContentLoaded",()=>{setTimeout(()=>AIEnginePro.init(),2e3)}):setTimeout(()=>AIEnginePro.init(),2e3),window.AIEnginePro=AIEnginePro,console.log("[AI-PRO] AI Engine PRO v1.6.9 loaded (always-active mode)");