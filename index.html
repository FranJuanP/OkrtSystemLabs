<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/><!-- ============================================ --><!-- SECURITY HEADERS - Pentesting Ready --><!-- ============================================ --><!-- Content Security Policy - Strict Whitelist --><meta content="default-src 'self'; script-src 'self' 'nonce-okrt-oraculum-nonce-2026' https://unpkg.com https://cdnjs.cloudflare.com https://www.gstatic.com https://www.google.com https://www.recaptcha.net; script-src-attr 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: blob: https:; connect-src 'self' https://www.gstatic.com https://www.google.com https://www.recaptcha.net https://*.googleapis.com https://*.firebaseio.com https://firestore.googleapis.com https://api.binance.com https://fapi.binance.com wss://stream.binance.com:9443 wss://fstream.binance.com wss://stream.bybit.com wss://ws-feed.exchange.coinbase.com wss://ws.kraken.com wss://ws.bitstamp.net wss://stream.crypto.com https://api.alternative.me; media-src 'self' blob: data:; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; frame-src https://www.google.com https://www.recaptcha.net; worker-src 'self' blob:; manifest-src 'self' data:; block-all-mixed-content; upgrade-insecure-requests;" http-equiv="Content-Security-Policy"/><!-- Prevent MIME type sniffing --><meta content="nosniff" http-equiv="X-Content-Type-Options"/><!-- Referrer Policy --><meta content="strict-origin-when-cross-origin" name="referrer"/><!-- Prevent clickjacking --><!-- XSS Protection (legacy browsers) --><meta content="1; mode=block" http-equiv="X-XSS-Protection"/><!-- Permissions Policy - Disable unnecessary features --><meta content="accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()" http-equiv="Permissions-Policy"/><!-- PWA Meta Tags --><meta content="ORACULUM" name="application-name"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="ORACULUM" name="apple-mobile-web-app-title"/><meta content="yes" name="mobile-web-app-capable"/><meta content="#02060c" name="theme-color"/><meta content="#02060c" name="msapplication-TileColor"/><meta content="#00d4ff" name="msapplication-navbutton-color"/><!-- SEO & Social --><meta content="ORACULUM OkrtSystem Labs - Advanced XRP Trading Dashboard with Probability-Based Predictions, Market Regime Detection, S/R Levels, Fibonacci, and Signal Quality Analysis" name="description"/><meta content="XRP, trading, dashboard, crypto, AI, analysis, ORACULUM, fibonacci, support, resistance" name="keywords"/><meta content="OkrtSystem Labs" name="author"/><title>ORACULUM OkrtSystem Labs</title><!-- PWA Icons --><link href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4ff'/%3E%3Cstop offset='100%25' stop-color='%23a855f7'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='512' height='512' rx='100' fill='%2302060c'/%3E%3Crect x='128' y='128' width='256' height='256' rx='40' fill='url(%23g)' transform='rotate(45 256 256)'/%3E%3Ctext x='256' y='290' text-anchor='middle' font-family='Arial Black' font-size='180' font-weight='900' fill='%2302060c'%3EX%3C/text%3E%3C/svg%3E" rel="icon" type="image/svg+xml"/><link href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4ff'/%3E%3Cstop offset='100%25' stop-color='%23a855f7'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='512' height='512' rx='100' fill='%2302060c'/%3E%3Crect x='128' y='128' width='256' height='256' rx='40' fill='url(%23g)' transform='rotate(45 256 256)'/%3E%3Ctext x='256' y='290' text-anchor='middle' font-family='Arial Black' font-size='180' font-weight='900' fill='%2302060c'%3EX%3C/text%3E%3C/svg%3E" rel="apple-touch-icon"/><!-- Splash Screens iOS --><meta content="yes" name="apple-mobile-web-app-capable"/><link href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1242 2688'%3E%3Crect fill='%2302060c' width='1242' height='2688'/%3E%3Ctext x='621' y='1344' text-anchor='middle' font-family='Arial' font-size='120' fill='%2300d4ff'%3EXRP ORACULUM%3C/text%3E%3C/svg%3E" rel="apple-touch-startup-image"/><!-- Web App Manifest (inline) --><link href="data:application/json,%7B%22name%22%3A%22XRP%20ORACULUM%20%7C%20OkrtSystem%20Labs%22%2C%22short_name%22%3A%22XRP%20ORACULUM%22%2C%22description%22%3A%22Advanced%20XRP%20Trading%20Dashboard%20by%20OkrtSystem%20Labs%22%2C%22start_url%22%3A%22https%3A%2F%2Ffranjuanp.github.io%2FOkrtSystemLabs%2F%22%2C%22display%22%3A%22standalone%22%2C%22orientation%22%3A%22any%22%2C%22background_color%22%3A%22%2302060c%22%2C%22theme_color%22%3A%22%2300d4ff%22%2C%22categories%22%3A%5B%22finance%22%2C%22utilities%22%5D%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%2520viewBox%3D%270%25200%2520512%2520512%27%253E%253Cdefs%253E%253ClinearGradient%2520id%3D%27g%27%2520x1%3D%270%2525%27%2520y1%3D%270%2525%27%2520x2%3D%27100%2525%27%2520y2%3D%27100%2525%27%253E%253Cstop%2520offset%3D%270%2525%27%2520stop-color%3D%27%252300d4ff%27%2F%253E%253Cstop%2520offset%3D%27100%2525%27%2520stop-color%3D%27%2523a855f7%27%2F%253E%253C%2FlinearGradient%253E%253C%2Fdefs%253E%253Crect%2520width%3D%27512%27%2520height%3D%27512%27%2520rx%3D%27100%27%2520fill%3D%27%252302060c%27%2F%253E%253Crect%2520x%3D%27128%27%2520y%3D%27128%27%2520width%3D%27256%27%2520height%3D%27256%27%2520rx%3D%2740%27%2520fill%3D%27url%28%2523g%29%27%2520transform%3D%27rotate%2845%2520256%2520256%29%27%2F%253E%253Ctext%2520x%3D%27256%27%2520y%3D%27290%27%2520text-anchor%3D%27middle%27%2520font-family%3D%27Arial%2520Black%27%2520font-size%3D%27180%27%2520font-weight%3D%27900%27%2520fill%3D%27%252302060c%27%253EX%253C%2Ftext%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%2C%22purpose%22%3A%22any%20maskable%22%7D%5D%7D" rel="manifest"/><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&amp;family=Orbitron:wght@400;700;900&amp;family=Rajdhani:wght@400;600;700&amp;display=swap" rel="stylesheet"/><style>
    :root {
      --bg-primary: #02060c;
      --bg-card: rgba(13, 24, 41, 0.85); 
      --bg-header: rgba(2, 6, 12, 0.95);
      
      --accent-cyan: #00d4ff;
      --accent-purple: #a855f7;
      --accent-green: #00ff88;
      --accent-red: #ff4466;
      --accent-orange: #ff9500;
      --accent-yellow: #f4b942;
      --text-main: #f0f4f8;
      --text-dim: #94a3b8;
      
      --border-glass: 1px solid rgba(255, 255, 255, 0.15);
      --font-tech: 'Orbitron', sans-serif;
      --font-data: 'JetBrains Mono', monospace;
    }
    /* Modo Claro */
    body.light-mode {
      --bg-primary: #f0f4f8;
      --bg-card: rgba(255, 255, 255, 0.9);
      --bg-header: rgba(240, 244, 248, 0.98);
      --text-main: #1a202c;
      --text-dim: #4a5568;
      --border-glass: 1px solid rgba(0, 0, 0, 0.1);
    }
    body.light-mode { background: radial-gradient(circle at 50% 0%, #e2e8f0 0%, #f0f4f8 80%); }
    body.light-mode .grid-bg {
      background-image: 
        linear-gradient(rgba(0, 100, 150, 0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 100, 150, 0.08) 1px, transparent 1px);
    }
    body.light-mode .panel { background: var(--bg-card); border: 1px solid rgba(0,0,0,0.1); }
    body.light-mode .kpi-card { background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(240,244,248,0.9)); border: 1px solid rgba(0,0,0,0.08); }
    body.light-mode .ob-bid { color: #059669; }
    body.light-mode .ob-ask { color: #dc2626; }
    /* ðŸŒŸ Modo NEON Futurista */
    body.neon-mode {
      --bg-primary: #000000;
      --bg-card: rgba(5, 5, 20, 0.95);
      --bg-header: rgba(0, 0, 10, 0.98);
      --accent-cyan: #00ffff;
      --accent-purple: #ff00ff;
      --accent-green: #00ff00;
      --accent-red: #ff0040;
      --accent-orange: #ff6600;
      --accent-yellow: #ffff00;
      --text-main: #ffffff;
      --text-dim: #8888aa;
      --border-glass: 1px solid rgba(0, 255, 255, 0.2);
    }
    body.neon-mode { 
      background: radial-gradient(ellipse at 50% 0%, #0a0015 0%, #000005 50%, #000000 100%);
    }
    body.neon-mode .grid-bg {
      background-image: 
        linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 0, 255, 0.03) 1px, transparent 1px);
      background-size: 30px 30px;
    }
    body.neon-mode .panel { 
      background: linear-gradient(180deg, rgba(5, 5, 25, 0.95), rgba(0, 0, 15, 0.98));
      border: 1px solid rgba(0, 255, 255, 0.15);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.05), inset 0 0 30px rgba(0, 0, 0, 0.5);
    }
    body.neon-mode .kpi-card { 
      background: linear-gradient(180deg, rgba(10, 0, 20, 0.9), rgba(5, 5, 15, 0.95));
      border: 1px solid rgba(255, 0, 255, 0.2);
      box-shadow: 0 0 10px rgba(255, 0, 255, 0.1);
    }
    body.neon-mode header {
      background: linear-gradient(180deg, rgba(0, 0, 20, 0.98), rgba(0, 0, 10, 0.95));
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 2px 20px rgba(0, 255, 255, 0.1);
    }
    body.neon-mode .control-btn {
      border-color: rgba(0, 255, 255, 0.3);
      text-shadow: 0 0 5px currentColor;
    }
    body.neon-mode .control-btn:hover {
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
      text-shadow: 0 0 10px var(--accent-cyan);
    }
    body.neon-mode .status-pill {
      border-color: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }
    body.neon-mode .panel-head {
      text-shadow: 0 0 8px currentColor;
    }
    body.neon-mode .c-green { text-shadow: 0 0 8px var(--accent-green); }
    body.neon-mode .c-red { text-shadow: 0 0 8px var(--accent-red); }
    body.neon-mode .c-cyan { text-shadow: 0 0 8px var(--accent-cyan); }
    body.neon-mode .c-purple { text-shadow: 0 0 8px var(--accent-purple); }
    body.neon-mode #priceDisplay { text-shadow: 0 0 15px var(--accent-cyan); }
    body.neon-mode .tab-btn.active {
      box-shadow: 0 0 10px var(--accent-cyan);
    }
    body.neon-mode .score-meter {
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }
    body.neon-mode .accuracy-bar {
      box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
    }
    /* Controles del header */
    .header-controls {
      display: flex; gap: 8px; align-items: center;
    }
    .control-btn {
      font-family: var(--font-data); font-size: 10px;
      padding: 5px 10px; border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px; background: rgba(0,0,0,0.3);
      color: var(--text-dim); cursor: pointer; transition: all 0.2s;
    }
    .control-btn:hover { background: rgba(0,212,255,0.2); border-color: var(--accent-cyan); color: var(--accent-cyan); }
    .control-btn.active { background: var(--accent-cyan); color: #000; border-color: var(--accent-cyan); }
    
    .timeframe-select {
      font-family: var(--font-data); font-size: 10px;
      padding: 5px 8px; border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px; background: rgba(0,0,0,0.5);
      color: var(--accent-cyan); cursor: pointer;
    }
    .timeframe-select option { background: #0d1829; color: #fff; }
    
    .lang-select {
      font-family: var(--font-data); font-size: 10px;
      padding: 5px 8px; border: 1px solid rgba(168,85,247,0.4);
      border-radius: 4px; background: rgba(168,85,247,0.1);
      color: var(--accent-purple); cursor: pointer;
      min-width: 60px;
    }
    .lang-select option { background: #0d1829; color: #fff; }
    .lang-select:hover { border-color: var(--accent-purple); background: rgba(168,85,247,0.2); }
    body.light-mode .control-btn { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.2); color: var(--text-dim); }
    body.light-mode .control-btn:hover { background: rgba(0,212,255,0.1); }
    body.light-mode .timeframe-select { background: rgba(255,255,255,0.8); color: #1a202c; border-color: rgba(0,0,0,0.2); }
    body.light-mode .lang-select { background: rgba(255,255,255,0.8); color: #6b21a8; border-color: rgba(168,85,247,0.4); }
    /* Mini grfico de accuracy */
    .accuracy-chart {
      display: flex; align-items: flex-end; gap: 1px; height: 30px; padding: 5px;
      background: rgba(0,0,0,0.2); border-radius: 3px; margin: 5px 10px;
    }
    .accuracy-bar-mini {
      width: 4px; border-radius: 1px; transition: height 0.3s;
      min-height: 2px;
    }
    /* ============================================
       TOOLS PANEL - Multi-TF, Risk Calc, Alerts
       ============================================ */
    .tools-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(5px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .tools-overlay.active { display: flex; }
    .tools-panel {
      width: 900px;
      max-height: 85vh;
      background: linear-gradient(180deg, #0d1829 0%, #061018 100%);
      border: 1px solid rgba(0,212,255,0.3);
      border-radius: 16px;
      box-shadow: 0 0 60px rgba(0,212,255,0.2);
      overflow: hidden;
    }
    .tools-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .tools-header h2 {
      font-family: var(--font-tech);
      font-size: 16px;
      color: var(--accent-cyan);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .tools-close {
      background: none;
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--text-dim);
      width: 30px; height: 30px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }
    .tools-close:hover {
      background: var(--accent-red);
      border-color: var(--accent-red);
      color: #fff;
    }
    .tools-tabs {
      display: flex;
      gap: 5px;
      padding: 10px 20px;
      background: rgba(0,0,0,0.2);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .tools-tab {
      padding: 10px 20px;
      border: none;
      background: rgba(255,255,255,0.05);
      color: var(--text-dim);
      border-radius: 8px;
      cursor: pointer;
      font-family: var(--font-tech);
      font-size: 11px;
      transition: all 0.2s;
    }
    .tools-tab:hover { background: rgba(0,212,255,0.1); color: var(--accent-cyan); }
    .tools-tab.active { background: var(--accent-cyan); color: #000; }
    .tools-content {
      padding: 20px;
      max-height: 60vh;
      overflow-y: auto;
    }
    .tool-section { display: none; }
    .tool-section.active { display: block; }
    /* Multi-Timeframe Panel */
    .mtf-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
    }
    .mtf-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }
    .mtf-card.bullish { border-color: rgba(0,255,136,0.3); background: rgba(0,255,136,0.05); }
    .mtf-card.bearish { border-color: rgba(255,68,102,0.3); background: rgba(255,68,102,0.05); }
    .mtf-tf {
      font-family: var(--font-tech);
      font-size: 18px;
      color: var(--accent-cyan);
      margin-bottom: 10px;
    }
    .mtf-price {
      font-family: var(--font-data);
      font-size: 14px;
      color: var(--text-main);
      margin-bottom: 8px;
    }
    .mtf-signal {
      font-size: 11px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      margin-bottom: 8px;
    }
    .mtf-signal.bullish { background: rgba(0,255,136,0.2); color: var(--accent-green); }
    .mtf-signal.bearish { background: rgba(255,68,102,0.2); color: var(--accent-red); }
    .mtf-signal.neutral { background: rgba(255,255,255,0.1); color: var(--text-dim); }
    .mtf-indicators {
      font-size: 9px;
      color: var(--text-dim);
      line-height: 1.6;
    }
    .mtf-rsi { font-weight: 600; }
    .mtf-rsi.oversold { color: var(--accent-green); }
    .mtf-rsi.overbought { color: var(--accent-red); }
    .mtf-rsi.neutral { color: var(--text-dim); }
    /* Risk Calculator */
    .risk-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .risk-inputs, .risk-results {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }
    .risk-inputs h3, .risk-results h3 {
      font-family: var(--font-tech);
      font-size: 12px;
      color: var(--accent-cyan);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .input-group {
      margin-bottom: 15px;
    }
    .input-group label {
      display: block;
      font-size: 11px;
      color: var(--text-dim);
      margin-bottom: 5px;
    }
    .input-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: var(--text-main);
      font-family: var(--font-data);
      font-size: 13px;
    }
    .input-group input:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }
    .input-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .result-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .result-item:last-child { border: none; }
    .result-label {
      font-size: 11px;
      color: var(--text-dim);
    }
    .result-value {
      font-family: var(--font-data);
      font-size: 13px;
      font-weight: 600;
    }
    .result-value.green { color: var(--accent-green); }
    .result-value.red { color: var(--accent-red); }
    .result-value.cyan { color: var(--accent-cyan); }
    .risk-ratio {
      text-align: center;
      padding: 15px;
      background: rgba(0,212,255,0.1);
      border-radius: 8px;
      margin-top: 15px;
    }
    .risk-ratio-value {
      font-family: var(--font-tech);
      font-size: 28px;
      color: var(--accent-cyan);
    }
    .risk-ratio-label {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 5px;
    }
    /* Price Alerts */
    .alerts-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .alerts-form, .alerts-list-panel {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }
    .alerts-form h3, .alerts-list-panel h3 {
      font-family: var(--font-tech);
      font-size: 12px;
      color: var(--accent-cyan);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .alert-type-btns {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .alert-type-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(0,0,0,0.2);
      color: var(--text-dim);
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }
    .alert-type-btn:hover { border-color: var(--accent-cyan); }
    .alert-type-btn.active.above { background: rgba(0,255,136,0.2); border-color: var(--accent-green); color: var(--accent-green); }
    .alert-type-btn.active.below { background: rgba(255,68,102,0.2); border-color: var(--accent-red); color: var(--accent-red); }
    .add-alert-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border: none;
      border-radius: 8px;
      color: #000;
      font-family: var(--font-tech);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .add-alert-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,212,255,0.3); }
    .custom-alerts-list {
      max-height: 300px;
      overflow-y: auto;
    }
    .custom-alert-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      margin-bottom: 8px;
      border-left: 3px solid;
    }
    .custom-alert-item.above { border-color: var(--accent-green); }
    .custom-alert-item.below { border-color: var(--accent-red); }
    .custom-alert-item.triggered { opacity: 0.5; }
    .alert-info {
      flex: 1;
    }
    .alert-price {
      font-family: var(--font-data);
      font-size: 14px;
      font-weight: 600;
      color: var(--text-main);
    }
    .alert-condition {
      font-size: 10px;
      color: var(--text-dim);
    }
    .alert-delete {
      background: none;
      border: none;
      color: var(--accent-red);
      cursor: pointer;
      font-size: 16px;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    .alert-delete:hover { opacity: 1; }
    .no-alerts {
      text-align: center;
      padding: 30px;
      color: var(--text-dim);
      font-size: 12px;
    }
    /* ============================================
       NEW TOOLS: Fibo, Session, Strategy, Correlation, Watchlist
       ============================================ */
    
    /* Session Stats */
    .session-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .session-stat {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }
    .session-stat-value {
      font-family: var(--font-tech);
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 5px;
    }
    .session-stat-label {
      font-size: 10px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .session-timeline {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 15px;
    }
    .timeline-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 11px;
    }
    .timeline-row:last-child { border: none; }
    /* Fibonacci */
    .fibo-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .fibo-levels, .fibo-info {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }
    .fibo-level-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .fibo-level-row:last-child { border: none; }
    .fibo-label {
      font-size: 12px;
      color: var(--text-dim);
    }
    .fibo-price {
      font-family: var(--font-data);
      font-size: 13px;
      font-weight: 600;
    }
    .fibo-bar {
      flex: 1;
      height: 4px;
      background: rgba(255,255,255,0.1);
      margin: 0 15px;
      border-radius: 2px;
      position: relative;
    }
    .fibo-bar-fill {
      position: absolute;
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s;
    }
    .fibo-current-marker {
      position: absolute;
      width: 8px;
      height: 8px;
      background: var(--accent-cyan);
      border-radius: 50%;
      top: -2px;
      transform: translateX(-50%);
      box-shadow: 0 0 10px var(--accent-cyan);
    }
    /* Correlation */
    .corr-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
    }
    .corr-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    .corr-pair {
      font-family: var(--font-tech);
      font-size: 14px;
      color: var(--accent-cyan);
      margin-bottom: 10px;
    }
    .corr-value {
      font-family: var(--font-data);
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 5px;
    }
    .corr-value.positive { color: var(--accent-green); }
    .corr-value.negative { color: var(--accent-red); }
    .corr-value.neutral { color: var(--text-dim); }
    .corr-label {
      font-size: 10px;
      color: var(--text-dim);
    }
    .corr-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      margin-top: 10px;
      overflow: hidden;
    }
    .corr-bar-fill {
      height: 100%;
      transition: width 0.5s;
    }
    /* Watchlist */
    .watchlist-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .watchlist-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .watchlist-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      background: rgba(255,255,255,0.05);
    }
    .watchlist-info { flex: 1; }
    .watchlist-symbol {
      font-family: var(--font-tech);
      font-size: 14px;
      color: var(--text-main);
    }
    .watchlist-name {
      font-size: 10px;
      color: var(--text-dim);
    }
    .watchlist-price {
      text-align: right;
    }
    .watchlist-price-value {
      font-family: var(--font-data);
      font-size: 16px;
      font-weight: 600;
    }
    .watchlist-change {
      font-size: 11px;
      font-family: var(--font-data);
    }
    .watchlist-change.up { color: var(--accent-green); }
    .watchlist-change.down { color: var(--accent-red); }
    .watchlist-mini-chart {
      width: 60px;
      height: 30px;
      display: flex;
      align-items: flex-end;
      gap: 2px;
    }
    .mini-bar {
      flex: 1;
      border-radius: 1px;
      transition: height 0.3s;
    }
    /* Strategy Builder */
    .strategy-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .strategy-builder, .strategy-list {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }
    .condition-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .condition-row select, .condition-row input {
      padding: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: var(--text-main);
      font-family: var(--font-data);
      font-size: 11px;
    }
    .condition-row select { flex: 1; }
    .condition-row input { width: 80px; }
    .logic-connector {
      text-align: center;
      padding: 5px;
      font-size: 10px;
      color: var(--accent-purple);
      font-weight: 600;
    }
    .strategy-item {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      border-left: 3px solid var(--accent-purple);
    }
    .strategy-item.active { border-color: var(--accent-green); }
    .strategy-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .strategy-item-name {
      font-family: var(--font-tech);
      font-size: 12px;
      color: var(--accent-cyan);
    }
    .strategy-item-toggle {
      width: 40px;
      height: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      position: relative;
      cursor: pointer;
      transition: background 0.3s;
    }
    .strategy-item-toggle.active {
      background: var(--accent-green);
    }
    .strategy-item-toggle::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      top: 2px;
      left: 2px;
      transition: left 0.3s;
    }
    .strategy-item-toggle.active::after {
      left: 22px;
    }
    .strategy-conditions {
      font-size: 10px;
      color: var(--text-dim);
      line-height: 1.6;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at 50% 0%, #112240 0%, var(--bg-primary) 80%);
      color: var(--text-main);
      font-family: 'Rajdhani', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .grid-bg {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
      background-image: 
        linear-gradient(rgba(0, 212, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 212, 255, 0.05) 1px, transparent 1px);
      background-size: 50px 50px;
      mask-image: radial-gradient(circle at 50% 50%, black 40%, transparent 90%);
    }
    header {
      height: 55px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      background: var(--bg-header);
      border-bottom: var(--border-glass);
      z-index: 10;
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .brand h1 { font-family: var(--font-tech); font-size: 18px; letter-spacing: 2px; color: var(--accent-cyan); text-shadow: 0 0 10px rgba(0,212,255,0.4); }
    
    .header-center {
      display: flex; gap: 15px; align-items: center;
    }
    .header-stat {
      font-family: var(--font-data); font-size: 11px;
      padding: 4px 10px; border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px; background: rgba(0,0,0,0.3);
    }
    .header-stat span { color: var(--text-dim); }
    .status-pill {
      font-family: var(--font-data); font-size: 11px; padding: 4px 10px;
      border: 1px solid #333; border-radius: 4px;
      display: flex; align-items: center; gap: 6px;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
    .status-live .status-dot { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
    .status-err .status-dot { background: var(--accent-red); }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 340px 1fr 320px;
      grid-template-rows: 70px 1fr 180px;
      gap: 8px;
      padding: 8px;
      overflow: hidden;
    }
    .panel {
      background: var(--bg-card);
      border: var(--border-glass);
      border-radius: 4px;
      backdrop-filter: blur(5px);
      display: flex; flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    
    .panel-head {
      font-family: var(--font-tech); font-size: 9px; color: var(--text-dim);
      padding: 6px 10px; border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex; justify-content: space-between; letter-spacing: 1px;
      flex-shrink: 0; align-items: center;
    }
    .metrics-wrapper {
      grid-column: 1 / -1; grid-row: 1;
      display: flex; gap: 10px;
    }
    .kpi-card {
      flex: 1; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2));
      border: var(--border-glass); padding: 8px 12px;
      display: flex; flex-direction: column; justify-content: center;
    }
    .kpi-val { font-family: var(--font-data); font-size: 20px; font-weight: 700; color: var(--text-main); margin-top: 3px; }
    .kpi-lbl { font-size: 10px; color: var(--text-dim); text-transform: uppercase; }
    .kpi-sub { font-size: 9px; color: var(--text-dim); margin-top: 2px; }
    .chart-box {
      grid-column: 2; grid-row: 2;
      position: relative;
      overflow: hidden; 
    }
    #chartContainer { width: 100%; height: 100%; }
    .side-left { grid-column: 1; grid-row: 2 / 4; display: flex; flex-direction: column; gap: 10px; }
    .side-right { grid-column: 3; grid-row: 2 / 4; display: flex; flex-direction: column; gap: 10px; }
    .bottom-box { grid-column: 2; grid-row: 3; display: grid; grid-template-columns: 2fr 1fr; gap: 10px; }
    .ob-row {
      display: flex; justify-content: space-between; font-family: var(--font-data); font-size: 11px;
      padding: 2px 8px;
    }
    .ob-ask { color: var(--accent-red); }
    .ob-bid { color: var(--accent-green); }
    
    .whale-item {
      font-size: 10px; padding: 5px 10px; border-left: 3px solid var(--accent-purple);
      margin-bottom: 3px; background: rgba(255,255,255,0.02); font-family: var(--font-data);
      display: flex; justify-content: space-between; align-items: center;
    }
    .whale-item.buy { border-left-color: var(--accent-green); }
    .whale-item.sell { border-left-color: var(--accent-red); }
    .indicator-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 5px 10px; border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 11px;
    }
    .indicator-label { color: var(--text-dim); }
    .indicator-value { font-family: var(--font-data); font-weight: 600; font-size: 11px; }
    .indicator-signal {
      font-size: 8px; padding: 2px 5px; border-radius: 3px;
      text-transform: uppercase; font-weight: 700;
    }
    .signal-buy { background: rgba(0,255,136,0.2); color: var(--accent-green); }
    .signal-sell { background: rgba(255,68,102,0.2); color: var(--accent-red); }
    .signal-neutral { background: rgba(255,255,255,0.1); color: var(--text-dim); }
    .signal-warning { background: rgba(255,149,0,0.2); color: var(--accent-orange); }
    /* AI Engine Classes - Base styles */
    .ai-label { font-size: 8px; }
    .ai-regime { font-size: 14px; }
    .ai-quality { font-size: 14px; }
    .ai-prob { font-size: 22px; }
    .ai-target-price { font-size: 24px; }
    .ai-conf { font-size: 9px; }
    .smc-label { font-size: 8px; }
    .smc-value { font-size: 9px; }
    .mtf-label { font-size: 7px; }
    .mtf-value { font-size: 10px; }
    .conf-value { font-size: 16px; }
    .prediction-box {
      text-align: center; padding: 12px;
      border: 1px solid rgba(0, 212, 255, 0.3);
      background: rgba(0, 212, 255, 0.05);
      margin: 8px; border-radius: 4px;
    }
    .score-meter {
      height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px;
      margin: 8px 10px; overflow: hidden; position: relative;
    }
    .score-fill {
      height: 100%; border-radius: 3px; transition: all 0.5s ease;
      position: absolute; left: 50%;
    }
    .wall-indicator {
      font-size: 9px; padding: 3px 6px; margin: 2px 6px;
      background: rgba(168, 85, 247, 0.15); border-radius: 3px;
      border-left: 2px solid var(--accent-purple);
    }
    .alert-item {
      font-size: 10px; padding: 6px 10px; margin: 3px 8px;
      border-radius: 4px; font-family: var(--font-data);
      animation: alertPulse 0.5s ease;
    }
    .alert-bullish { background: rgba(0,255,136,0.15); border-left: 3px solid var(--accent-green); }
    .alert-bearish { background: rgba(255,68,102,0.15); border-left: 3px solid var(--accent-red); }
    .alert-warning { background: rgba(255,149,0,0.15); border-left: 3px solid var(--accent-orange); }
    .alert-info { background: rgba(0,212,255,0.15); border-left: 3px solid var(--accent-cyan); }
    @keyframes alertPulse {
      0% { opacity: 0; transform: translateX(-10px); }
      100% { opacity: 1; transform: translateX(0); }
    }
    .divergence-badge {
      position: absolute; top: 8px; right: 8px;
      font-size: 9px; padding: 3px 8px; border-radius: 3px;
      font-family: var(--font-data); font-weight: 700;
      animation: pulse 2s infinite;
    }
    .div-bullish { background: var(--accent-green); color: #000; }
    .div-bearish { background: var(--accent-red); color: #fff; }
    .pattern-tag {
      display: inline-block; font-size: 9px; padding: 2px 6px;
      margin: 2px; border-radius: 3px; background: rgba(168,85,247,0.2);
      color: var(--accent-purple); font-family: var(--font-data);
    }
    .accuracy-bar {
      height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px;
      overflow: hidden; margin-top: 5px;
    }
    .accuracy-fill { height: 100%; background: var(--accent-cyan); transition: width 0.5s; }
    .derivatives-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
      padding: 8px; font-size: 10px;
    }
    .deriv-item {
      background: rgba(0,0,0,0.2); padding: 6px 8px; border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .deriv-label { color: var(--text-dim); font-size: 9px; }
    .deriv-value { font-family: var(--font-data); font-size: 13px; font-weight: 600; margin-top: 2px; }
    .etf-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px;
      font-size: 10px;
    }
    .etf-item {
      background: rgba(0,0,0,0.2); padding: 5px 7px; border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .etf-label { color: var(--text-dim); font-size: 8px; text-transform: uppercase; }
    .etf-value { font-family: var(--font-data); font-size: 11px; font-weight: 600; margin-top: 2px; }
    .c-green { color: var(--accent-green); }
    .c-red { color: var(--accent-red); }
    .c-orange { color: var(--accent-orange); }
    .c-purple { color: var(--accent-purple); }
    .c-cyan { color: var(--accent-cyan); }
    .scrollable { overflow-y: auto; flex: 1; }
    .scrollable::-webkit-scrollbar { width: 4px; }
    .scrollable::-webkit-scrollbar-track { background: transparent; }
    .scrollable::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse { animation: pulse 2s infinite; }
    .tab-buttons {
      display: flex; gap: 5px; padding: 5px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .tab-btn {
      font-size: 9px; padding: 3px 8px; border: none;
      background: rgba(255,255,255,0.05); color: var(--text-dim);
      border-radius: 3px; cursor: pointer; font-family: var(--font-tech);
    }
    .tab-btn.active { background: var(--accent-cyan); color: #000; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    /* ============================================
       PWA INSTALL BANNER
       ============================================ */
    .pwa-install-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #0d1829 0%, #1a0a2e 100%);
      border-top: 1px solid rgba(0, 212, 255, 0.3);
      padding: 15px 20px;
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 15px;
      z-index: 10000;
      box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.5);
      animation: slideUp 0.3s ease;
    }
    .pwa-install-banner.show { display: flex; }
    
    @keyframes slideUp {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .pwa-install-content {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
    }
    
    .pwa-install-icon {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 900;
      color: #000;
      font-family: var(--font-tech);
      transform: rotate(45deg);
    }
    .pwa-install-icon span { transform: rotate(-45deg); }
    
    .pwa-install-text h4 {
      font-family: var(--font-tech);
      font-size: 14px;
      color: var(--accent-cyan);
      margin-bottom: 3px;
    }
    .pwa-install-text p {
      font-size: 12px;
      color: var(--text-dim);
    }
    
    .pwa-install-btn {
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      color: #000;
      font-family: var(--font-tech);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .pwa-install-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
    }
    
    .pwa-install-close {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 20px;
      cursor: pointer;
      padding: 5px;
    }
    .pwa-install-close:hover { color: var(--accent-red); }
    /* iOS Install Instructions Modal */
    .ios-install-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      padding: 20px;
    }
    .ios-install-modal.show { display: flex; }
    
    .ios-install-content {
      background: linear-gradient(180deg, #0d1829 0%, #061018 100%);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 20px;
      padding: 30px;
      max-width: 350px;
      text-align: center;
    }
    
    .ios-install-content h3 {
      font-family: var(--font-tech);
      color: var(--accent-cyan);
      margin-bottom: 20px;
    }
    
    .ios-step {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin-bottom: 10px;
      text-align: left;
    }
    
    .ios-step-num {
      width: 30px;
      height: 30px;
      background: var(--accent-cyan);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #000;
      flex-shrink: 0;
    }
    
    .ios-step-text {
      font-size: 13px;
      color: var(--text-main);
    }
    
    .ios-step-icon {
      font-size: 20px;
    }
    /* ============================================
       MOBILE RESPONSIVE STYLES
       ============================================ */
    @media screen and (max-width: 1200px) {
      main {
        grid-template-columns: 280px 1fr 280px;
      }
      .kpi-card { padding: 8px; }
      .kpi-val { font-size: 18px; }
    }
    @media screen and (max-width: 992px) {
      main {
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        padding: 10px;
        gap: 10px;
      }
      
      .metrics-wrapper {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        order: 1;
      }
      
      .kpi-card {
        padding: 10px;
      }
      
      .chart-box {
        order: 2;
        height: 300px;
        min-height: 300px;
        grid-column: auto;
        grid-row: auto;
      }
      
      .side-left, .side-right {
        order: 3;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      
      .bottom-box {
        order: 4;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
      
      .panel { min-height: auto; }
      
      header {
        flex-wrap: wrap;
        height: auto;
        padding: 10px;
        gap: 10px;
      }
      
      .header-center {
        order: 3;
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }
      
      .brand { order: 1; }
      .header-controls { order: 2; }
      .status-pill { order: 4; }
    }
    @media screen and (max-width: 768px) {
      .metrics-wrapper {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .chart-box {
        height: 280px;
        min-height: 280px;
      }
      
      .side-left, .side-right {
        grid-template-columns: 1fr;
      }
      
      .bottom-box {
        grid-template-columns: 1fr;
      }
      
      .brand h1 { font-size: 14px; }
      
      .header-controls {
        gap: 5px;
      }
      
      .control-btn {
        padding: 4px 8px;
        font-size: 9px;
      }
      
      .header-stat {
        padding: 3px 6px;
        font-size: 9px;
      }
      
      .tools-panel {
        width: 95vw;
        max-height: 90vh;
        margin: 10px;
      }
      
      .tools-tabs {
        flex-wrap: wrap;
        gap: 5px;
      }
      
      .tools-tab {
        padding: 8px 12px;
        font-size: 10px;
      }
      
      .mtf-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .risk-grid,
      .fibo-container,
      .alerts-container,
      .strategy-container,
      .corr-grid {
        grid-template-columns: 1fr;
      }
      
      .watchlist-grid {
        grid-template-columns: 1fr;
      }
      
      .session-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media screen and (max-width: 480px) {
      .metrics-wrapper {
        grid-template-columns: 1fr 1fr;
      }
      
      .kpi-card {
        padding: 8px;
      }
      
      .kpi-lbl { font-size: 8px; }
      .kpi-val { font-size: 16px; }
      .kpi-sub { font-size: 9px; }
      
      .chart-box {
        height: 220px;
        min-height: 220px;
      }
      
      .brand h1 {
        font-size: 12px;
        letter-spacing: 1px;
      }
      
      .header-center {
        display: none;
      }
      
      .panel-head {
        font-size: 10px;
        padding: 8px;
      }
      
      .mtf-grid {
        grid-template-columns: 1fr;
      }
      
      .ob-row {
        font-size: 9px;
      }
      
      .alert-item {
        font-size: 9px;
        padding: 5px 8px;
      }
    }
    /* PWA Standalone Mode Adjustments */
    @media all and (display-mode: standalone) {
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      
      header {
        padding-top: calc(10px + env(safe-area-inset-top));
      }
      
      .pwa-install-banner {
        display: none !important;
      }
    }
    /* Landscape mobile */
    @media screen and (max-height: 500px) and (orientation: landscape) {
      header { height: 45px; padding: 5px 10px; }
      .brand h1 { font-size: 12px; }
      .metrics-wrapper { display: none; }
      main { padding: 5px; }
      .chart-box { height: calc(100vh - 60px); }
    }
    /* ========================================= */
    /*  LARGE SCREENS (1600px+) */
    /* ========================================= */
    @media screen and (min-width: 1600px) {
      /* Grid Layout - Sidebars ms grandes */
      main {
        grid-template-columns: 380px 1fr 360px;
        grid-template-rows: 75px 1fr 200px;
        gap: 10px;
        padding: 10px;
      }
      
      /* Header */
      header { padding: 10px 25px; }
      .brand h1 { font-size: 22px; }
      .brand span { font-size: 11px; }
      .control-btn { font-size: 12px; padding: 8px 14px; }
      .status-pill { font-size: 13px; padding: 8px 18px; }
      
      /* KPIs */
      .kpi-card { padding: 14px 18px; }
      .kpi-card .label { font-size: 11px; }
      .kpi-card .value { font-size: 26px; }
      .kpi-card .sub { font-size: 11px; }
      
      /* Panels */
      .panel { border-radius: 10px; }
      .panel-head { font-size: 13px; padding: 10px 14px; }
      
      /* AI Engine Panel */
      .prediction-box { padding: 10px; }
      .ai-regime { font-size: 15px !important; }
      .ai-quality { font-size: 15px !important; }
      .ai-prob { font-size: 26px !important; }
      .ai-target-price { font-size: 28px !important; }
      .ai-label { font-size: 9px !important; }
      .ai-conf { font-size: 11px !important; }
      .smc-label { font-size: 9px !important; }
      .smc-value { font-size: 10px !important; }
      .mtf-label { font-size: 8px !important; }
      .mtf-value { font-size: 12px !important; }
      .conf-value { font-size: 18px !important; }
      
      /* Indicators */
      .indicator-row { padding: 5px 10px !important; }
      .indicator-label { font-size: 11px !important; }
      .indicator-value { font-size: 11px !important; }
      .indicator-signal { font-size: 9px !important; padding: 3px 8px !important; }
      
      /* Tab buttons */
      .tab-btn { font-size: 10px !important; padding: 5px 10px !important; }
      
      /* Order Book */
      .ob-row { font-size: 12px; padding: 4px 10px; }
      #midPrice { font-size: 16px !important; }
      
      /* Whale list */
      .whale-item { font-size: 11px; padding: 6px 10px; }
      
      /* Bottom panels */
      .bottom-box .panel { padding: 12px; }
      .bottom-box .panel-head { font-size: 12px; }
      
      /* Patterns */
      .pattern-tag { font-size: 10px !important; padding: 4px 8px !important; }
      
      /* Alerts */
      .alert-item { font-size: 11px; padding: 8px 12px; }
    }
    /* ========================================= */
    /*  EXTRA LARGE SCREENS (1920px+) */
    /* ========================================= */
    @media screen and (min-width: 1920px) {
      /* Grid Layout - Sidebars an ms grandes para Full HD */
      main {
        grid-template-columns: 420px 1fr 400px;
        grid-template-rows: 80px 1fr 220px;
        gap: 12px;
        padding: 12px;
      }
      
      /* Header */
      header { padding: 12px 30px; }
      .brand h1 { font-size: 26px; }
      .brand span { font-size: 13px; }
      .control-btn { font-size: 13px; padding: 10px 16px; }
      .status-pill { font-size: 14px; padding: 10px 22px; }
      
      /* KPIs */
      .kpi-card { padding: 18px 22px; }
      .kpi-card .label { font-size: 13px; }
      .kpi-card .value { font-size: 32px; }
      .kpi-card .sub { font-size: 13px; }
      
      /* Panels */
      .panel-head { font-size: 15px; padding: 12px 16px; }
      
      /* AI Engine */
      .ai-regime { font-size: 18px !important; }
      .ai-quality { font-size: 18px !important; }
      .ai-prob { font-size: 32px !important; }
      .ai-target-price { font-size: 34px !important; }
      .ai-label { font-size: 10px !important; }
      .ai-conf { font-size: 13px !important; }
      .smc-label { font-size: 10px !important; }
      .smc-value { font-size: 12px !important; }
      .mtf-label { font-size: 9px !important; }
      .mtf-value { font-size: 14px !important; }
      .conf-value { font-size: 22px !important; }
      
      /* Indicators */
      .indicator-row { padding: 6px 12px !important; }
      .indicator-label { font-size: 13px !important; }
      .indicator-value { font-size: 13px !important; }
      .indicator-signal { font-size: 10px !important; padding: 4px 10px !important; }
      
      /* Tab buttons */
      .tab-btn { font-size: 11px !important; padding: 6px 12px !important; }
      
      /* Order Book */
      .ob-row { font-size: 14px; padding: 5px 12px; }
      #midPrice { font-size: 20px !important; }
      
      /* Bottom */
      .bottom-box .panel-head { font-size: 14px; }
      
      /* Pattern tags */
      .pattern-tag { font-size: 11px !important; padding: 5px 10px !important; }
    }
    /* ========================================= */
    /*  4K SCREENS (2560px+) */
    /* ========================================= */
    @media screen and (min-width: 2560px) {
      /* Grid Layout - Mximo espacio para 4K */
      main {
        grid-template-columns: 500px 1fr 480px;
        grid-template-rows: 90px 1fr 260px;
        gap: 15px;
        padding: 15px;
      }
      
      header { padding: 15px 40px; }
      .brand h1 { font-size: 32px; }
      .brand span { font-size: 16px; }
      .control-btn { font-size: 15px; padding: 12px 20px; }
      
      .kpi-card .value { font-size: 40px; }
      .kpi-card .label { font-size: 15px; }
      
      .panel-head { font-size: 18px; }
      
      .ai-regime { font-size: 22px !important; }
      .ai-prob { font-size: 40px !important; }
      .ai-target-price { font-size: 42px !important; }
      
      .indicator-label { font-size: 15px !important; }
      .indicator-value { font-size: 15px !important; }
      .indicator-signal { font-size: 12px !important; }
      
      #midPrice { font-size: 24px !important; }
    }
  </style></head><body><!-- Hidden elements for legacy code compatibility -->
<div style="display:none;">
<span id="r2"></span>
<span id="r1"></span>
<span id="currentLevel"></span>
<span id="s1"></span>
<span id="s2"></span>
</div>
<div class="grid-bg"></div><header><div class="brand"><div style="width:15px; height:15px; background:var(--accent-cyan); transform:rotate(45deg);"></div><h1> ORACULUM <span style="opacity:0.5; font-weight:400; font-size:14px;">OkrtSystem Labs</span></h1></div><div class="header-center"><div class="header-stat"><span>BTC:</span><span class="c-cyan" id="btcPrice">--</span></div><div class="header-stat" id="sessionDisplay" style="min-width:140px;">
         <span style="color:var(--text-dim)">LOADING...</span></div><div class="header-stat"><span>Accuracy:</span><span class="c-green" id="accuracyPct">--%</span></div></div><!-- CONTROLES --><div class="header-controls"><select class="timeframe-select" id="timeframeSelect" title="Timeframe"><option value="1m">1m</option><option value="5m">5m</option><option value="15m">15m</option><option value="4h">4h</option></select><button class="control-btn" id="soundBtn" onclick="toggleSound()" title="Sound Alerts">
         ðŸ”‡ OFF
      </button><button class="control-btn" id="voiceBtn" onclick="toggleVoice()" style="min-width:70px;" title="AI Voice Alerts">
         ðŸŽ™ï¸ <span style="color:var(--text-dim)">OFF</span></button><select class="lang-select" id="voiceLangSelect" onchange="changeVoiceLanguage(this.value)" title="Voice Language"><option value="en">ðŸ‡¬ðŸ‡§ EN</option><option value="es">ðŸ‡ªðŸ‡¸ ES</option></select><button class="control-btn" id="themeBtn" onclick="toggleTheme()" title="Change Theme">
         ðŸŽ¨ NEON
      </button><button class="control-btn" onclick="toggleMultiChart()" style="background:linear-gradient(135deg, rgba(168,85,247,0.2), rgba(0,212,255,0.2)); border-color:var(--accent-purple);" title="Multi-Chart Mode (M)">
         ðŸ“Š 4-VIEW
      </button><button class="control-btn" id="toolsBtn" onclick="toggleToolsPanel()" style="background:linear-gradient(135deg, rgba(0,212,255,0.2), rgba(168,85,247,0.2)); border-color:var(--accent-cyan);" title="Trading Tools">
         ðŸ› ï¸ TOOLS
      </button></div><div class="status-pill" id="statusPill"><div class="status-dot"></div><span id="apiStatusText">INITIALIZING...</span><span id="voiceIndicator" style="margin-left:8px; font-size:12px;" title="Voice Status"></span><span id="clock" style="margin-left:10px; color:#fff;">00:00:00</span></div></header><main><!-- KPIs TOP --><div class="metrics-wrapper"><div class="kpi-card"><span class="kpi-lbl">XRP/USDT</span><span class="kpi-val" id="priceDisplay">--.----</span><span class="kpi-sub" id="priceChange">--</span></div><div class="kpi-card"><span class="kpi-lbl">24H VOL</span><span class="kpi-val" id="volDisplay">--</span><span class="kpi-sub">USDT</span></div><div class="kpi-card"><span class="kpi-lbl">FEAR &amp; GREED</span><span class="kpi-val" id="fgIndex" style="color:#f4b942">--</span><span class="kpi-sub" id="fgLabel">Loading...</span></div><div class="kpi-card"><span class="kpi-lbl">FUNDING RATE</span><span class="kpi-val c-cyan" id="fundingRate">--</span><span class="kpi-sub" id="fundingLabel">8h</span></div><div class="kpi-card"><span class="kpi-lbl">OPEN INTEREST</span><span class="kpi-val c-purple" id="openInterest">--</span><span class="kpi-sub" id="oiChange">--</span></div><div class="kpi-card"><span class="kpi-lbl">MARKET SCORE</span><span class="kpi-val" id="totalScore">--</span><span class="kpi-sub" id="scoreLabel">Calculating...</span></div></div><!-- SIDEBAR IZQUIERDA --><div class="side-left"><div class="panel" style="flex:1; display:flex; flex-direction:column;"><div class="panel-head">
           ðŸ¤– AI ENGINE <span class="ai-label" style="background:linear-gradient(90deg, #ff00ff, #00ffff); -webkit-background-clip:text; -webkit-text-fill-color:transparent; font-weight:bold;">by OkrtSystem Labs</span><span class="pulse" style="color:var(--accent-green)"></span></div><div class="prediction-box" style="flex:1; display:flex; flex-direction:column; padding:8px;"><!-- Market Regime + Signal Quality --><div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; padding:6px 10px; background:rgba(0,212,255,0.08); border-radius:6px;"><div><div class="ai-label" style="color:var(--text-dim);">REGIME</div><div class="ai-regime" id="marketRegime" style="font-weight:bold; color:var(--accent-cyan);">ANALYZING...</div></div><div style="text-align:right;"><div class="ai-label" style="color:var(--text-dim);">QUALITY</div><div class="ai-quality" id="signalQuality" style="font-weight:bold; color:var(--accent-green);">--%</div></div></div><!-- Multi-TF Confluence --><div style="margin-bottom:6px; padding:5px 8px; background:linear-gradient(135deg, rgba(255,0,255,0.05), rgba(0,255,255,0.05)); border-radius:5px; border:1px solid rgba(255,0,255,0.15);"><div style="display:flex; justify-content:space-between; align-items:center; gap:4px;"><div class="mtf-label" style="color:var(--accent-purple);">MTF</div><div class="mtf-box" id="mtf1m" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;"><span class="mtf-label" style="color:var(--text-dim);">1M</span><span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span></div><div class="mtf-box" id="mtf5m" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;"><span class="mtf-label" style="color:var(--text-dim);">5M</span><span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span></div><div class="mtf-box" id="mtf15m" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;"><span class="mtf-label" style="color:var(--text-dim);">15M</span><span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span></div><div class="mtf-box" id="mtf1h" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;"><span class="mtf-label" style="color:var(--text-dim);">1H</span><span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span></div><div id="mtfScore" style="text-align:center; padding:3px 8px; background:rgba(168,85,247,0.2); border-radius:4px;"><span class="mtf-value" style="font-weight:bold; color:var(--accent-purple);">0/4</span></div></div></div><!-- Bull/Bear Probability --><div style="display:flex; justify-content:space-between; margin-bottom:6px; gap:6px;"><div style="text-align:center; flex:1; background:rgba(0,255,136,0.05); padding:6px; border-radius:6px; border:1px solid rgba(0,255,136,0.2);"><div class="ai-label" style="color:var(--accent-green);">ðŸ“ˆ BULL</div><div class="ai-prob" id="probBull" style="font-weight:bold; color:var(--accent-green);">50%</div></div><div style="text-align:center; flex:1; background:rgba(255,68,102,0.05); padding:6px; border-radius:6px; border:1px solid rgba(255,68,102,0.2);"><div class="ai-label" style="color:var(--accent-red);">ðŸ“‰ BEAR</div><div class="ai-prob" id="probBear" style="font-weight:bold; color:var(--accent-red);">50%</div></div></div><!-- Trading Signal Box (hidden by default) --><div id="tradingSignalBox" style="margin-bottom:6px; padding:6px; background:linear-gradient(135deg, rgba(0,255,136,0.05), rgba(0,212,255,0.05)); border-radius:6px; border:1px solid rgba(0,255,136,0.2); display:none;"><div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><span class="ai-label" id="signalDirection" style="font-weight:bold; color:var(--accent-green);">ðŸ“ˆ LONG</span><span class="ai-label" id="signalRR" style="color:var(--accent-cyan);">R:R 1:2</span></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:4px;"><div class="smc-value" style="background:rgba(0,0,0,0.3); padding:3px 5px; border-radius:4px;"><span style="color:var(--text-dim);">E:</span><span id="signalEntry" style="color:var(--accent-cyan); font-weight:bold;">$0.00</span></div><div class="smc-value" style="background:rgba(255,68,102,0.1); padding:3px 5px; border-radius:4px;"><span style="color:var(--text-dim);">SL:</span><span id="signalSL" style="color:var(--accent-red); font-weight:bold;">$0.00</span></div><div class="smc-value" style="background:rgba(0,255,136,0.1); padding:3px 5px; border-radius:4px;"><span style="color:var(--text-dim);">TP1:</span><span id="signalTP1" style="color:var(--accent-green); font-weight:bold;">$0.00</span></div><div class="smc-value" style="background:rgba(0,255,136,0.15); padding:3px 5px; border-radius:4px;"><span style="color:var(--text-dim);">TP2:</span><span id="signalTP2" style="color:var(--accent-green); font-weight:bold;">$0.00</span></div></div><div class="ai-label" style="margin-top:4px; display:flex; justify-content:space-between; color:var(--text-dim);"><span>Risk: <span id="signalRisk" style="color:var(--accent-red);">-0%</span></span><span>Reward: <span id="signalReward" style="color:var(--accent-green);">+0%</span></span><span>WR: <span id="signalWinRate" style="color:var(--accent-cyan);">--%</span></span></div></div><!-- AI Target Price --><div style="text-align:center; padding:6px; background:rgba(0,212,255,0.05); border-radius:6px; margin-bottom:6px; border:1px solid rgba(0,212,255,0.2);"><div class="ai-label" style="color:var(--text-dim);">AI TARGET</div><div class="ai-target-price" id="aiTarget" style="font-weight:bold; color:var(--accent-cyan);">$0.0000</div><div class="ai-conf" style="display:flex; justify-content:center; gap:12px;"><span>Conf: <span id="confLevel" style="color:var(--accent-green); font-weight:bold;">--%</span></span><span>Acc: <span id="modelAccuracy" style="font-weight:bold;">--%</span></span></div><div class="accuracy-bar" style="margin-top:5px; height:4px;"><div class="accuracy-fill" id="accuracyBar" style="width:0%"></div></div></div><!-- Smart Money Concepts --><div style="margin-bottom:6px; padding:5px 8px; background:rgba(255,149,0,0.05); border-radius:5px; border:1px solid rgba(255,149,0,0.15);"><div class="ai-label" style="color:var(--accent-orange); margin-bottom:4px;">ðŸ’° SMART MONEY</div><div style="display:grid; grid-template-columns:1fr 1fr; gap:3px;"><div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;"><span class="smc-label" style="color:var(--text-dim);">OB</span><span id="smcOB" style="color:var(--text-dim);">--</span></div><div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;"><span class="smc-label" style="color:var(--text-dim);">FVG</span><span id="smcFVG" style="color:var(--text-dim);">--</span></div><div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;"><span class="smc-label" style="color:var(--text-dim);">Liq</span><span id="smcLiq" style="color:var(--text-dim);">--</span></div><div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;"><span class="smc-label" style="color:var(--text-dim);">Struct</span><span id="smcStruct" style="color:var(--text-dim);">--</span></div></div></div><!-- Confluence & Noise & Whale --><div style="display:flex; justify-content:space-around; margin-bottom:6px; padding:5px; background:rgba(168,85,247,0.08); border-radius:5px;"><div style="text-align:center;"><div class="ai-label" style="color:var(--text-dim);">CONF</div><div class="conf-value" id="confluenceCount" style="font-weight:bold; color:var(--accent-purple);">0</div></div><div style="text-align:center;"><div class="ai-label" style="color:var(--text-dim);">NOISE</div><div class="conf-value" id="noiseLevel" style="font-weight:bold; color:var(--accent-orange);">--%</div></div><div style="text-align:center;"><div class="ai-label" style="color:var(--text-dim);">WHALE</div><div class="conf-value" id="whaleImpact" style="font-weight:bold; color:var(--accent-cyan);">0</div></div></div><!-- Prediction History --><div style="margin-bottom:5px;"><div class="accuracy-chart" id="accuracyHistoryChart" style="height:18px;"></div></div></div><!-- Score Meter --><div class="score-meter" style="height:8px;"><div class="score-fill" id="scoreFill" style="width:0; background:var(--accent-cyan);"></div></div><div class="ai-label" style="text-align:center; color:var(--text-dim); margin-bottom:5px;"><span style="float:left; margin-left:8px;">BEAR</span><span style="float:right; margin-right:8px;">BULL</span><span>NEUTRAL</span></div><!-- Tabs --><div class="tab-buttons" style="padding:3px;"><button class="tab-btn active" onclick="switchTab('momentum')" style="font-size:7px; padding:2px 5px;">MOM</button><button class="tab-btn" onclick="switchTab('trend')" style="font-size:7px; padding:2px 5px;">TREND</button><button class="tab-btn" onclick="switchTab('volume')" style="font-size:7px; padding:2px 5px;">VOL</button><button class="tab-btn" onclick="switchTab('advanced')" style="font-size:7px; padding:2px 5px; background:linear-gradient(135deg, rgba(255,0,255,0.1), rgba(0,255,255,0.1));">ADV</button></div><div class="scrollable" style="flex:1; min-height:80px;"><!-- TAB: Momentum --><div class="tab-content active" id="tab-momentum"><div class="indicator-row"><span class="indicator-label">RSI (14)</span><span class="indicator-value" id="rsiValue">--</span><span class="indicator-signal signal-neutral" id="rsiSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Stoch RSI</span><span class="indicator-value" id="stochValue">--</span><span class="indicator-signal signal-neutral" id="stochSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Williams %R</span><span class="indicator-value" id="willrValue">--</span><span class="indicator-signal signal-neutral" id="willrSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Momentum</span><span class="indicator-value" id="momValue">--</span><span class="indicator-signal signal-neutral" id="momSignal">--</span></div><div class="indicator-row"><span class="indicator-label">RSI Div</span><span class="indicator-value" id="divValue">--</span><span class="indicator-signal signal-neutral" id="divSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Squeeze</span><span class="indicator-value" id="squeezeValue">--</span><span class="indicator-signal signal-neutral" id="squeezeSignal">--</span></div></div><!-- TAB: Trend --><div class="tab-content" id="tab-trend"><div class="indicator-row"><span class="indicator-label">MACD</span><span class="indicator-value" id="macdValue">--</span><span class="indicator-signal signal-neutral" id="macdSignal">--</span></div><div class="indicator-row"><span class="indicator-label">EMA Cross</span><span class="indicator-value" id="emaValue">--</span><span class="indicator-signal signal-neutral" id="emaSignal">--</span></div><div class="indicator-row"><span class="indicator-label">ADX</span><span class="indicator-value" id="adxValue">--</span><span class="indicator-signal signal-neutral" id="adxSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Bollinger</span><span class="indicator-value" id="bbValue">--</span><span class="indicator-signal signal-neutral" id="bbSignal">--</span></div><div class="indicator-row"><span class="indicator-label">VWAP</span><span class="indicator-value" id="vwapValue">--</span><span class="indicator-signal signal-neutral" id="vwapSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Supertrend</span><span class="indicator-value" id="strendValue">--</span><span class="indicator-signal signal-neutral" id="strendSignal">--</span></div></div><!-- TAB: Volume --><div class="tab-content" id="tab-volume"><div class="indicator-row"><span class="indicator-label">OBV</span><span class="indicator-value" id="obvValue">--</span><span class="indicator-signal signal-neutral" id="obvSignal">--</span></div><div class="indicator-row"><span class="indicator-label">OB Imbal</span><span class="indicator-value" id="obValue">--</span><span class="indicator-signal signal-neutral" id="obSignal">--</span></div><div class="indicator-row"><span class="indicator-label">CVD</span><span class="indicator-value" id="cvdValue">--</span><span class="indicator-signal signal-neutral" id="cvdSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Chaikin</span><span class="indicator-value" id="cmfValue">--</span><span class="indicator-signal signal-neutral" id="cmfSignal">--</span></div><div class="indicator-row"><span class="indicator-label">Whale Flow</span><span class="indicator-value" id="whaleFlowValue">--</span><span class="indicator-signal signal-neutral" id="whaleFlowSignal">--</span></div></div><!-- TAB: Advanced --><div class="tab-content" id="tab-advanced"><div class="indicator-row"><span class="indicator-label">ðŸŒ Ichimoku</span><span class="indicator-value" id="ichiValue">--</span><span class="indicator-signal signal-neutral" id="ichiSignal">--</span></div><div class="indicator-row"><span class="indicator-label">ðŸ“ Fibo</span><span class="indicator-value" id="fiboValue">--</span><span class="indicator-signal signal-neutral" id="fiboSignal">--</span></div><div class="indicator-row"><span class="indicator-label">ðŸ“Š Vol Prof</span><span class="indicator-value" id="vpValue">--</span><span class="indicator-signal signal-neutral" id="vpSignal">--</span></div><div class="indicator-row"><span class="indicator-label">ðŸ“ˆ OFI</span><span class="indicator-value" id="ofiValue">--</span><span class="indicator-signal signal-neutral" id="ofiSignal">--</span></div><div class="indicator-row"><span class="indicator-label">ðŸ—ï¸ Struct</span><span class="indicator-value" id="structValue">--</span><span class="indicator-signal signal-neutral" id="structSignal">--</span></div><div class="indicator-row"><span class="indicator-label">ðŸ‹ Whale OB</span><span class="indicator-value" id="whaleOBValue">--</span><span class="indicator-signal signal-neutral" id="whaleOBSignal">--</span></div></div><!-- Patterns --><div style="padding:6px 8px; border-top:1px solid rgba(255,255,255,0.05);"><div class="ai-label" style="color:var(--text-dim); margin-bottom:3px;">ðŸ”® PATTERNS</div><div id="patternsContainer" style="display:flex; flex-wrap:wrap; gap:3px;"><span class="pattern-tag" style="color:var(--text-dim);">Analyzing...</span></div></div></div></div></div><!-- GRFICO CENTRAL --><div class="panel chart-box"><div class="panel-head"><span id="chartLabel">XRP/USDT  1m</span><span style="color:var(--accent-cyan)">TradingView</span><span style="float:right; font-size:9px; color:var(--text-dim);"><span style="color:rgba(0,255,136,0.6);">â—</span> Support
          <span style="color:rgba(255,68,102,0.6); margin-left:5px;">â—</span> Resistance
          <span style="color:var(--accent-yellow); margin-left:5px;">â—†</span> Fibonacci
        </span></div><div class="divergence-badge" id="divergenceBadge" style="display:none;"></div><div id="chartContainer"></div><!-- Fibonacci Levels Display --><div id="fiboLevels" style="padding:3px 10px; font-size:8px; background:rgba(0,0,0,0.3); border-top:1px solid rgba(255,255,255,0.05); overflow-x:auto; white-space:nowrap;"><span style="color:var(--accent-yellow)">ðŸ“ FIBO:</span><span style="color:var(--text-dim)">Calculating...</span></div><!-- AI NARRATOR removed - hidden elements for JS compatibility --><div style="display:none;"><span id="narratorTimestamp">--:--</span><div id="aiNarratorText"></div></div></div><!-- SIDEBAR DERECHA --><div class="side-right"><!-- ALERTS + SIGNALS en Tabs --><div class="panel" style="flex:1; display:flex; flex-direction:column;"><div class="panel-head" style="padding:4px 8px;"><div class="tab-buttons" style="padding:0; gap:2px;"><button class="tab-btn active" onclick="switchRightTab('alerts')" style="padding:2px 6px; font-size:8px;">ðŸ”” ALERTS <span id="alertCount" style="background:var(--accent-red); color:#fff; padding:0 3px; border-radius:6px; font-size:7px;">0</span></button><button class="tab-btn" onclick="switchRightTab('signals')" style="padding:2px 6px; font-size:8px;">ðŸ“¡ SIGNALS</button></div></div><div class="tab-content active scrollable" id="tab-alerts" style="flex:1;"><div id="alertsContainer"></div></div><div class="tab-content scrollable" id="tab-signals" style="flex:1;"><div id="signalHistoryList"><div style="text-align:center; color:var(--text-dim); padding:8px; font-size:9px;">Waiting for signals...</div></div></div></div><!-- ORDER BOOK --><div class="panel" style="flex:1; display:flex; flex-direction:column;"><div class="panel-head" style="padding:4px 8px;">ðŸ“Š ORDER BOOK <span id="spoofWarning" style="display:none; color:var(--accent-orange);"></span></div><div id="askSide" style="flex:1; overflow:hidden;"></div><div style="padding:3px; text-align:center; background:rgba(0,212,255,0.1);"><span id="midPrice" style="font-family:var(--font-data); font-size:13px; font-weight:bold;">--</span></div><div id="bidSide" style="flex:1; overflow:hidden;"></div><div id="wallDetection" style="padding:2px; font-size:7px;"></div></div><!-- WHALES / ETF --><div class="panel" style="flex:1; display:flex; flex-direction:column;"><div class="panel-head" style="padding:4px 8px;"><div class="tab-buttons" style="padding:0; gap:2px;"><button class="tab-btn active" onclick="switchWhaleTab('whales')" style="padding:3px 10px; font-size:9px;">ðŸ‹ WHALES <span id="whaleCount" style="background:var(--accent-purple); padding:0 4px; border-radius:6px; font-size:8px;">0</span></button><button class="tab-btn" onclick="switchWhaleTab('etf')" style="padding:3px 10px; font-size:9px;">ðŸ¦ ETF</button></div></div><div class="tab-content active scrollable" id="tab-whales" style="flex:1; padding:8px;"><div id="whaleList"><div style="padding:10px; text-align:center; color:var(--text-dim); font-size:9px;">Monitoring &gt;5K XRP...</div></div></div><div class="tab-content" id="tab-etf" style="flex:1; padding:15px; text-align:center;"><div style="margin-top:15px;"><div style="font-size:13px; color:var(--accent-cyan); margin-bottom:6px; font-weight:bold;">XRP ETF DATA</div><div style="font-size:10px; color:var(--text-dim);">7 Spot ETFs  774M+ XRP Locked</div></div><div style="margin-top:15px;"><a href="https://xrp-insights.com" style="background:var(--accent-green); color:#000; padding:8px 20px; border-radius:5px; font-size:11px; text-decoration:none; font-weight:bold; display:inline-block;" target="_blank">VIEW LIVE DATA </a></div></div></div></div><!-- BOTTOM --><div class="bottom-box"><div class="panel" id="aiEnginePanel" style="grid-column: span 1;"><!-- Hidden elements for SIGNAL CONSENSUS compatibility --><div style="display:none;"><span id="bullCount">0</span><span id="neutCount">0</span><span id="bearCount">0</span><span id="consensus">--</span></div><div class="panel-head" style="display:flex; justify-content:space-between; align-items:center; padding:6px 10px;"><div style="display:flex; align-items:center; gap:10px;"><span>ðŸ§  AI ENGINE PRO</span><span id="aiStatus" style="font-size:9px; padding:2px 8px; border-radius:10px; background:rgba(244,185,66,0.2); color:#f4b942;">INIT</span></div><span id="aiVersion" style="font-size:8px; color:var(--text-dim);">v--</span></div><div style="padding:10px; font-family:var(--font-data);"><div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; align-items:start;"><!-- Col 1: Prediction --><div id="aiPredictionBox" style="background:rgba(0,212,255,0.05); border-radius:6px; padding:10px; border-left:3px solid #94a3b8;"><div style="font-size:8px; color:var(--text-dim); margin-bottom:6px;">CURRENT SIGNAL</div><div id="aiDirection" style="font-size:18px; font-weight:bold; color:#94a3b8;">â³ ANALYZING</div><div id="aiConfidence" style="font-size:14px; color:#94a3b8; margin-top:4px;">--</div><div style="display:flex; gap:12px; margin-top:8px; font-size:9px;"><div><span style="color:var(--text-dim);">Regime:</span><br><span id="aiRegime" style="color:var(--accent-cyan);">--</span></div><div><span style="color:var(--text-dim);">Session:</span><br><span id="aiSession" style="color:var(--accent-cyan);">--</span></div></div></div><!-- Col 2: Stats + Verification --><div id="aiStatsCol" style="display:flex; flex-direction:column; gap:6px; min-width:0;"><div id="aiStatsGrid" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:4px; min-width:0;"><div style="background:rgba(0,255,136,0.1); padding:6px; border-radius:4px; text-align:center;"><div style="font-size:7px; color:var(--text-dim);">ACCURACY</div><div id="aiAccuracy" style="font-size:14px; font-weight:bold; color:#00ff88;">0.0%</div><div style="height:2px; background:rgba(255,255,255,0.1); border-radius:2px; margin-top:2px;"><div id="aiAccuracyBar" style="height:100%; width:0%; background:linear-gradient(90deg,#ff4466,#f4b942,#00ff88); border-radius:2px;"></div></div></div><div style="background:rgba(0,212,255,0.1); padding:6px; border-radius:4px; text-align:center;"><div style="font-size:7px; color:var(--text-dim);">SESSION</div><div id="aiSessionCount" style="font-size:14px; font-weight:bold; color:#00d4ff;">0</div></div><div style="background:rgba(168,85,247,0.15); padding:6px; border-radius:4px; text-align:center;"><div style="font-size:7px; color:var(--text-dim);">PENDING</div><div id="aiPending" style="font-size:14px; font-weight:bold; color:#a855f7;">0</div></div><div style="background:rgba(255,149,0,0.1); padding:6px; border-radius:4px; text-align:center;"><div style="font-size:7px; color:var(--text-dim);">COMPLETED</div><div id="aiCompleted" style="font-size:14px; font-weight:bold; color:#ff9500;">0</div></div><div style="background:rgba(255,68,102,0.1); padding:6px; border-radius:4px; text-align:center;"><div style="font-size:7px; color:var(--text-dim);">PATTERNS</div><div id="aiPatterns" style="font-size:14px; font-weight:bold; color:#ff4466;">0</div></div><div style="background:rgba(100,116,139,0.15); padding:6px; border-radius:4px; text-align:center;"><div style="font-size:7px; color:var(--text-dim);">UPTIME</div><div id="aiUptime" style="font-size:14px; font-weight:bold; color:#64748b;">0m</div></div></div><div id="aiLastVerifBox" style="padding:4px 6px; background:rgba(0,0,0,0.2); border-radius:4px; min-width:0;"><div style="font-size:7px; color:var(--text-dim); margin-bottom:2px;">LAST VERIFICATION</div><div id="aiLastVerif" style="font-size:9px; color:#64748b;">Waiting...</div></div></div><!-- Col 3: Horizons & Models --><div><div style="margin-bottom:10px;"><div style="font-size:8px; color:var(--text-dim); margin-bottom:4px;">BEST HORIZONS</div><div id="aiHorizonsGrid" style="display:flex; flex-wrap:wrap; gap:4px;"><span style="color:#64748b; font-size:9px;">Collecting...</span></div></div><div><div style="font-size:8px; color:var(--text-dim); margin-bottom:4px;">MODELS</div><div id="aiModelsGrid" style="display:grid; grid-template-columns:1fr 1fr; gap:2px; font-size:8px;"></div></div><div style="margin-top:8px; font-size:8px; color:var(--text-dim); text-align:right;"><span id="aiLastUpdate">--</span></div></div></div></div></div><div class="panel"><div class="panel-head">ðŸ’§ LIQUIDITY FLOW</div><div style="padding:10px;"><div style="display:flex; height:16px; border-radius:3px; overflow:hidden; margin-bottom:8px;"><div id="liqBarBid" style="background:var(--accent-green); height:100%; transition:width 0.3s;"></div><div id="liqBarAsk" style="background:var(--accent-red); height:100%; transition:width 0.3s;"></div></div><div id="liqText" style="font-size:10px; color:var(--text-dim); line-height:1.5;"></div><div id="cvdText" style="font-size:10px; color:var(--text-dim); margin-top:5px;"></div></div></div></div></main><script nonce="okrt-oraculum-nonce-2026" src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script><script nonce="okrt-oraculum-nonce-2026">
    // ============================================
    // SECURITY MODULE - Pentesting Ready
    // ============================================
    'use strict';
    
    const Security = {
      // HTML Entity Escape - Prevent XSS
      escapeHtml: (str) => {
        if (typeof str !== 'string') return str;
        const htmlEscapes = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;',
          '"': '&quot;', "'": '&#x27;', '/': '&#x2F;'
        };
        return str.replace(/[&<>"'/]/g, char => htmlEscapes[char]);
      },
      
      // Validate and sanitize number
      sanitizeNumber: (val, defaultVal = 0, min = -Infinity, max = Infinity) => {
        const num = parseFloat(val);
        if (isNaN(num) || !isFinite(num)) return defaultVal;
        return Math.max(min, Math.min(max, num));
      },
      
      // Safe JSON parse with prototype pollution protection
      safeJsonParse: (str, defaultVal = null) => {
        if (!str || typeof str !== 'string') return defaultVal;
        try {
          const parsed = JSON.parse(str);
          if (parsed && typeof parsed === 'object') {
            if ('__proto__' in parsed || 'constructor' in parsed || 'prototype' in parsed) {
              console.warn('[Security] Blocked prototype pollution attempt');
              return defaultVal;
            }
          }
          return parsed;
        } catch (e) {
          return defaultVal;
        }
      },
      
      // Validate WebSocket data
      validateWsData: (data) => {
        if (!data || typeof data !== 'object') return null;
        const forbidden = ['__proto__', 'constructor', 'prototype'];
        const jsonStr = JSON.stringify(data);
        for (const key of forbidden) {
          if (jsonStr.includes(key)) return null;
        }
        return data;
      },
      
      // Rate limiter
      rateLimiter: (() => {
        const calls = {};
        return (key, maxCalls = 10, windowMs = 1000) => {
          const now = Date.now();
          if (!calls[key]) calls[key] = [];
          calls[key] = calls[key].filter(t => now - t < windowMs);
          if (calls[key].length >= maxCalls) return false;
          calls[key].push(now);
          return true;
        };
      })(),
      
      // Validate URL domain
      isValidUrl: (url) => {
        const allowedDomains = [
          'binance.com', 'bybit.com', 'coinbase.com', 
          'kraken.com', 'bitstamp.net', 'crypto.com', 'alternative.me'
        ];
        try {
          const parsed = new URL(url);
          return allowedDomains.some(d => parsed.hostname.endsWith(d));
        } catch {
          return false;
        }
      },
      
      // Safe localStorage
      storage: {
        get: (key, defaultVal = null) => {
          try {
            const val = localStorage.getItem(key);
            return val !== null ? val : defaultVal;
          } catch (e) {
            return defaultVal;
          }
        },
        set: (key, val) => {
          try {
            localStorage.setItem(key, typeof val === 'object' ? JSON.stringify(val) : String(val));
            return true;
          } catch (e) {
            return false;
          }
        }
      }
    };
    
    Object.freeze(Security);
    Object.freeze(Security.storage);
    
    // ============================================
    // FREEZE PROTECTION MODULE v1.0
    // Prevents UI freezing from unhandled errors
    // ============================================
    const FreezeGuard = {
      intervals: new Map(),
      timeouts: new Map(),
      lastActivity: Date.now(),
      watchdogId: null,
      
      // Safe setInterval with error protection
      safeInterval: function(fn, delay, name = 'unnamed') {
        const wrapped = () => {
          try {
            this.lastActivity = Date.now();
            fn();
          } catch (e) {
            console.warn('[FreezeGuard] Interval error in ' + name + ':', e.message);
          }
        };
        const id = setInterval(wrapped, delay);
        this.intervals.set(id, { name, delay, fn: wrapped });
        return id;
      },
      
      // Safe setTimeout with error protection  
      safeTimeout: function(fn, delay, name = 'unnamed') {
        const wrapped = () => {
          try {
            this.lastActivity = Date.now();
            fn();
          } catch (e) {
            console.warn('[FreezeGuard] Timeout error in ' + name + ':', e.message);
          }
          this.timeouts.delete(id);
        };
        const id = setTimeout(wrapped, delay);
        this.timeouts.set(id, { name, delay });
        return id;
      },
      
      // Debounced ResizeObserver factory
      createResizeObserver: function(callback, delay = 100) {
        let timeout = null;
        return new ResizeObserver((entries) => {
          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(() => {
            try {
              callback(entries);
            } catch (e) {
              console.warn('[FreezeGuard] ResizeObserver error:', e.message);
            }
          }, delay);
        });
      },
      
      // Watchdog to detect freezes
      startWatchdog: function() {
        if (this.watchdogId) return;
        this.watchdogId = setInterval(() => {
          const now = Date.now();
          // If no activity for 30 seconds and we have pending work, something's wrong
          if (now - this.lastActivity > 30000 && this.intervals.size > 0) {
            console.warn('[FreezeGuard] Potential freeze detected, activity gap:', ((now - this.lastActivity)/1000).toFixed(0) + 's');
            this.lastActivity = now; // Reset to avoid spam
          }
        }, 10000);
      },
      
      // Clear all managed intervals
      clearAll: function() {
        this.intervals.forEach((_, id) => clearInterval(id));
        this.intervals.clear();
        this.timeouts.forEach((_, id) => clearTimeout(id));
        this.timeouts.clear();
      },
      
      // Get status
      status: function() {
        return {
          intervals: this.intervals.size,
          timeouts: this.timeouts.size,
          lastActivity: new Date(this.lastActivity).toLocaleTimeString()
        };
      }
    };
    
    // Start watchdog
    FreezeGuard.startWatchdog();
    
    // Expose globally
    window.FreezeGuard = FreezeGuard;
    
    // CSP Violation logging
    document.addEventListener('securitypolicyviolation', (e) => {
      console.error('[CSP Violation]', e.violatedDirective, e.blockedURI);
    });
    
    // Secure error handling
    window.addEventListener('error', (e) => {
      console.error('[Error]', e.message);
      e.preventDefault();
    });
    
    window.addEventListener('unhandledrejection', (e) => {
      console.error('[Promise Error]', e.reason?.message || 'Unknown');
      e.preventDefault();
    });
    
    // ============================================
    // FREEZE PROTECTION MODULE v1.0
    // Prevents UI freezing from runaway intervals
    // ============================================
    (function() {
      const _originalSetInterval = window.setInterval;
      const _originalClearInterval = window.clearInterval;
      const _activeIntervals = new Map();
      let _intervalCounter = 0;
      
      // Override setInterval with error protection
      window.setInterval = function(fn, delay, ...args) {
        const id = ++_intervalCounter;
        const wrappedFn = function() {
          try {
            if (typeof fn === 'function') {
              fn.apply(this, args);
            }
          } catch (e) {
            console.warn('[FreezeGuard] Interval error:', e.message);
          }
        };
        const realId = _originalSetInterval.call(window, wrappedFn, delay);
        _activeIntervals.set(realId, { delay, created: Date.now() });
        return realId;
      };
      
      // Override clearInterval
      window.clearInterval = function(id) {
        _activeIntervals.delete(id);
        return _originalClearInterval.call(window, id);
      };
      
      // Expose diagnostic function
      window._getActiveIntervals = function() {
        return { count: _activeIntervals.size, intervals: Array.from(_activeIntervals.entries()) };
      };
      
      console.log('[FreezeGuard] Interval protection enabled');
    })();
  </script><script nonce="okrt-oraculum-nonce-2026">
    // ============================================
    // XRP ORACULUM - OkrtSystem Labs
    // ============================================
    const CONFIG = {
      WHALE_THRESHOLD: 5000,       // 5K XRP (~$9K USD) para ver ms actividad
      WALL_THRESHOLD: 50000,       // 50K para paredes
      SPOOF_THRESHOLD: 200000,     // 200K para spoof detection
      HISTORY_SIZE: 100,
      ATR_PERIOD: 14,
      RSI_PERIOD: 14,
      MACD_FAST: 12,
      MACD_SLOW: 26,
      MACD_SIGNAL: 9,
      EMA_FAST: 9,
      EMA_SLOW: 21,
      STOCH_PERIOD: 14,
      BB_PERIOD: 20,
      BB_STD: 2,
      ADX_PERIOD: 14,
      WILLR_PERIOD: 14
    };

    // ============================================
    // FIREBASE CONFIGURATION
    // ============================================
    const FIREBASE_CONFIG = {
      // âš ï¸ REEMPLAZA CON TUS DATOS DE FIREBASE
      apiKey: "AIzaSyC_mWJcJMCrQv005hvYfHiUf7WDwgpD_nI",
      authDomain: "oraculum-ia.firebaseapp.com",
      projectId: "oraculum-ia",
      storageBucket: "oraculum-ia.firebasestorage.app",
      messagingSenderId: "965301309562",
      appId: "1:965301309562:web:9e81e2a57421454227abc3"
    };

    // ============================================
    // AI LEARNING SYSTEM v4.0
    // ============================================
    // ============================================
    // ðŸ”’ AI LEARNING ENGINE v4.0 - PROTECTED
    // Copyright (c) 2025-2026 OkrtSystem Labs
    // This code is obfuscated and protected
    // ============================================
function a0_0x34a4(){const _0x48c529=['\x6e\x63\x34\x57','\x44\x67\x76\x6e\x44\x75\x38','\x42\x30\x44\x76\x73\x4b\x34','\x44\x67\x39\x30\x79\x77\x58\x71\x43\x4d\x76\x4b\x41\x77\x6e\x30\x41\x77\x39\x55\x43\x57','\x43\x68\x6a\x50\x79\x32\x75','\x77\x30\x66\x6a\x78\x73\x62\x71\x43\x4d\x76\x4b\x69\x61','\x44\x4d\x76\x59\x41\x77\x7a\x50\x79\x32\x66\x30\x41\x77\x39\x55\x43\x57','\x77\x4b\x35\x64\x72\x30\x79','\x42\x77\x66\x57','\x6d\x5a\x75\x57\x72\x68\x7a\x55\x45\x4c\x66\x7a','\x41\x32\x76\x35\x43\x57','\x71\x4d\x48\x58\x72\x31\x65','\x7a\x67\x4c\x59\x7a\x77\x6e\x30\x41\x77\x39\x55','\x79\x4e\x76\x53\x42\x61','\x43\x32\x4c\x54','\x42\x32\x6e\x4a\x44\x78\x6a\x59\x7a\x77\x35\x4a\x7a\x78\x6d','\x74\x68\x7a\x34\x75\x66\x61','\x42\x67\x39\x4e','\x44\x4d\x4c\x6c\x79\x4b\x38','\x79\x32\x39\x54\x43\x67\x58\x4c\x44\x67\x76\x4b\x75\x68\x6a\x4c\x7a\x67\x4c\x4a\x44\x67\x4c\x56\x42\x4e\x6d','\x45\x4e\x48\x50\x75\x31\x69','\x44\x32\x76\x50\x7a\x32\x48\x30\x43\x57','\x41\x4d\x66\x67\x42\x30\x79','\x43\x32\x66\x54\x43\x67\x58\x4c\x43\x57','\x43\x32\x66\x32\x7a\x76\x72\x56\x74\x67\x39\x4a\x79\x77\x57','\x45\x65\x7a\x73\x42\x4b\x34','\x42\x77\x66\x34\x75\x67\x66\x30\x44\x67\x76\x59\x42\x4e\x6d','\x44\x67\x39\x74\x44\x68\x6a\x50\x42\x4d\x43','\x43\x32\x66\x32\x7a\x76\x72\x56\x71\x32\x58\x56\x44\x77\x71','\x74\x67\x4c\x73\x76\x30\x53','\x72\x77\x48\x77\x43\x65\x4f','\x76\x75\x39\x34\x44\x4d\x57','\x7a\x4d\x4c\x55\x7a\x61','\x45\x78\x76\x4a\x7a\x65\x79','\x43\x67\x66\x30\x44\x67\x76\x59\x42\x4e\x6d','\x79\x30\x54\x55\x44\x4b\x57','\x6d\x5a\x75\x33\x6d\x5a\x62\x71\x79\x32\x54\x69\x43\x4b\x65','\x44\x77\x4c\x4b','\x43\x32\x76\x30\x73\x78\x72\x4c\x42\x71','\x41\x68\x72\x30\x43\x68\x6d\x36\x6c\x59\x39\x33\x44\x33\x43\x55\x7a\x33\x6e\x30\x79\x78\x72\x50\x79\x59\x35\x4a\x42\x32\x30\x56\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x76\x51\x43\x59\x38\x58\x6d\x63\x34\x33\x6c\x4a\x65\x56\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x75\x54\x79\x78\x62\x57\x6c\x4d\x50\x5a','\x77\x30\x66\x6a\x78\x73\x62\x67\x41\x78\x6a\x4c\x79\x4d\x66\x5a\x7a\x73\x62\x55\x42\x33\x71\x47\x79\x32\x39\x55\x7a\x4d\x4c\x4e\x44\x78\x6a\x4c\x7a\x63\x61\x54\x69\x68\x76\x5a\x41\x77\x35\x4e\x69\x67\x58\x56\x79\x32\x66\x53\x75\x33\x72\x56\x43\x4d\x66\x4e\x7a\x71','\x42\x67\x66\x5a\x44\x66\x76\x57\x7a\x67\x66\x30\x7a\x77\x71','\x44\x78\x6e\x4c\x43\x47','\x79\x77\x6e\x4a\x44\x78\x6a\x48\x79\x33\x4b','\x42\x67\x76\x55\x7a\x33\x72\x4f','\x74\x76\x72\x35\x76\x33\x79','\x75\x32\x31\x65\x43\x68\x6d','\x42\x4d\x39\x59\x42\x75\x4c\x55\x7a\x61','\x6d\x5a\x6a\x64\x45\x4b\x35\x50\x77\x68\x47','\x79\x78\x76\x30\x41\x61','\x7a\x4d\x4c\x59\x7a\x78\x6e\x30\x42\x33\x6a\x4c','\x43\x4d\x76\x4e\x41\x77\x31\x4c','\x42\x33\x76\x30\x79\x32\x39\x54\x7a\x71','\x77\x4b\x4c\x72\x43\x65\x53','\x77\x4c\x44\x68\x42\x4d\x38','\x79\x78\x62\x50\x73\x32\x76\x35','\x77\x30\x66\x6a\x78\x73\x62\x67\x41\x78\x6a\x4c\x79\x4d\x66\x5a\x7a\x73\x62\x70\x73\x59\x57\x47\x44\x78\x6e\x4c\x43\x4a\x4f','\x44\x67\x4c\x54\x7a\x78\x6e\x30\x79\x77\x31\x57','\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x75','\x42\x4e\x76\x54\x79\x4d\x76\x59','\x73\x4d\x6a\x79\x41\x30\x71','\x73\x4b\x7a\x70\x79\x4c\x47','\x76\x67\x48\x76\x75\x32\x30','\x79\x77\x6a\x5a','\x44\x67\x66\x55\x41\x61','\x41\x68\x72\x30\x43\x68\x6d\x36\x6c\x59\x39\x33\x44\x33\x43\x55\x7a\x33\x6e\x30\x79\x78\x72\x50\x79\x59\x35\x4a\x42\x32\x30\x56\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x76\x51\x43\x59\x38\x58\x6d\x63\x34\x33\x6c\x4a\x65\x56\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x75\x54\x79\x78\x76\x30\x41\x63\x35\x51\x43\x57','\x71\x31\x4c\x53\x73\x4e\x43','\x42\x67\x39\x48\x7a\x65\x7a\x59\x42\x32\x31\x64\x42\x67\x39\x31\x7a\x61','\x41\x77\x35\x4a\x42\x68\x76\x4b\x7a\x78\x6d','\x73\x4d\x48\x6a\x7a\x4c\x79','\x71\x4b\x76\x62\x75\x47','\x77\x30\x66\x6a\x78\x73\x62\x71\x79\x78\x72\x30\x7a\x78\x6a\x55\x43\x59\x62\x53\x42\x32\x66\x4b\x7a\x77\x71\x36','\x43\x4d\x76\x4b\x44\x77\x6e\x4c','\x44\x67\x39\x67\x41\x78\x48\x4c\x7a\x61','\x7a\x78\x48\x50\x43\x33\x72\x5a','\x7a\x77\x4c\x79\x44\x31\x43','\x42\x4d\x39\x33','\x77\x4d\x66\x65\x74\x4e\x4b','\x43\x68\x76\x5a\x41\x61','\x6d\x5a\x61\x58\x6d\x74\x62\x65\x74\x76\x48\x4a\x72\x77\x75','\x69\x68\x57\x47\x71\x77\x6e\x4a\x6f\x49\x61','\x77\x75\x39\x76\x75\x4c\x39\x62\x75\x65\x4c\x46\x73\x30\x76\x7a','\x43\x33\x76\x49\x43\x32\x6e\x59\x41\x77\x6a\x4c\x76\x67\x39\x76\x43\x67\x72\x48\x44\x67\x76\x5a','\x44\x32\x76\x50\x7a\x32\x48\x30','\x74\x4e\x6a\x5a\x42\x77\x75','\x44\x4d\x76\x59\x41\x77\x7a\x35','\x7a\x78\x6a\x59\x42\x33\x69','\x71\x4b\x66\x58\x43\x30\x38','\x6d\x74\x61\x35\x6d\x64\x69\x35\x6e\x66\x72\x41\x76\x4d\x54\x34\x41\x57','\x43\x33\x72\x56\x43\x4d\x76\x71\x79\x78\x72\x30\x7a\x78\x6a\x55','\x7a\x32\x76\x30\x73\x78\x72\x4c\x42\x71','\x41\x32\x50\x36\x7a\x4b\x47','\x72\x68\x72\x31\x79\x4d\x53','\x7a\x77\x35\x30\x43\x4d\x4c\x4c\x43\x57','\x42\x78\x76\x53\x44\x67\x4c\x57\x42\x67\x4c\x4c\x43\x47','\x74\x33\x6e\x75\x41\x4d\x75','\x6d\x74\x4b\x30\x6e\x74\x75\x59\x6e\x4d\x7a\x66\x71\x4b\x31\x5a\x44\x57','\x73\x31\x72\x63\x45\x4c\x47','\x43\x67\x76\x55\x7a\x67\x4c\x55\x7a\x31\x62\x59\x7a\x77\x72\x50\x79\x33\x72\x50\x42\x32\x35\x5a','\x7a\x4d\x76\x70\x43\x67\x4b','\x79\x75\x50\x48\x43\x4c\x47','\x79\x77\x4c\x46\x44\x32\x76\x50\x7a\x32\x48\x30\x43\x57','\x79\x32\x48\x48\x42\x4d\x44\x4c','\x7a\x78\x6e\x54\x73\x65\x71','\x43\x33\x72\x59\x41\x77\x35\x4e\x41\x77\x7a\x35','\x44\x4c\x4c\x52\x72\x32\x34','\x43\x33\x72\x48\x44\x68\x6d','\x43\x32\x58\x50\x79\x32\x75','\x43\x32\x4c\x54\x41\x77\x58\x48\x43\x4d\x4c\x30\x45\x71','\x6d\x74\x65\x57\x6e\x74\x47\x5a\x6f\x74\x6a\x4c\x45\x4d\x7a\x4f\x7a\x68\x61','\x43\x4e\x48\x55\x42\x65\x4b','\x41\x77\x35\x4b\x41\x77\x6e\x48\x44\x67\x39\x59\x43\x57','\x43\x33\x76\x4a\x79\x32\x76\x5a\x43\x31\x6a\x48\x44\x67\x75','\x43\x4d\x76\x4e\x41\x77\x31\x4c\x43\x57','\x43\x32\x39\x59\x44\x61','\x42\x67\x39\x48\x7a\x65\x7a\x59\x42\x32\x31\x6d\x42\x32\x6e\x48\x42\x61','\x79\x32\x48\x35\x76\x68\x43','\x6d\x5a\x43\x5a\x6e\x64\x43\x35\x77\x75\x48\x6c\x75\x33\x4c\x4c','\x43\x68\x6a\x56\x79\x4d\x66\x49\x41\x77\x58\x50\x44\x68\x4b','\x6d\x74\x6d\x33\x6e\x5a\x4c\x4d\x42\x4b\x31\x4f\x72\x32\x75','\x45\x67\x58\x79\x44\x4b\x71','\x43\x67\x66\x59\x43\x32\x75','\x79\x32\x39\x59\x43\x4d\x76\x4a\x44\x66\x62\x59\x7a\x77\x72\x50\x79\x33\x72\x50\x42\x32\x35\x5a','\x74\x67\x48\x63\x74\x68\x4b','\x6e\x74\x61\x33\x6f\x74\x61\x31\x6d\x67\x58\x66\x72\x67\x4c\x4a\x74\x61','\x79\x77\x72\x51\x44\x78\x6e\x30\x76\x32\x76\x50\x7a\x32\x48\x30\x43\x57','\x76\x30\x48\x5a\x42\x33\x43','\x72\x68\x6a\x4d\x45\x65\x6d','\x75\x67\x72\x31\x44\x4b\x47','\x41\x78\x6e\x6a\x42\x4d\x4c\x30\x41\x77\x66\x53\x41\x78\x50\x4c\x7a\x61','\x43\x78\x48\x72\x74\x68\x6d','\x71\x75\x58\x66\x73\x65\x53','\x79\x4d\x76\x48\x43\x47','\x77\x30\x66\x6a\x78\x73\x62\x67\x41\x78\x6a\x4c\x79\x4d\x66\x5a\x7a\x73\x62\x4d\x79\x77\x4c\x53\x7a\x77\x71\x36','\x75\x4b\x7a\x6d\x75\x66\x69','\x71\x4c\x76\x6d\x74\x61','\x79\x77\x4c\x46\x43\x67\x66\x30\x44\x67\x76\x59\x42\x4e\x6d','\x7a\x4d\x4c\x53\x44\x67\x76\x59','\x41\x68\x72\x30\x43\x68\x6d\x36\x6c\x59\x39\x33\x44\x33\x43\x55\x7a\x33\x6e\x30\x79\x78\x72\x50\x79\x59\x35\x4a\x42\x32\x30\x56\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x76\x51\x43\x59\x38\x58\x6d\x63\x34\x33\x6c\x4a\x65\x56\x7a\x4d\x4c\x59\x7a\x77\x6a\x48\x43\x32\x75\x54\x7a\x4d\x4c\x59\x7a\x78\x6e\x30\x42\x33\x6a\x4c\x6c\x4d\x50\x5a','\x7a\x67\x66\x30\x79\x71','\x71\x4c\x76\x6c\x74\x33\x4b','\x76\x65\x72\x41\x74\x4d\x43','\x43\x33\x72\x59\x41\x77\x35\x4e'];a0_0x34a4=function(){return _0x48c529;};return a0_0x34a4();}const a0_0x1c10cc=a0_0x1a4b;function a0_0x1a4b(_0x9dd23a,_0x23b914){_0x9dd23a=_0x9dd23a-0x190;const _0x34a423=a0_0x34a4();let _0x1a4b37=_0x34a423[_0x9dd23a];if(a0_0x1a4b['\x4e\x51\x77\x4e\x54\x4c']===undefined){var _0x5b4e72=function(_0x1bbfc9){const _0x1a4202='\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x2b\x2f\x3d';let _0x3cf3d6='',_0x4a64d1='';for(let _0x26fa46=0x0,_0x379f13,_0x106369,_0x443124=0x0;_0x106369=_0x1bbfc9['\x63\x68\x61\x72\x41\x74'](_0x443124++);~_0x106369&&(_0x379f13=_0x26fa46%0x4?_0x379f13*0x40+_0x106369:_0x106369,_0x26fa46++%0x4)?_0x3cf3d6+=String['\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65'](0xff&_0x379f13>>(-0x2*_0x26fa46&0x6)):0x0){_0x106369=_0x1a4202['\x69\x6e\x64\x65\x78\x4f\x66'](_0x106369);}for(let _0x434d5c=0x0,_0x22e667=_0x3cf3d6['\x6c\x65\x6e\x67\x74\x68'];_0x434d5c<_0x22e667;_0x434d5c++){_0x4a64d1+='\x25'+('\x30\x30'+_0x3cf3d6['\x63\x68\x61\x72\x43\x6f\x64\x65\x41\x74'](_0x434d5c)['\x74\x6f\x53\x74\x72\x69\x6e\x67'](0x10))['\x73\x6c\x69\x63\x65'](-0x2);}return decodeURIComponent(_0x4a64d1);};a0_0x1a4b['\x4b\x44\x67\x72\x43\x77']=_0x5b4e72,a0_0x1a4b['\x63\x62\x6c\x45\x46\x63']={},a0_0x1a4b['\x4e\x51\x77\x4e\x54\x4c']=!![];}const _0x2cd8c4=_0x34a423[0x0],_0x361f8f=_0x9dd23a+_0x2cd8c4,_0x3fbe52=a0_0x1a4b['\x63\x62\x6c\x45\x46\x63'][_0x361f8f];return!_0x3fbe52?(_0x1a4b37=a0_0x1a4b['\x4b\x44\x67\x72\x43\x77'](_0x1a4b37),a0_0x1a4b['\x63\x62\x6c\x45\x46\x63'][_0x361f8f]=_0x1a4b37):_0x1a4b37=_0x3fbe52,_0x1a4b37;}(function(_0x1a6717,_0x2a0b2c){const _0x21c707=a0_0x1a4b,_0x31a752=_0x1a6717();while(!![]){try{const _0x5a653b=-parseInt(_0x21c707(0x211))/0x1+-parseInt(_0x21c707(0x219))/0x2+-parseInt(_0x21c707(0x19f))/0x3*(parseInt(_0x21c707(0x1e9))/0x4)+parseInt(_0x21c707(0x1a6))/0x5+-parseInt(_0x21c707(0x1dd))/0x6*(parseInt(_0x21c707(0x1c2))/0x7)+-parseInt(_0x21c707(0x197))/0x8+parseInt(_0x21c707(0x1a1))/0x9*(parseInt(_0x21c707(0x208))/0xa);if(_0x5a653b===_0x2a0b2c)break;else _0x31a752['push'](_0x31a752['shift']());}catch(_0x2e9582){_0x31a752['push'](_0x31a752['shift']());}}}(a0_0x34a4,0xd8749));const AILearning={'\x69\x73\x49\x6e\x69\x74\x69\x61\x6c\x69\x7a\x65\x64':![],'\x66\x69\x72\x65\x62\x61\x73\x65':null,'\x64\x62':null,'\x75\x73\x65\x72':null,'\x77\x65\x69\x67\x68\x74\x73':{'\x76\x65\x72\x73\x69\x6f\x6e':a0_0x1c10cc(0x1b9),'\x6c\x61\x73\x74\x55\x70\x64\x61\x74\x65\x64':Date[a0_0x1c10cc(0x205)](),'\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73':{'\x72\x73\x69':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x72\x73\x69\x5f\x64\x69\x76\x65\x72\x67\x65\x6e\x63\x65':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x6d\x61\x63\x64':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x65\x6d\x61\x5f\x63\x72\x6f\x73\x73':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x62\x6f\x6c\x6c\x69\x6e\x67\x65\x72':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x73\x74\x6f\x63\x68\x5f\x72\x73\x69':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x61\x64\x78':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x73\x75\x70\x65\x72\x74\x72\x65\x6e\x64':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x76\x6f\x6c\x75\x6d\x65':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x77\x68\x61\x6c\x65\x5f\x66\x6c\x6f\x77':{'\x77\x65\x69\x67\x68\x74':1.2,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x70\x61\x74\x74\x65\x72\x6e\x73':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x73\x75\x70\x70\x6f\x72\x74\x5f\x72\x65\x73\x69\x73\x74\x61\x6e\x63\x65':{'\x77\x65\x69\x67\x68\x74':0x1,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0}},'\x72\x65\x67\x69\x6d\x65\x73':{'\x74\x72\x65\x6e\x64\x69\x6e\x67\x5f\x75\x70':{'\x6d\x75\x6c\x74\x69\x70\x6c\x69\x65\x72':1.2,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x74\x72\x65\x6e\x64\x69\x6e\x67\x5f\x64\x6f\x77\x6e':{'\x6d\x75\x6c\x74\x69\x70\x6c\x69\x65\x72':1.2,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x72\x61\x6e\x67\x69\x6e\x67':{'\x6d\x75\x6c\x74\x69\x70\x6c\x69\x65\x72':0.8,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0},'\x76\x6f\x6c\x61\x74\x69\x6c\x65':{'\x6d\x75\x6c\x74\x69\x70\x6c\x69\x65\x72':0.6,'\x61\x63\x63\x75\x72\x61\x63\x79':0.5,'\x73\x61\x6d\x70\x6c\x65\x73':0x0}},'\x73\x74\x61\x74\x73':{'\x74\x6f\x74\x61\x6c\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73':0x0,'\x63\x6f\x72\x72\x65\x63\x74\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73':0x0,'\x61\x63\x63\x75\x72\x61\x63\x79':0x0}},'\x70\x61\x74\x74\x65\x72\x6e\x73':[],'\x6d\x61\x78\x50\x61\x74\x74\x65\x72\x6e\x73':0x1f4,'\x70\x65\x6e\x64\x69\x6e\x67\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73':[],'\x63\x6f\x6d\x70\x6c\x65\x74\x65\x64\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73':[],async '\x69\x6e\x69\x74'(){const _0x20d1bb=a0_0x1c10cc,_0x1306f2={'\x4d\x54\x79\x57\x76':_0x20d1bb(0x20a),'\x63\x54\x76\x46\x4f':function(_0x331612,_0x934d39){return _0x331612!==_0x934d39;},'\x79\x75\x63\x64\x46':_0x20d1bb(0x1f6),'\x76\x69\x4b\x62\x4f':_0x20d1bb(0x1e0),'\x5a\x57\x47\x6e\x6f':_0x20d1bb(0x1b4),'\x4b\x54\x42\x7a\x58':function(_0x206191,_0x79b2e4){return _0x206191(_0x79b2e4);},'\x4c\x76\x78\x50\x50':function(_0x1d2770,_0xb58934){return _0x1d2770(_0xb58934);},'\x43\x59\x6c\x4a\x77':function(_0x485bc3,_0x30e5a5,_0x64333b){return _0x485bc3(_0x30e5a5,_0x64333b);}};if(FIREBASE_CONFIG[_0x20d1bb(0x1f0)]===_0x1306f2[_0x20d1bb(0x1e6)]){if(_0x1306f2['\x63\x54\x76\x46\x4f'](_0x1306f2[_0x20d1bb(0x1da)],'\x4a\x46\x4f\x62\x58'))return this[_0x20d1bb(0x1ce)][_0x20d1bb(0x199)][_0xd15b96]?.[_0x20d1bb(0x20c)]||0x1;else{console[_0x20d1bb(0x1ca)](_0x20d1bb(0x1e1)),this['\x6c\x6f\x61\x64\x46\x72\x6f\x6d\x4c\x6f\x63\x61\x6c'](),this['\x69\x73\x49\x6e\x69\x74\x69\x61\x6c\x69\x7a\x65\x64']=!![];return;}}try{const {initializeApp:_0x24bada}=await import(_0x1306f2[_0x20d1bb(0x1cb)]),{getFirestore:_0x17a494,doc:_0x118c68,setDoc:_0x38afb9,getDoc:_0x2b3d70,onSnapshot:_0x353723}=await import(_0x1306f2[_0x20d1bb(0x1ef)]),{getAuth:_0x2d800e,signInAnonymously:_0x385ccd,onAuthStateChanged:_0x4f7633}=await import(_0x20d1bb(0x1fa));this[_0x20d1bb(0x1f3)]=_0x1306f2[_0x20d1bb(0x21a)](_0x24bada,FIREBASE_CONFIG),this['\x64\x62']=_0x1306f2[_0x20d1bb(0x1c9)](_0x17a494,this[_0x20d1bb(0x1f3)]),this['\x61\x75\x74\x68']=_0x2d800e(this[_0x20d1bb(0x1f3)]),this[_0x20d1bb(0x1eb)]={'\x64\x6f\x63':_0x118c68,'\x73\x65\x74\x44\x6f\x63':_0x38afb9,'\x67\x65\x74\x44\x6f\x63':_0x2b3d70,'\x6f\x6e\x53\x6e\x61\x70\x73\x68\x6f\x74':_0x353723},await _0x385ccd(this[_0x20d1bb(0x1ea)]),_0x1306f2[_0x20d1bb(0x1fb)](_0x4f7633,this['\x61\x75\x74\x68'],_0x2e48c8=>{const _0x5edbb6=_0x20d1bb;this[_0x5edbb6(0x1e3)]=_0x2e48c8,_0x2e48c8&&(console[_0x5edbb6(0x1ca)](_0x5edbb6(0x1f1),_0x2e48c8['\x75\x69\x64']['\x73\x6c\x69\x63\x65'](0x0,0x8)),this[_0x5edbb6(0x1fc)](),this['\x73\x75\x62\x73\x63\x72\x69\x62\x65\x54\x6f\x55\x70\x64\x61\x74\x65\x73']());}),this[_0x20d1bb(0x1ab)]=!![],this['\x73\x74\x61\x72\x74\x50\x65\x72\x69\x6f\x64\x69\x63\x53\x79\x6e\x63']();}catch(_0x2325b4){console[_0x20d1bb(0x20f)](_0x20d1bb(0x1af),_0x2325b4),this[_0x20d1bb(0x19d)](),this[_0x20d1bb(0x1ab)]=!![];}},async '\x6c\x6f\x61\x64\x46\x72\x6f\x6d\x43\x6c\x6f\x75\x64'(){const _0x3cd185=a0_0x1c10cc,_0x40f2fc={'\x5a\x49\x51\x70\x4b':function(_0x126e5b,_0x3a1948){return _0x126e5b(_0x3a1948);},'\x5a\x61\x44\x4e\x79':function(_0x281c84,_0x4573a0,_0x247738,_0x1a029a){return _0x281c84(_0x4573a0,_0x247738,_0x1a029a);},'\x52\x46\x4c\x50\x52':'\x77\x65\x69\x67\x68\x74\x73','\x4d\x46\x72\x59\x51':function(_0x435065,_0x53d8ac){return _0x435065>_0x53d8ac;},'\x6a\x61\x46\x6f\x46':function(_0x517502,_0x28facc){return _0x517502(_0x28facc);},'\x4c\x69\x52\x57\x4b':_0x3cd185(0x1db)};if(!this['\x64\x62'])return;try{const {doc:_0x5893ba,getDoc:_0x5b7754}=this[_0x3cd185(0x1eb)],_0x351cbc=await _0x40f2fc[_0x3cd185(0x1ee)](_0x5b7754,_0x40f2fc[_0x3cd185(0x206)](_0x5893ba,this['\x64\x62'],'\x61\x69',_0x40f2fc[_0x3cd185(0x1b0)]));if(_0x351cbc[_0x3cd185(0x203)]()){const _0xe3960e=_0x351cbc['\x64\x61\x74\x61']();_0x40f2fc['\x4d\x46\x72\x59\x51'](_0xe3960e['\x73\x74\x61\x74\x73']?.['\x74\x6f\x74\x61\x6c\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73'],this[_0x3cd185(0x1ce)][_0x3cd185(0x194)][_0x3cd185(0x1bc)])&&(this[_0x3cd185(0x1ce)]=_0xe3960e);}const _0x490a21=await _0x40f2fc[_0x3cd185(0x1cf)](_0x5b7754,_0x40f2fc['\x5a\x61\x44\x4e\x79'](_0x5893ba,this['\x64\x62'],'\x61\x69',_0x40f2fc[_0x3cd185(0x1d6)]));_0x490a21['\x65\x78\x69\x73\x74\x73']()&&_0x490a21[_0x3cd185(0x1b5)]()['\x70\x61\x74\x74\x65\x72\x6e\x73']&&(this[_0x3cd185(0x1db)]=_0x490a21[_0x3cd185(0x1b5)]()[_0x3cd185(0x1db)],console[_0x3cd185(0x1ca)](_0x3cd185(0x200),this['\x70\x61\x74\x74\x65\x72\x6e\x73']['\x6c\x65\x6e\x67\x74\x68']));}catch(_0x3551f7){}},'\x73\x75\x62\x73\x63\x72\x69\x62\x65\x54\x6f\x55\x70\x64\x61\x74\x65\x73'(){const _0x171b0f=a0_0x1c10cc,_0x35e245={'\x41\x4c\x45\x48\x4b':function(_0x2fd5a2,_0x37129a,_0xcd9df7){return _0x2fd5a2(_0x37129a,_0xcd9df7);},'\x4a\x68\x49\x66\x56':_0x171b0f(0x1ce)};if(!this['\x64\x62'])return;const {doc:_0x11da21,onSnapshot:_0x16aac5}=this['\x66\x69\x72\x65\x73\x74\x6f\x72\x65'];_0x35e245[_0x171b0f(0x1ad)](_0x16aac5,_0x11da21(this['\x64\x62'],'\x61\x69',_0x35e245[_0x171b0f(0x1fe)]),_0x59b6c1=>{const _0x2233a5=_0x171b0f;_0x59b6c1[_0x2233a5(0x203)]()&&_0x59b6c1[_0x2233a5(0x1b5)]()[_0x2233a5(0x1e2)]>this[_0x2233a5(0x1ce)][_0x2233a5(0x1e2)]&&this['\x6d\x65\x72\x67\x65\x57\x65\x69\x67\x68\x74\x73'](_0x59b6c1[_0x2233a5(0x1b5)]());});},'\x6d\x65\x72\x67\x65\x57\x65\x69\x67\x68\x74\x73'(_0x88216f){const _0xe316c4=a0_0x1c10cc,_0x341574={'\x42\x55\x4b\x4f\x79':function(_0x503507,_0x834c81){return _0x503507>_0x834c81;}};for(const [_0x133e09,_0x2cb515]of Object['\x65\x6e\x74\x72\x69\x65\x73'](_0x88216f[_0xe316c4(0x199)]||{})){this[_0xe316c4(0x1ce)][_0xe316c4(0x199)][_0x133e09]&&_0x341574[_0xe316c4(0x1b6)](_0x2cb515[_0xe316c4(0x1d0)],this[_0xe316c4(0x1ce)][_0xe316c4(0x199)][_0x133e09][_0xe316c4(0x1d0)])&&(this[_0xe316c4(0x1ce)][_0xe316c4(0x199)][_0x133e09]=_0x2cb515);}_0x88216f[_0xe316c4(0x194)]?.[_0xe316c4(0x1bc)]>this[_0xe316c4(0x1ce)][_0xe316c4(0x194)][_0xe316c4(0x1bc)]&&(this[_0xe316c4(0x1ce)]['\x73\x74\x61\x74\x73']=_0x88216f[_0xe316c4(0x194)]),this['\x73\x61\x76\x65\x54\x6f\x4c\x6f\x63\x61\x6c']();},async '\x73\x61\x76\x65\x54\x6f\x43\x6c\x6f\x75\x64'(){const _0x28f5b8=a0_0x1c10cc,_0x5757e3={'\x57\x48\x73\x6f\x77':function(_0x4530d4,_0x35a19c,_0x4313fe){return _0x4530d4(_0x35a19c,_0x4313fe);},'\x66\x65\x4f\x70\x69':function(_0xb89ec0,_0x232116,_0x131254,_0x51bd18){return _0xb89ec0(_0x232116,_0x131254,_0x51bd18);},'\x71\x78\x51\x4c\x73':_0x28f5b8(0x1db)};if(!this['\x64\x62']||!this[_0x28f5b8(0x1e3)])return;try{const {doc:_0x5c0c57,setDoc:_0x2911dc}=this[_0x28f5b8(0x1eb)];await _0x2911dc(_0x5c0c57(this['\x64\x62'],'\x61\x69',_0x28f5b8(0x1ce)),this[_0x28f5b8(0x1ce)]),await _0x5757e3[_0x28f5b8(0x1a8)](_0x2911dc,_0x5757e3[_0x28f5b8(0x21c)](_0x5c0c57,this['\x64\x62'],'\x61\x69',_0x5757e3[_0x28f5b8(0x1ac)]),{'\x70\x61\x74\x74\x65\x72\x6e\x73':this[_0x28f5b8(0x1db)][_0x28f5b8(0x195)](-this['\x6d\x61\x78\x50\x61\x74\x74\x65\x72\x6e\x73']),'\x75\x70\x64\x61\x74\x65\x64\x41\x74':new Date()['\x74\x6f\x49\x53\x4f\x53\x74\x72\x69\x6e\x67']()});}catch(_0x3e752e){}},'\x73\x61\x76\x65\x54\x6f\x4c\x6f\x63\x61\x6c'(){const _0x38fd43=a0_0x1c10cc,_0xfc55da={'\x61\x4a\x61\x72\x58':_0x38fd43(0x193),'\x78\x46\x52\x6e\x4e':_0x38fd43(0x21e),'\x54\x44\x5a\x4e\x67':_0x38fd43(0x1b2)};try{_0xfc55da[_0x38fd43(0x21d)]===_0x38fd43(0x193)?(localStorage[_0x38fd43(0x1df)](_0xfc55da[_0x38fd43(0x1d2)],JSON['\x73\x74\x72\x69\x6e\x67\x69\x66\x79'](this[_0x38fd43(0x1ce)])),localStorage[_0x38fd43(0x1df)](_0xfc55da[_0x38fd43(0x1b7)],JSON[_0x38fd43(0x192)](this[_0x38fd43(0x1db)][_0x38fd43(0x195)](-0x64)))):(this['\x70\x61\x74\x74\x65\x72\x6e\x73']=_0x52aa85[_0x38fd43(0x1b5)]()['\x70\x61\x74\x74\x65\x72\x6e\x73'],_0xed6125['\x6c\x6f\x67']('\x5b\x41\x49\x5d\x20\x50\x61\x74\x74\x65\x72\x6e\x73\x20\x6c\x6f\x61\x64\x65\x64\x3a',this[_0x38fd43(0x1db)]['\x6c\x65\x6e\x67\x74\x68']));}catch(_0x45120c){}},'\x6c\x6f\x61\x64\x46\x72\x6f\x6d\x4c\x6f\x63\x61\x6c'(){const _0x5aabd5=a0_0x1c10cc,_0x3648e5={'\x72\x78\x6e\x6c\x49':_0x5aabd5(0x1b2)};try{const _0x2bd769=localStorage['\x67\x65\x74\x49\x74\x65\x6d'](_0x5aabd5(0x21e));if(_0x2bd769)this[_0x5aabd5(0x1ce)]=JSON['\x70\x61\x72\x73\x65'](_0x2bd769);const _0x9f1ff8=localStorage[_0x5aabd5(0x213)](_0x3648e5[_0x5aabd5(0x198)]);if(_0x9f1ff8)this[_0x5aabd5(0x1db)]=JSON[_0x5aabd5(0x1a3)](_0x9f1ff8);}catch(_0x14ee81){}},'\x73\x74\x61\x72\x74\x50\x65\x72\x69\x6f\x64\x69\x63\x53\x79\x6e\x63'(){const _0x34499d=a0_0x1c10cc,_0x3bb379={'\x53\x6d\x44\x70\x73':function(_0x2fd0c3,_0x3b624a,_0x264e6c){return _0x2fd0c3(_0x3b624a,_0x264e6c);}};_0x3bb379[_0x34499d(0x1e7)](setInterval,()=>{const _0x41b5e3=_0x34499d;this[_0x41b5e3(0x1d5)](),this['\x73\x61\x76\x65\x54\x6f\x4c\x6f\x63\x61\x6c']();},0x493e0);},'\x67\x65\x74\x57\x65\x69\x67\x68\x74'(_0x13f562){const _0x466706=a0_0x1c10cc;return this['\x77\x65\x69\x67\x68\x74\x73']['\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73'][_0x13f562]?.[_0x466706(0x20c)]||0x1;},'\x67\x65\x74\x52\x65\x67\x69\x6d\x65\x4d\x75\x6c\x74\x69\x70\x6c\x69\x65\x72'(_0x178683){const _0x454bf5=a0_0x1c10cc;return this[_0x454bf5(0x1ce)]['\x72\x65\x67\x69\x6d\x65\x73'][_0x178683]?.[_0x454bf5(0x217)]||0x1;},'\x72\x65\x63\x6f\x72\x64\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e'(_0xc8d620){const _0x55c746=a0_0x1c10cc,_0x48f820={'\x69\x64':Date[_0x55c746(0x205)]()['\x74\x6f\x53\x74\x72\x69\x6e\x67'](0x24)+Math['\x72\x61\x6e\x64\x6f\x6d']()[_0x55c746(0x1d4)](0x24)[_0x55c746(0x195)](0x2,0x7),'\x74\x69\x6d\x65\x73\x74\x61\x6d\x70':Date[_0x55c746(0x205)](),'\x70\x72\x69\x63\x65':state[_0x55c746(0x1bd)],'\x64\x69\x72\x65\x63\x74\x69\x6f\x6e':_0xc8d620[_0x55c746(0x1c5)],'\x70\x72\x6f\x62\x61\x62\x69\x6c\x69\x74\x79':_0xc8d620[_0x55c746(0x1a0)],'\x72\x65\x67\x69\x6d\x65':_0xc8d620['\x72\x65\x67\x69\x6d\x65'],'\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73':_0xc8d620[_0x55c746(0x199)]||{},'\x6f\x75\x74\x63\x6f\x6d\x65':null,'\x76\x65\x72\x69\x66\x69\x63\x61\x74\x69\x6f\x6e\x73':[]};return this[_0x55c746(0x21b)][_0x55c746(0x207)](_0x48f820),[0x2,0x5,0xa]['\x66\x6f\x72\x45\x61\x63\x68'](_0x252c9d=>setTimeout(()=>this[_0x55c746(0x20e)](_0x48f820['\x69\x64'],_0x252c9d),_0x252c9d*0xea60)),_0x48f820['\x69\x64'];},'\x76\x65\x72\x69\x66\x79'(_0x8e7a18,_0x34bc48){const _0x1d75d0=a0_0x1c10cc,_0x5b908b={'\x65\x73\x6d\x48\x44':function(_0xddc235,_0x540dd0){return _0xddc235/_0x540dd0;},'\x78\x6c\x58\x76\x44':function(_0x47cae9,_0x103091){return _0x47cae9-_0x103091;},'\x6b\x6a\x7a\x66\x48':function(_0x3a6e61,_0x247052){return _0x3a6e61===_0x247052;},'\x4f\x73\x54\x6a\x65':function(_0x30461f,_0xb17f80){return _0x30461f>_0xb17f80;},'\x48\x75\x66\x46\x4b':function(_0x56ca46,_0x257d96){return _0x56ca46===_0x257d96;},'\x42\x68\x71\x47\x51':function(_0x2388ab,_0x2028a8){return _0x2388ab<_0x2028a8;}},_0x1fabe6=this['\x70\x65\x6e\x64\x69\x6e\x67\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73'][_0x1d75d0(0x1d9)](_0x58c556=>_0x58c556['\x69\x64']===_0x8e7a18);if(!_0x1fabe6||!state[_0x1d75d0(0x1bd)]||!_0x1fabe6[_0x1d75d0(0x1bd)])return;const _0x25099e=_0x5b908b[_0x1d75d0(0x191)](_0x5b908b[_0x1d75d0(0x1a2)](state[_0x1d75d0(0x1bd)],_0x1fabe6[_0x1d75d0(0x1bd)]),_0x1fabe6[_0x1d75d0(0x1bd)])*0x64,_0x26b287=_0x5b908b[_0x1d75d0(0x214)](_0x1fabe6[_0x1d75d0(0x1c5)],_0x1d75d0(0x1b1))&&_0x5b908b[_0x1d75d0(0x218)](_0x25099e,0.1)||_0x5b908b['\x48\x75\x66\x46\x4b'](_0x1fabe6[_0x1d75d0(0x1c5)],_0x1d75d0(0x1ff))&&_0x5b908b[_0x1d75d0(0x1c4)](_0x25099e,-0.1);_0x1fabe6[_0x1d75d0(0x1bf)][_0x1d75d0(0x207)]({'\x6d\x69\x6e\x73':_0x34bc48,'\x63\x68\x61\x6e\x67\x65':_0x25099e,'\x6f\x6b':_0x26b287});if(_0x34bc48===0xa)this['\x63\x6f\x6d\x70\x6c\x65\x74\x65'](_0x1fabe6);},'\x63\x6f\x6d\x70\x6c\x65\x74\x65'(_0x15e0df){const _0x39fdb8=a0_0x1c10cc,_0x570e21={'\x4e\x72\x73\x6d\x65':function(_0x3bff4b,_0x2f0550){return _0x3bff4b>=_0x2f0550;},'\x70\x50\x6a\x54\x6f':function(_0x14eafe,_0x23262b){return _0x14eafe*_0x23262b;},'\x44\x72\x66\x78\x43':function(_0x32b695,_0x3c5dfe){return _0x32b695+_0x3c5dfe;},'\x54\x68\x55\x53\x6d':function(_0x90cd1c,_0x1ac6eb){return _0x90cd1c+_0x1ac6eb;}},_0x5f171d=_0x15e0df[_0x39fdb8(0x1bf)][_0x39fdb8(0x1b3)](_0x23d805=>_0x23d805['\x6f\x6b'])['\x6c\x65\x6e\x67\x74\x68'],_0x2fc468=_0x570e21[_0x39fdb8(0x20d)](_0x5f171d,0x2);_0x15e0df[_0x39fdb8(0x1ed)]={'\x73\x75\x63\x63\x65\x73\x73':_0x2fc468,'\x70\x72\x69\x63\x65\x43\x68\x61\x6e\x67\x65':_0x15e0df[_0x39fdb8(0x1bf)][_0x39fdb8(0x201)]((_0x4b8798,_0x35b9f2)=>_0x4b8798+_0x35b9f2[_0x39fdb8(0x190)],0x0)/_0x15e0df[_0x39fdb8(0x1bf)][_0x39fdb8(0x1e5)],'\x63\x6f\x6d\x70\x6c\x65\x74\x65\x64\x41\x74':Date[_0x39fdb8(0x205)]()},this[_0x39fdb8(0x1a7)](_0x15e0df,_0x2fc468);if(_0x2fc468)this[_0x39fdb8(0x212)](_0x15e0df);this[_0x39fdb8(0x1cc)][_0x39fdb8(0x207)](_0x15e0df),this[_0x39fdb8(0x21b)]=this[_0x39fdb8(0x21b)][_0x39fdb8(0x1b3)](_0x5ef415=>_0x5ef415['\x69\x64']!==_0x15e0df['\x69\x64']),this['\x77\x65\x69\x67\x68\x74\x73']['\x73\x74\x61\x74\x73']['\x74\x6f\x74\x61\x6c\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73']++;if(_0x2fc468)this['\x77\x65\x69\x67\x68\x74\x73'][_0x39fdb8(0x194)][_0x39fdb8(0x1a4)]++;this[_0x39fdb8(0x1ce)][_0x39fdb8(0x194)][_0x39fdb8(0x1e4)]=_0x570e21['\x70\x50\x6a\x54\x6f'](this[_0x39fdb8(0x1ce)][_0x39fdb8(0x194)]['\x63\x6f\x72\x72\x65\x63\x74\x50\x72\x65\x64\x69\x63\x74\x69\x6f\x6e\x73']/this[_0x39fdb8(0x1ce)]['\x73\x74\x61\x74\x73'][_0x39fdb8(0x1bc)],0x64)[_0x39fdb8(0x202)](0x1),this[_0x39fdb8(0x1ce)][_0x39fdb8(0x1e2)]=Date[_0x39fdb8(0x205)](),this[_0x39fdb8(0x1d1)](),console[_0x39fdb8(0x1ca)](_0x570e21['\x44\x72\x66\x78\x43'](_0x570e21[_0x39fdb8(0x1a9)](_0x570e21[_0x39fdb8(0x1f7)](_0x39fdb8(0x1be)+_0x15e0df['\x69\x64']['\x73\x6c\x69\x63\x65'](0x0,0x6),'\x3a\x20'),_0x2fc468?'\u2713':'\u2717')+_0x39fdb8(0x209),this[_0x39fdb8(0x1ce)]['\x73\x74\x61\x74\x73']['\x61\x63\x63\x75\x72\x61\x63\x79'])+'\x25');},'\x61\x64\x6a\x75\x73\x74\x57\x65\x69\x67\x68\x74\x73'(_0x4fe2df,_0x5761d8){const _0x389711=a0_0x1c10cc,_0x4aef91={'\x6e\x71\x63\x42\x71':_0x389711(0x1f1),'\x4c\x68\x42\x4c\x79':function(_0x23b3d1,_0x450693){return _0x23b3d1*_0x450693;},'\x6e\x73\x4b\x6b\x77':function(_0x31d2ef,_0x5cbeb0){return _0x31d2ef-_0x5cbeb0;},'\x63\x68\x79\x54\x77':function(_0x35c5c4,_0xa8040d){return _0x35c5c4===_0xa8040d;},'\x55\x4f\x78\x76\x6c':function(_0x2145c7,_0x1cadcc){return _0x2145c7*_0x1cadcc;},'\x6f\x47\x55\x4a\x4e':function(_0x4d960e,_0xf5dc20){return _0x4d960e>=_0xf5dc20;},'\x4a\x62\x58\x6b\x44':function(_0x356c88,_0x1475d8){return _0x356c88+_0x1475d8;}},_0x15a3a5=0.05;for(const _0x19f870 of Object[_0x389711(0x1c3)](_0x4fe2df[_0x389711(0x199)])){if(_0x4aef91[_0x389711(0x19e)](_0x389711(0x1aa),'\x50\x64\x75\x76\x48')){if(this[_0x389711(0x1ce)]['\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73'][_0x19f870]){const _0x2c8013=this['\x77\x65\x69\x67\x68\x74\x73'][_0x389711(0x199)][_0x19f870];_0x2c8013[_0x389711(0x1d0)]++,_0x2c8013['\x61\x63\x63\x75\x72\x61\x63\x79']=_0x4aef91[_0x389711(0x1a5)](_0x2c8013[_0x389711(0x1e4)],0.95)+_0x4aef91[_0x389711(0x1a5)](_0x5761d8?0x1:0x0,0.05);if(_0x2c8013[_0x389711(0x1d0)]>=0xa){if(_0x4aef91[_0x389711(0x19e)](_0x389711(0x210),_0x389711(0x210))){if(_0x2c8013[_0x389711(0x1e4)]>0.6)_0x2c8013[_0x389711(0x20c)]=Math['\x6d\x69\x6e'](0x2,_0x2c8013[_0x389711(0x20c)]+_0x15a3a5);else{if(_0x2c8013[_0x389711(0x1e4)]<0.4)_0x2c8013[_0x389711(0x20c)]=Math['\x6d\x61\x78'](0.1,_0x2c8013[_0x389711(0x20c)]-_0x15a3a5);}}else this[_0x389711(0x1e3)]=_0x434d5c,_0x22e667&&(_0xfc6470[_0x389711(0x1ca)](_0x4aef91['\x6e\x71\x63\x42\x71'],_0x388175[_0x389711(0x1de)][_0x389711(0x195)](0x0,0x8)),this[_0x389711(0x1fc)](),this[_0x389711(0x20b)]());}}}else{const _0x35954c={'\x72\x65\x67\x69\x6d\x65':_0x64e9b9[_0x389711(0x1ec)],'\x64\x69\x72\x65\x63\x74\x69\x6f\x6e':_0xfcae66[_0x389711(0x1c5)],'\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73':this[_0x389711(0x1e8)](_0x147b74[_0x389711(0x199)]),'\x73\x75\x63\x63\x65\x73\x73\x52\x61\x74\x65':0x1,'\x6f\x63\x63\x75\x72\x72\x65\x6e\x63\x65\x73':0x1,'\x74\x69\x6d\x65\x73\x74\x61\x6d\x70':_0x167f57['\x6e\x6f\x77']()},_0x400297=this[_0x389711(0x1db)][_0x389711(0x1d9)](_0x108e94=>_0x108e94['\x72\x65\x67\x69\x6d\x65']===_0x35954c[_0x389711(0x1ec)]&&_0x108e94['\x64\x69\x72\x65\x63\x74\x69\x6f\x6e']===_0x35954c[_0x389711(0x1c5)]&&this[_0x389711(0x196)](_0x108e94[_0x389711(0x199)],_0x35954c['\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73'])>0.85);if(_0x400297)_0x400297[_0x389711(0x1c8)]++,_0x400297['\x73\x75\x63\x63\x65\x73\x73\x52\x61\x74\x65']=(_0x4aef91[_0x389711(0x1a5)](_0x400297[_0x389711(0x19a)],_0x4aef91['\x6e\x73\x4b\x6b\x77'](_0x400297[_0x389711(0x1c8)],0x1))+0x1)/_0x400297[_0x389711(0x1c8)],_0x400297[_0x389711(0x1f2)]=_0x2dff3a[_0x389711(0x205)]();else{this[_0x389711(0x1db)][_0x389711(0x207)](_0x35954c);if(this[_0x389711(0x1db)]['\x6c\x65\x6e\x67\x74\x68']>this[_0x389711(0x1d3)])this[_0x389711(0x1db)]=this['\x70\x61\x74\x74\x65\x72\x6e\x73'][_0x389711(0x195)](-this[_0x389711(0x1d3)]);}}}if(_0x4fe2df[_0x389711(0x1ec)]&&this['\x77\x65\x69\x67\x68\x74\x73'][_0x389711(0x19b)][_0x4fe2df[_0x389711(0x1ec)]]){const _0x1b6703=this[_0x389711(0x1ce)][_0x389711(0x19b)][_0x4fe2df['\x72\x65\x67\x69\x6d\x65']];_0x1b6703['\x73\x61\x6d\x70\x6c\x65\x73']++,_0x1b6703[_0x389711(0x1e4)]=_0x4aef91[_0x389711(0x1d8)](_0x1b6703['\x61\x63\x63\x75\x72\x61\x63\x79'],0.95)+_0x4aef91[_0x389711(0x1d8)](_0x5761d8?0x1:0x0,0.05);if(_0x4aef91[_0x389711(0x1bb)](_0x1b6703[_0x389711(0x1d0)],0xa))_0x1b6703['\x6d\x75\x6c\x74\x69\x70\x6c\x69\x65\x72']=_0x4aef91[_0x389711(0x1f5)](0.5,_0x1b6703[_0x389711(0x1e4)]);}},'\x73\x74\x6f\x72\x65\x50\x61\x74\x74\x65\x72\x6e'(_0xe9b540){const _0xbce1d0=a0_0x1c10cc,_0x242bed={'\x63\x4b\x6e\x76\x4c':function(_0xbf3d5e,_0x345a74){return _0xbf3d5e-_0x345a74;},'\x45\x68\x56\x70\x4a':function(_0x2d091c,_0x14b098){return _0x2d091c>_0x14b098;}},_0x527885={'\x72\x65\x67\x69\x6d\x65':_0xe9b540['\x72\x65\x67\x69\x6d\x65'],'\x64\x69\x72\x65\x63\x74\x69\x6f\x6e':_0xe9b540[_0xbce1d0(0x1c5)],'\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73':this[_0xbce1d0(0x1e8)](_0xe9b540['\x69\x6e\x64\x69\x63\x61\x74\x6f\x72\x73']),'\x73\x75\x63\x63\x65\x73\x73\x52\x61\x74\x65':0x1,'\x6f\x63\x63\x75\x72\x72\x65\x6e\x63\x65\x73':0x1,'\x74\x69\x6d\x65\x73\x74\x61\x6d\x70':Date['\x6e\x6f\x77']()},_0x40cd39=this['\x70\x61\x74\x74\x65\x72\x6e\x73']['\x66\x69\x6e\x64'](_0x5a5b1b=>_0x5a5b1b[_0xbce1d0(0x1ec)]===_0x527885[_0xbce1d0(0x1ec)]&&_0x5a5b1b[_0xbce1d0(0x1c5)]===_0x527885[_0xbce1d0(0x1c5)]&&this['\x73\x69\x6d\x69\x6c\x61\x72\x69\x74\x79'](_0x5a5b1b[_0xbce1d0(0x199)],_0x527885[_0xbce1d0(0x199)])>0.85);if(_0x40cd39)_0x40cd39[_0xbce1d0(0x1c8)]++,_0x40cd39[_0xbce1d0(0x19a)]=(_0x40cd39[_0xbce1d0(0x19a)]*_0x242bed[_0xbce1d0(0x1dc)](_0x40cd39['\x6f\x63\x63\x75\x72\x72\x65\x6e\x63\x65\x73'],0x1)+0x1)/_0x40cd39[_0xbce1d0(0x1c8)],_0x40cd39[_0xbce1d0(0x1f2)]=Date['\x6e\x6f\x77']();else{this[_0xbce1d0(0x1db)][_0xbce1d0(0x207)](_0x527885);if(_0x242bed[_0xbce1d0(0x1d7)](this[_0xbce1d0(0x1db)]['\x6c\x65\x6e\x67\x74\x68'],this[_0xbce1d0(0x1d3)]))this[_0xbce1d0(0x1db)]=this['\x70\x61\x74\x74\x65\x72\x6e\x73'][_0xbce1d0(0x195)](-this[_0xbce1d0(0x1d3)]);}},'\x6e\x6f\x72\x6d\x49\x6e\x64'(_0x32ca98){const _0x451e32=a0_0x1c10cc,_0x2ee37f={'\x44\x74\x75\x62\x6b':function(_0x89de18,_0x1e54bc){return _0x89de18===_0x1e54bc;},'\x74\x65\x4d\x75\x4f':'\x72\x73\x69','\x7a\x78\x69\x53\x52':function(_0x24f590,_0x2efc25){return _0x24f590===_0x2efc25;}},_0x2582e0={};for(const [_0x1b997d,_0x3190fc]of Object[_0x451e32(0x216)](_0x32ca98)){if(_0x2ee37f[_0x451e32(0x215)](typeof _0x3190fc,_0x451e32(0x1f4)))_0x2582e0[_0x1b997d]=_0x1b997d[_0x451e32(0x1fd)](_0x2ee37f[_0x451e32(0x1ba)])?_0x3190fc/0x64:Math[_0x451e32(0x1f9)](_0x3190fc);else{if(_0x2ee37f[_0x451e32(0x1cd)](typeof _0x3190fc,_0x451e32(0x1b8)))_0x2582e0[_0x1b997d]=_0x3190fc===_0x451e32(0x1c6)?0x1:_0x2ee37f[_0x451e32(0x215)](_0x3190fc,_0x451e32(0x1ae))?-0x1:0x0;}}return _0x2582e0;},'\x73\x69\x6d\x69\x6c\x61\x72\x69\x74\x79'(_0x4c2930,_0x348e52){const _0x51c4c1=a0_0x1c10cc,_0x1e9992={'\x5a\x4e\x43\x47\x46':function(_0x1c5b7c,_0x399774){return _0x1c5b7c/_0x399774;}},_0x34fdae=Object[_0x51c4c1(0x1c3)](_0x4c2930)[_0x51c4c1(0x1b3)](_0x3bd0d0=>_0x348e52[_0x3bd0d0]!==undefined);if(!_0x34fdae[_0x51c4c1(0x1e5)])return 0x0;return _0x1e9992[_0x51c4c1(0x1c0)](_0x34fdae['\x72\x65\x64\x75\x63\x65']((_0x5a0f48,_0x4dd745)=>_0x5a0f48+(0x1-Math[_0x51c4c1(0x1f8)](_0x4c2930[_0x4dd745]-_0x348e52[_0x4dd745])),0x0),_0x34fdae[_0x51c4c1(0x1e5)]);},'\x71\x75\x65\x72\x79\x50\x61\x74\x74\x65\x72\x6e\x73'(_0x337bde){const _0x4e4528=a0_0x1c10cc,_0x48e9e9={'\x65\x69\x58\x77\x57':function(_0x164492,_0x2947f8){return _0x164492*_0x2947f8;}},_0x5d4c62=this[_0x4e4528(0x1db)][_0x4e4528(0x1b3)](_0x2f19f5=>_0x2f19f5[_0x4e4528(0x1ec)]===_0x337bde[_0x4e4528(0x1ec)])[_0x4e4528(0x1c1)](_0x4fb42a=>({'\x70':_0x4fb42a,'\x73\x69\x6d':this[_0x4e4528(0x196)](_0x4fb42a[_0x4e4528(0x199)],_0x337bde[_0x4e4528(0x199)])}))[_0x4e4528(0x1b3)](_0x2dc706=>_0x2dc706[_0x4e4528(0x1c7)]>0.7)[_0x4e4528(0x19c)]((_0x5877f6,_0x2de83c)=>_0x2de83c[_0x4e4528(0x1c7)]*_0x2de83c['\x70'][_0x4e4528(0x19a)]-_0x5877f6[_0x4e4528(0x1c7)]*_0x5877f6['\x70'][_0x4e4528(0x19a)]);if(!_0x5d4c62['\x6c\x65\x6e\x67\x74\x68'])return{'\x66\x6f\x75\x6e\x64':![]};const _0x498ee2=_0x5d4c62[0x0];return{'\x66\x6f\x75\x6e\x64':!![],'\x63\x6f\x6e\x66\x69\x64\x65\x6e\x63\x65':_0x48e9e9[_0x4e4528(0x204)](_0x498ee2[_0x4e4528(0x1c7)],_0x498ee2['\x70'][_0x4e4528(0x19a)]),'\x64\x69\x72\x65\x63\x74\x69\x6f\x6e':_0x498ee2['\x70'][_0x4e4528(0x1c5)],'\x6f\x63\x63\x75\x72\x72\x65\x6e\x63\x65\x73':_0x498ee2['\x70']['\x6f\x63\x63\x75\x72\x72\x65\x6e\x63\x65\x73']};},'\x67\x65\x74\x53\x74\x61\x74\x73'(){const _0x3524c3=a0_0x1c10cc;return{'\x77\x65\x69\x67\x68\x74\x73':this[_0x3524c3(0x1ce)][_0x3524c3(0x194)],'\x70\x61\x74\x74\x65\x72\x6e\x73':this[_0x3524c3(0x1db)][_0x3524c3(0x1e5)],'\x70\x65\x6e\x64\x69\x6e\x67':this[_0x3524c3(0x21b)][_0x3524c3(0x1e5)]};}};
    // ============================================
    // PERFORMANCE MODULE - Firefox Optimization
    // ============================================
    const Performance = {
      // Throttle function - limita ejecucin
      throttle: (func, limit) => {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      },
      
      // Debounce function - espera antes de ejecutar
      debounce: (func, wait) => {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      },
      
      // Batch DOM updates usando requestAnimationFrame
      pendingUpdates: new Map(),
      scheduledFrame: false,
      
      batchUpdate: (key, updateFn) => {
        Performance.pendingUpdates.set(key, updateFn);
        if (!Performance.scheduledFrame) {
          Performance.scheduledFrame = true;
          requestAnimationFrame(() => {
            Performance.pendingUpdates.forEach(fn => fn());
            Performance.pendingUpdates.clear();
            Performance.scheduledFrame = false;
          });
        }
      },
      
      // WebSocket message counter para throttling
      wsMessageCount: 0,
      wsLastReset: Date.now(),
      maxWsMessagesPerSecond: 15,
      
      shouldProcessWsMessage: () => {
        const now = Date.now();
        if (now - Performance.wsLastReset > 1000) {
          Performance.wsMessageCount = 0;
          Performance.wsLastReset = now;
        }
        if (Performance.wsMessageCount < Performance.maxWsMessagesPerSecond) {
          Performance.wsMessageCount++;
          return true;
        }
        return false;
      },
      
      // Lite mode - reduce carga
      liteMode: false,
      
      toggleLiteMode: () => {
        Performance.liteMode = !Performance.liteMode;
        console.log('[Performance] Lite mode:', Performance.liteMode ? 'ON' : 'OFF');
        return Performance.liteMode;
      }
    };
    
    Object.freeze(Performance.throttle);
    Object.freeze(Performance.debounce);
    const state = {
      candles: [],
      currentPrice: 0,
      price: 0,  // Alias para compatibilidad
      btcPrice: 0,
      whaleCount: 0,
      cvd: 0,
      whaleBuyVol: 0,
      whaleSellVol: 0,
      predictions: [],
      alertCount: 0,
      lastOrderBook: { bids: [], asks: [] },
      obvHistory: [],
      priceHistory: [],
      rsiHistory: [],
      // Nuevas variables para funcionalidades
      soundEnabled: false,
      currentTimeframe: '1m',
      predictionHistory: [],  // Historial de aciertos/fallos
      exportData: []          // Datos para exportar
    };
    // Exponer estado global para mÃ³dulos externos (AI Engine PRO, feeds, etc.)
    // Mantiene compatibilidad con auto-prediction y evita valores undefined en window.state.*
    window.state = state;
    // --- AUDIO CONTEXT para alertas sonoras ---
    let audioCtx = null;
    
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    function playSound(type = 'alert') {
      if (!state.soundEnabled || !audioCtx) return;
      
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      if (type === 'bullish') {
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
        oscillator.frequency.setValueAtTime(1108, audioCtx.currentTime + 0.1); // C#6
      } else if (type === 'bearish') {
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4
        oscillator.frequency.setValueAtTime(330, audioCtx.currentTime + 0.1); // E4
      } else if (type === 'whale') {
        oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // A3 deep
        oscillator.type = 'sawtooth';
      } else {
        oscillator.frequency.setValueAtTime(660, audioCtx.currentTime); // E5
      }
      
      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.3);
    }
    // --- TOGGLE FUNCIONES ---
    function toggleSound() {
      initAudio();
      state.soundEnabled = !state.soundEnabled;
      const btn = document.getElementById('soundBtn');
      if (state.soundEnabled) {
        btn.innerHTML = 'ðŸ”Š ON';
        btn.classList.add('active');
        playSound('alert'); // Sonido de confirmacin
      } else {
        btn.innerHTML = 'ðŸ”‡ OFF';
        btn.classList.remove('active');
      }
    }
    // ============================================
    //  AI VOICE ALERTS SYSTEM
    // ============================================
    
    const voiceState = {
      enabled: false,
      speaking: false,
      lastSpoke: 0,
      cooldown: 60000, // 60 segundos entre alertas de voz (aumentado de 30s)
      voice: null,
      lang: localStorage.getItem('oraculum_voice_lang') || 'en',
      rate: 1.0,
      pitch: 1.0
    };
    
    // Traducciones para alertas de voz
    const voiceTranslations = {
      en: {
        activated: 'Voice alerts activated. I will announce high quality trading signals.',
        deactivated: 'Voice alerts deactivated.',
        attention: 'Attention!',
        bullish: 'Bullish',
        bearish: 'Bearish',
        signalDetected: 'signal detected.',
        probability: 'Probability',
        percent: 'percent.',
        signalQuality: 'Signal quality',
        marketIs: 'Market is',
        regimes: {
          'trending_up': 'trending upward',
          'trending_down': 'trending downward',
          'ranging': 'consolidating',
          'volatile': 'highly volatile',
          'unknown': 'analyzing'
        },
        divergence: {
          bullish: 'Bullish divergence detected on RSI. Potential reversal signal.',
          bearish: 'Bearish divergence detected on RSI. Potential reversal signal.'
        },
        whale: {
          alert: 'Whale alert!',
          largeBuy: 'Large buy order detected.',
          largeSell: 'Large sell order detected.',
          units: 'K units.'
        },
        session: {
          starting: 'session starting.',
          volatility: 'Expected volatility:'
        },
        langName: 'English',
        narrator: {
          analyzing: 'Analyzing market...',
          bullishSetup: 'Bullish accumulation detected.',
          bearishSetup: 'Bearish distribution detected.',
          whalesAccumulating: 'Whales accumulating,',
          whalesDistributing: 'Whales distributing,',
          rsiOversold: 'RSI exiting oversold',
          rsiOverbought: 'RSI exiting overbought',
          rsiNeutral: 'RSI neutral',
          strongBuyPressure: 'strong buy pressure.',
          strongSellPressure: 'strong sell pressure.',
          mixedSignals: 'mixed signals.',
          nextResistance: 'Resistance:',
          nextSupport: 'Support:',
          regimeIs: 'Regime:',
          probabilityAt: 'prob',
          confluence: 'confluences',
          noiseWarning: 'High noise - wait for clearer signals.',
          trendingUp: 'TREND UP',
          trendingDown: 'TREND DOWN',
          ranging: 'RANGING',
          volatile: 'VOLATILE',
          recommendation: 'Action:',
          wait: 'Wait',
          lookForLongs: 'Look for longs',
          lookForShorts: 'Look for shorts',
          holdPosition: 'Hold position'
        }
      },
      es: {
        activated: 'Alertas de voz activadas. Anunciar seales de trading de alta calidad.',
        deactivated: 'Alertas de voz desactivadas.',
        attention: 'Atencin!',
        bullish: 'Alcista',
        bearish: 'Bajista',
        signalDetected: 'seal detectada.',
        probability: 'Probabilidad',
        percent: 'por ciento.',
        signalQuality: 'Calidad de seal',
        marketIs: 'El mercado est',
        regimes: {
          'trending_up': 'en tendencia alcista',
          'trending_down': 'en tendencia bajista',
          'ranging': 'en consolidacin',
          'volatile': 'muy voltil',
          'unknown': 'analizando'
        },
        divergence: {
          bullish: 'Divergencia alcista detectada en RSI. Posible seal de reversin.',
          bearish: 'Divergencia bajista detectada en RSI. Posible seal de reversin.'
        },
        whale: {
          alert: 'Alerta de ballena!',
          largeBuy: 'Gran orden de compra detectada.',
          largeSell: 'Gran orden de venta detectada.',
          units: 'mil unidades.'
        },
        session: {
          starting: 'sesin iniciando.',
          volatility: 'Volatilidad esperada:'
        },
        langName: 'Espaol',
        narrator: {
          analyzing: 'Analizando mercado...',
          bullishSetup: 'Acumulacin alcista detectada.',
          bearishSetup: 'Distribucin bajista detectada.',
          whalesAccumulating: 'Ballenas acumulando,',
          whalesDistributing: 'Ballenas distribuyendo,',
          rsiOversold: 'RSI saliendo de sobreventa',
          rsiOverbought: 'RSI saliendo de sobrecompra',
          rsiNeutral: 'RSI neutral',
          strongBuyPressure: 'fuerte presin compradora.',
          strongSellPressure: 'fuerte presin vendedora.',
          mixedSignals: 'seales mixtas.',
          nextResistance: 'Resistencia:',
          nextSupport: 'Soporte:',
          regimeIs: 'Rgimen:',
          probabilityAt: 'prob',
          confluence: 'confluencias',
          noiseWarning: 'Alto ruido - esperar seales ms claras.',
          trendingUp: 'ALCISTA',
          trendingDown: 'BAJISTA',
          ranging: 'LATERAL',
          volatile: 'VOLTIL',
          recommendation: 'Accin:',
          wait: 'Esperar',
          lookForLongs: 'Buscar largos',
          lookForShorts: 'Buscar cortos',
          holdPosition: 'Mantener posicin'
        }
      }
    };
    
    // Obtener traduccin actual
    function t(key) {
      const keys = key.split('.');
      let value = voiceTranslations[voiceState.lang];
      for (const k of keys) {
        value = value?.[k];
      }
      return value || key;
    }
    
    // Inicializar voces disponibles
    function initVoices() {
      if ('speechSynthesis' in window) {
        const voices = speechSynthesis.getVoices();
        updateVoiceForLanguage(voices);
      }
    }
    
    function updateVoiceForLanguage(voices) {
      if (!voices || voices.length === 0) {
        voices = speechSynthesis.getVoices();
      }
      
      const langCode = voiceState.lang === 'es' ? 'es' : 'en';
      
      // Buscar mejor voz para el idioma
      voiceState.voice = voices.find(v => v.name.includes('Google') && v.lang.startsWith(langCode)) ||
                        voices.find(v => v.lang.startsWith(langCode)) ||
                        voices.find(v => v.lang.startsWith(langCode.toUpperCase())) ||
                        voices[0];
    }
    
    // Cargar voces cuando estn disponibles
    if ('speechSynthesis' in window) {
      speechSynthesis.onvoiceschanged = initVoices;
      initVoices();
    }
    
    // Cambiar idioma de voz
    function changeVoiceLanguage(lang) {
      voiceState.lang = lang;
      localStorage.setItem('oraculum_voice_lang', lang);
      
      // Actualizar voz para el nuevo idioma
      updateVoiceForLanguage();
      
      // Actualizar UI del selector
      const selector = document.getElementById('voiceLangSelect');
      if (selector) selector.value = lang;
      
      // Confirmar cambio con voz
      if (voiceState.enabled) {
        const confirmText = lang === 'es' ? 'Idioma cambiado a espaol.' : 'Language changed to English.';
        speakAlert(confirmText, 'high');
      }
    }
    
    // Funcin principal de voz
    function speakAlert(text, priority = 'normal') {
      if (!voiceState.enabled || !('speechSynthesis' in window)) return;
      if (voiceState.speaking) return;
      
      const now = Date.now();
      // Respetar cooldown excepto para alertas de alta prioridad
      if (priority !== 'high' && now - voiceState.lastSpoke < voiceState.cooldown) return;
      
      // Cancelar cualquier speech anterior
      speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.voice = voiceState.voice;
      utterance.lang = voiceState.lang === 'es' ? 'es-ES' : 'en-US';
      utterance.rate = voiceState.rate;
      utterance.pitch = voiceState.pitch;
      utterance.volume = 0.8;
      
      utterance.onstart = () => {
        voiceState.speaking = true;
        updateVoiceIndicator(true);
      };
      
      utterance.onend = () => {
        voiceState.speaking = false;
        voiceState.lastSpoke = Date.now();
        updateVoiceIndicator(false);
      };
      
      utterance.onerror = () => {
        voiceState.speaking = false;
        updateVoiceIndicator(false);
      };
      
      speechSynthesis.speak(utterance);
    }
    
    // Actualizar indicador visual de voz
    function updateVoiceIndicator(speaking) {
      const indicator = document.getElementById('voiceIndicator');
      if (indicator) {
        indicator.style.color = speaking ? 'var(--accent-cyan)' : 'var(--text-dim)';
        indicator.style.animation = speaking ? 'pulse 0.5s infinite' : 'none';
      }
    }
    
    // Toggle voz
    function toggleVoice() {
      voiceState.enabled = !voiceState.enabled;
      const btn = document.getElementById('voiceBtn');
      
      if (voiceState.enabled) {
        btn.innerHTML = 'ðŸŽ™ï¸ <span style="color:var(--accent-green)">ON</span>';
        btn.classList.add('active');
        speakAlert(t('activated'), 'high');
      } else {
        btn.innerHTML = 'ðŸŽ™ï¸ <span style="color:var(--text-dim)">OFF</span>';
        btn.classList.remove('active');
        speechSynthesis.cancel();
      }
    }
    
    //  Toggle Theme (Default / Neon)
    let currentTheme = localStorage.getItem('oraculum_theme') || 'default';
    
    function toggleTheme() {
      const btn = document.getElementById('themeBtn');
      
      if (currentTheme === 'default') {
        document.body.classList.add('neon-mode');
        document.body.classList.remove('light-mode');
        currentTheme = 'neon';
        btn.innerHTML = ' DEFAULT';
        btn.style.background = 'linear-gradient(135deg, rgba(0,255,255,0.3), rgba(255,0,255,0.3))';
        btn.style.borderColor = 'var(--accent-cyan)';
        btn.style.boxShadow = '0 0 10px rgba(0,255,255,0.3)';
      } else {
        document.body.classList.remove('neon-mode');
        document.body.classList.remove('light-mode');
        currentTheme = 'default';
        btn.innerHTML = 'ðŸŽ¨ NEON';
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.style.boxShadow = '';
      }
      
      localStorage.setItem('oraculum_theme', currentTheme);
    }
    
    // Aplicar tema guardado al cargar
    if (currentTheme === 'neon') {
      document.body.classList.add('neon-mode');
      setTimeout(() => {
        const btn = document.getElementById('themeBtn');
        if (btn) {
          btn.innerHTML = ' DEFAULT';
          btn.style.background = 'linear-gradient(135deg, rgba(0,255,255,0.3), rgba(255,0,255,0.3))';
          btn.style.borderColor = 'var(--accent-cyan)';
          btn.style.boxShadow = '0 0 10px rgba(0,255,255,0.3)';
        }
      }, 100);
    }
    
    // Generar texto para seales de trading
    function generateSignalVoiceText(direction, probability, quality, regime) {
      const dirText = direction === 'BULL' ? t('bullish') : t('bearish');
      const regimeText = t(`regimes.${regime}`) || regime;
      
      return `${t('attention')} ${dirText} ${t('signalDetected')} ` +
             `${t('probability')} ${Math.round(probability)} ${t('percent')} ` +
             `${t('signalQuality')} ${Math.round(quality)} ${t('percent')} ` +
             `${t('marketIs')} ${regimeText}.`;
    }
    
    // Generar comentario de mercado
    function generateMarketCommentary() {
      if (!voiceState.enabled || voiceState.speaking) return;
      
      const regime = aiState.marketRegime;
      const probBull = aiState.probabilityBull;
      const quality = aiState.signalQuality;
      const noise = aiState.noiseLevel;
      
      let commentary = '';
      
      if (noise > 60) {
        commentary = 'Market is noisy. Recommend waiting for clearer signals.';
      } else if (quality >= 70 && probBull >= 65) {
        commentary = `Bullish setup forming. ${Math.round(probBull)} percent probability with good signal quality.`;
      } else if (quality >= 70 && probBull <= 35) {
        commentary = `Bearish pressure detected. ${Math.round(100-probBull)} percent sell probability.`;
      } else if (regime === 'trending_up') {
        commentary = 'Uptrend in progress. Look for pullbacks to support.';
      } else if (regime === 'trending_down') {
        commentary = 'Downtrend active. Resistance levels are key.';
      } else if (regime === 'volatile') {
        commentary = 'High volatility detected. Trade with caution.';
      } else {
        commentary = 'Market consolidating. Waiting for breakout direction.';
      }
      
      return commentary;
    }
    
    // Alertas especiales por voz
    function voiceAlertWhale(side, amount, price) {
      if (!voiceState.enabled) return;
      const sideText = side === 'BUY' ? t('whale.largeBuy') : t('whale.largeSell');
      speakAlert(`${t('whale.alert')} ${sideText} ${Math.round(amount/1000)} ${t('whale.units')}`);
    }
    
    function voiceAlertDivergence(type) {
      if (!voiceState.enabled) return;
      const divergenceKey = type.toLowerCase();
      speakAlert(t(`divergence.${divergenceKey}`), 'high');
    }
    
    function voiceAlertSession(session) {
      if (!voiceState.enabled) return;
      speakAlert(`${session.name} ${t('session.starting')} ${t('session.volatility')} ${session.volatility}.`);
    }
    // ============================================
    //  PAPER TRADING SIMULATOR
    // ============================================
    
    const paperTrading = {
      enabled: true,
      balance: parseFloat(localStorage.getItem('pt_balance')) || 10000,
      startingBalance: 10000,
      position: JSON.parse(localStorage.getItem('pt_position')) || null,
      history: JSON.parse(localStorage.getItem('pt_history')) || [],
      stats: JSON.parse(localStorage.getItem('pt_stats')) || { wins: 0, losses: 0, totalPnL: 0 }
    };
    
    function savePaperTradingState() {
      localStorage.setItem('pt_balance', paperTrading.balance.toString());
      localStorage.setItem('pt_position', JSON.stringify(paperTrading.position));
      localStorage.setItem('pt_history', JSON.stringify(paperTrading.history.slice(-50)));
      localStorage.setItem('pt_stats', JSON.stringify(paperTrading.stats));
    }
    
    function openPaperTrade(type) {
      if (paperTrading.position) {
        addAlert(' Already have open position', 'warning');
        return;
      }
      const amount = parseFloat(document.getElementById('ptAmount')?.value) || 0;
      if (amount <= 0) { addAlert(' Enter amount', 'warning'); return; }
      const cost = amount * state.currentPrice;
      if (cost > paperTrading.balance) { addAlert(' Insufficient balance', 'warning'); return; }
      
      paperTrading.position = { type, amount, entryPrice: state.currentPrice, timestamp: Date.now() };
      paperTrading.balance -= cost;
      savePaperTradingState();
      updatePaperTradingUI();
      addAlert(` ${type.toUpperCase()} ${amount} XRP @ $${state.currentPrice.toFixed(4)}`, type === 'long' ? 'bullish' : 'bearish');
    }
    
    function closePaperTrade() {
      if (!paperTrading.position) { addAlert(' No position', 'warning'); return; }
      const pos = paperTrading.position;
      const currentValue = pos.amount * state.currentPrice;
      const entryValue = pos.amount * pos.entryPrice;
      const pnl = pos.type === 'long' ? currentValue - entryValue : entryValue - currentValue;
      
      paperTrading.balance += entryValue + pnl;
      paperTrading.history.unshift({ ...pos, exitPrice: state.currentPrice, pnl, timestamp: Date.now() });
      if (pnl > 0) paperTrading.stats.wins++; else paperTrading.stats.losses++;
      paperTrading.stats.totalPnL += pnl;
      paperTrading.position = null;
      savePaperTradingState();
      updatePaperTradingUI();
      addAlert(` Closed: ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`, pnl >= 0 ? 'bullish' : 'bearish');
    }
    
    function resetPaperTrading() {
      if (confirm('Reset Paper Trading?')) {
        paperTrading.balance = 10000;
        paperTrading.position = null;
        paperTrading.history = [];
        paperTrading.stats = { wins: 0, losses: 0, totalPnL: 0 };
        savePaperTradingState();
        updatePaperTradingUI();
      }
    }
    
    function updatePaperTradingUI() {
      const balanceEl = document.getElementById('ptBalance');
      if (balanceEl) balanceEl.innerText = paperTrading.balance >= 1000 ? '$' + (paperTrading.balance/1000).toFixed(1) + 'K' : '$' + paperTrading.balance.toFixed(0);
      
      const totalPnL = paperTrading.balance - paperTrading.startingBalance;
      const pnlEl = document.getElementById('ptPnL');
      if (pnlEl) {
        pnlEl.innerText = (totalPnL >= 0 ? '+$' : '-$') + Math.abs(totalPnL).toFixed(0);
        pnlEl.style.color = totalPnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
      }
      
      const winRateEl = document.getElementById('ptWinRate');
      if (winRateEl) {
        const total = paperTrading.stats.wins + paperTrading.stats.losses;
        const wr = total > 0 ? (paperTrading.stats.wins / total * 100).toFixed(0) : 0;
        winRateEl.innerText = wr + '%';
        winRateEl.style.color = wr >= 50 ? 'var(--accent-green)' : 'var(--accent-red)';
      }
      
      const tradesEl = document.getElementById('ptTrades');
      if (tradesEl) tradesEl.innerText = paperTrading.stats.wins + paperTrading.stats.losses;
      
      const positionEl = document.getElementById('ptPosition');
      if (positionEl) {
        if (paperTrading.position) {
          const pos = paperTrading.position;
          const pnl = pos.type === 'long' ? (state.currentPrice - pos.entryPrice) * pos.amount : (pos.entryPrice - state.currentPrice) * pos.amount;
          const pnlPct = ((pnl / (pos.amount * pos.entryPrice)) * 100).toFixed(1);
          positionEl.innerHTML = `<span>${pos.type === 'long' ? '' : ''} ${pos.amount} @ $${pos.entryPrice.toFixed(4)}</span><span style="color:${pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}; float:right;">${pnl >= 0 ? '+' : ''}${pnlPct}%</span>`;
        } else {
          positionEl.innerHTML = '<span style="color:var(--text-dim);">No position</span>';
        }
      }
      
      const buyBtn = document.getElementById('ptBuyBtn'), sellBtn = document.getElementById('ptSellBtn'), closeBtn = document.getElementById('ptCloseBtn');
      if (buyBtn && sellBtn && closeBtn) {
        if (paperTrading.position) {
          buyBtn.style.display = 'none'; sellBtn.style.display = 'none'; closeBtn.style.display = 'block';
        } else {
          buyBtn.style.display = 'block'; sellBtn.style.display = 'block'; closeBtn.style.display = 'none';
        }
      }
    }
    // ============================================
    //  AI MARKET NARRATOR
    // ============================================
    
    let lastNarrativeUpdate = 0;
    
    function generateNarrative() {
      const lang = voiceState.lang;
      const nt = (key) => voiceTranslations[lang]?.narrator?.[key] || key;
      const regime = aiState.marketRegime;
      const probBull = aiState.probabilityBull;
      const quality = aiState.signalQuality;
      const noise = aiState.noiseLevel;
      const rsi = state.rsiHistory?.[state.rsiHistory.length - 1] || 50;
      const whaleFlow = (state.whaleBuyVol || 0) - (state.whaleSellVol || 0);
      
      let parts = [];
      
      if (noise > 60) return nt('noiseWarning');
      
      // Regime
      const regimeText = { 'trending_up': nt('trendingUp'), 'trending_down': nt('trendingDown'), 'ranging': nt('ranging'), 'volatile': nt('volatile') };
      parts.push(`${nt('regimeIs')} ${regimeText[regime] || regime} (${Math.round(probBull > 50 ? probBull : 100-probBull)}% ${nt('probabilityAt')}).`);
      
      // RSI
      if (rsi < 35) parts.push(nt('rsiOversold'));
      else if (rsi > 65) parts.push(nt('rsiOverbought'));
      
      // Whales
      if (whaleFlow > 50000) parts.push(nt('whalesAccumulating') + ' ' + nt('strongBuyPressure'));
      else if (whaleFlow < -50000) parts.push(nt('whalesDistributing') + ' ' + nt('strongSellPressure'));
      
      // Recommendation
      parts.push(nt('recommendation'));
      if (quality < 50 || noise > 45) parts.push(nt('wait'));
      else if (probBull >= 65) parts.push(nt('lookForLongs'));
      else if (probBull <= 35) parts.push(nt('lookForShorts'));
      else parts.push(nt('wait'));
      
      return parts.join(' ');
    }
    
    function updateNarratorUI() {
      const now = Date.now();
      if (now - lastNarrativeUpdate < 15000) return;
      lastNarrativeUpdate = now;
      
      const el = document.getElementById('aiNarratorText');
      if (el) {
        el.style.opacity = '0.5';
        setTimeout(() => { el.innerText = generateNarrative(); el.style.opacity = '1'; }, 150);
      }
      const ts = document.getElementById('narratorTimestamp');
      if (ts) ts.innerText = new Date().toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit'});
    }
    
    function speakNarrative() {
      if (!voiceState.enabled) { addAlert(' Enable voice first', 'warning'); return; }
      speakAlert(generateNarrative(), 'high');
    }
    // Tab switching for right sidebar
    function switchRightTab(tabName) {
      const container = event.target.closest('.panel');
      container.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      container.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      container.querySelector('#tab-' + tabName).classList.add('active');
    }
    
    function toggleTheme() {
      document.body.classList.toggle('light-mode');
      const btn = document.getElementById('themeBtn');
      if (document.body.classList.contains('light-mode')) {
        btn.innerHTML = '';
      } else {
        btn.innerHTML = '';
      }
    }
    // --- TIMEFRAME CHANGE ---
    function changeTimeframe(tf) {
      state.currentTimeframe = tf;
      state.candles = [];
      state.priceHistory = [];
      state.rsiHistory = [];
      state.obvHistory = [];
      
      // Reconectar WebSocket con nuevo timeframe
      if (ws) ws.close();
      fetchHistoricalData();
      connectAPI();
      
      addAlert(`Timeframe changed to ${tf}`, 'info');
    }
    // --- EXPORT DATA TO CSV ---
    function exportData() {
      if (state.candles.length === 0) {
        alert('No data to export yet!');
        return;
      }
      
      // Preparar datos
      let csv = 'Timestamp,Open,High,Low,Close,Volume,RSI,Prediction,Actual,Correct\\n';
      
      state.predictions.forEach((pred, idx) => {
        const candle = state.candles[idx] || {};
        const correct = pred.correct !== undefined ? (pred.correct ? 'YES' : 'NO') : 'PENDING';
        csv += `${new Date(pred.timestamp).toISOString()},`;
        csv += `${candle.open || ''},${candle.high || ''},${candle.low || ''},${candle.close || ''},${candle.volume || ''},`;
        csv += `${pred.rsi || ''},${pred.target.toFixed(6)},${pred.actual.toFixed(6)},${correct}\\n`;
      });
      
      // Crear y descargar archivo
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `XRP_ORACULUM_${state.currentTimeframe}_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      addAlert('Data exported to CSV', 'info');
    }
    // --- UPDATE PREDICTION HISTORY CHART ---
    function updatePredictionHistoryChart() {
      const container = document.getElementById('accuracyHistoryChart');
      if (!container) return;
      
      container.innerHTML = '';
      
      // Mostrar ltimas 20 predicciones
      const history = state.predictionHistory.slice(-20);
      
      if (history.length === 0) {
        // Mostrar cuntas predicciones faltan para empezar
        const needed = Math.max(0, 10 - state.predictions.length);
        const current = state.predictions.length;
        
        if (current === 0) {
          container.innerHTML = '<span class="ai-label" style="color:var(--text-dim);"> Waiting for data...</span>';
        } else if (needed > 0) {
          container.innerHTML = `<span class="ai-label" style="color:var(--text-dim);"> ${current}/10 samples (${needed} more needed)</span>`;
        } else {
          container.innerHTML = '<span class="ai-label" style="color:var(--text-dim);"> Processing predictions...</span>';
        }
        return;
      }
      
      // Calcular estadsticas
      const correct = history.filter(r => r).length;
      const accuracy = ((correct / history.length) * 100).toFixed(0);
      
      // Crear contenedor flex para barras + stats
      const wrapper = document.createElement('div');
      wrapper.style.cssText = 'display:flex; align-items:center; gap:8px; width:100%;';
      
      // Contenedor de barras
      const barsContainer = document.createElement('div');
      barsContainer.style.cssText = 'display:flex; gap:2px; flex:1; height:100%;';
      
      history.forEach((result, idx) => {
        const bar = document.createElement('div');
        bar.className = 'accuracy-bar-mini';
        bar.style.cssText = `flex:1; height:100%; border-radius:2px; background:${result ? 'var(--accent-green)' : 'var(--accent-red)'}; opacity:${0.3 + (idx / history.length) * 0.7};`;
        bar.title = result ? ' Correct' : ' Incorrect';
        barsContainer.appendChild(bar);
      });
      
      wrapper.appendChild(barsContainer);
      
      // Mini stats
      const stats = document.createElement('span');
      stats.className = 'ai-label';
      stats.style.cssText = `color:${accuracy >= 55 ? 'var(--accent-green)' : accuracy >= 45 ? 'var(--accent-orange)' : 'var(--accent-red)'}; white-space:nowrap;`;
      stats.innerText = `${accuracy}%`;
      wrapper.appendChild(stats);
      
      container.appendChild(wrapper);
    }
    // --- UI REFS ---
    const ui = {
      statusPill: document.getElementById('statusPill'),
      statusText: document.getElementById('apiStatusText'),
      clock: document.getElementById('clock'),
      price: document.getElementById('priceDisplay'),
      priceChange: document.getElementById('priceChange'),
      volume: document.getElementById('volDisplay'),
      fg: document.getElementById('fgIndex'),
      fgLabel: document.getElementById('fgLabel'),
      fundingRate: document.getElementById('fundingRate'),
      fundingLabel: document.getElementById('fundingLabel'),
      openInterest: document.getElementById('openInterest'),
      oiChange: document.getElementById('oiChange'),
      totalScore: document.getElementById('totalScore'),
      scoreLabel: document.getElementById('scoreLabel'),
      aiTarget: document.getElementById('aiTarget'),
      conf: document.getElementById('confLevel'),
      modelAccuracy: document.getElementById('modelAccuracy'),
      accuracyBar: document.getElementById('accuracyBar'),
      accuracyPct: document.getElementById('accuracyPct'),
      scoreFill: document.getElementById('scoreFill'),
      bids: document.getElementById('bidSide'),
      asks: document.getElementById('askSide'),
      midPrice: document.getElementById('midPrice'),
      wallDetection: document.getElementById('wallDetection'),
      spoofWarning: document.getElementById('spoofWarning'),
      liqBarBid: document.getElementById('liqBarBid'),
      liqBarAsk: document.getElementById('liqBarAsk'),
      liqText: document.getElementById('liqText'),
      cvdText: document.getElementById('cvdText'),
      whaleList: document.getElementById('whaleList'),
      whaleCount: document.getElementById('whaleCount'),
      bullCount: document.getElementById('bullCount'),
      neutCount: document.getElementById('neutCount'),
      bearCount: document.getElementById('bearCount'),
      consensus: document.getElementById('consensus'),
      alertsContainer: document.getElementById('alertsContainer'),
      alertCount: document.getElementById('alertCount'),
      btcPrice: document.getElementById('btcPrice'),
      divergenceBadge: document.getElementById('divergenceBadge'),
      patternsContainer: document.getElementById('patternsContainer'),
      // AI Engine v2 elements
      marketRegime: document.getElementById('marketRegime'),
      signalQuality: document.getElementById('signalQuality'),
      probBull: document.getElementById('probBull'),
      probBear: document.getElementById('probBear'),
      confluenceCount: document.getElementById('confluenceCount'),
      noiseLevel: document.getElementById('noiseLevel')
    };
    // --- TAB SWITCH ---
    function switchTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      document.getElementById('tab-' + tabName).classList.add('active');
    }
    function switchWhaleTab(tabName) {
      const container = event.target.closest('.panel');
      container.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      container.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      container.querySelector('#tab-' + tabName).classList.add('active');
    }
    // --- CHART ---
    let chart, candleSeries, trendLineUp, trendLineDown, ema9Series, ema21Series;
    let supportLines = [], resistanceLines = [], fiboLines = [];
    function initChart() {
      const container = document.getElementById('chartContainer');
      chart = LightweightCharts.createChart(container, {
        width: container.clientWidth,
        height: container.clientHeight,
        layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#94a3b8' },
        grid: { vertLines: { color: 'rgba(255,255,255,0.03)' }, horzLines: { color: 'rgba(255,255,255,0.03)' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { 
          borderColor: 'rgba(255,255,255,0.1)', 
          scaleMargins: { top: 0.05, bottom: 0.05 },
          autoScale: true
        },
        timeScale: { 
          borderColor: 'rgba(255,255,255,0.1)', 
          timeVisible: true,
          rightOffset: 5,
          barSpacing: 10,
          minBarSpacing: 5
        },
        localization: {
          timeFormatter: (timestamp) => {
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          }
        }
      });
      candleSeries = chart.addCandlestickSeries({
        upColor: '#00ff88', downColor: '#ff4466',
        borderUpColor: '#00ff88', borderDownColor: '#ff4466',
        wickUpColor: '#00ff88', wickDownColor: '#ff4466'
      });
      // EMA 9 - Rpida (Cyan)
      ema9Series = chart.addLineSeries({
        color: '#00d4ff',
        lineWidth: 1,
        crosshairMarkerVisible: false,
        lastValueVisible: true,
        priceLineVisible: false,
        title: 'EMA 9',
      });
      // EMA 21 - Lenta (Prpura)
      ema21Series = chart.addLineSeries({
        color: '#a855f7',
        lineWidth: 1,
        crosshairMarkerVisible: false,
        lastValueVisible: true,
        priceLineVisible: false,
        title: 'EMA 21',
      });
      // Lnea de tendencia alcista (soporte)
      trendLineUp = chart.addLineSeries({
        color: '#00ff88',
        lineWidth: 2,
        lineStyle: 0, // Solid
        crosshairMarkerVisible: false,
        lastValueVisible: false,
        priceLineVisible: false,
        autoscaleInfoProvider: () => null,
      });
      // Lnea de tendencia bajista (resistencia)
      trendLineDown = chart.addLineSeries({
        color: '#ff4466',
        lineWidth: 2,
        lineStyle: 0, // Solid
        crosshairMarkerVisible: false,
        lastValueVisible: false,
        priceLineVisible: false,
        autoscaleInfoProvider: () => null,
      });
      // Crear series para S/R levels (3 soportes + 3 resistencias)
      // autoscaleInfoProvider: () => null evita que estas lneas expandan el rango del grfico
      for (let i = 0; i < 3; i++) {
        supportLines.push(chart.addLineSeries({
          color: 'rgba(0, 255, 136, 0.6)',
          lineWidth: 1,
          lineStyle: 2, // Dashed
          crosshairMarkerVisible: false,
          lastValueVisible: true,
          priceLineVisible: false,
          title: `S${i+1}`,
          autoscaleInfoProvider: () => null,
        }));
        resistanceLines.push(chart.addLineSeries({
          color: 'rgba(255, 68, 102, 0.6)',
          lineWidth: 1,
          lineStyle: 2, // Dashed
          crosshairMarkerVisible: false,
          lastValueVisible: true,
          priceLineVisible: false,
          title: `R${i+1}`,
          autoscaleInfoProvider: () => null,
        }));
      }
      // Crear series para Fibonacci (5 niveles: 0.236, 0.382, 0.5, 0.618, 0.786)
      const fiboColors = ['#f4b942', '#f4b942', '#00d4ff', '#f4b942', '#f4b942'];
      const fiboWidths = [1, 1, 2, 1, 1];
      for (let i = 0; i < 5; i++) {
        fiboLines.push(chart.addLineSeries({
          color: fiboColors[i],
          lineWidth: fiboWidths[i],
          lineStyle: 1, // Dotted
          crosshairMarkerVisible: false,
          lastValueVisible: true,
          priceLineVisible: false,
          autoscaleInfoProvider: () => null,
        }));
      }
      // Debounced resize to prevent excessive redraws
      let resizeTimeout = null;
      new ResizeObserver(() => {
        if (resizeTimeout) clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          try {
            chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
          } catch(e) {}
        }, 150);
      }).observe(container);
    }
    // ============================================
    // EMA CALCULATION FOR CHART
    // ============================================
    function calculateEMAData(candles, period) {
      if (candles.length < period) return [];
      
      const emaData = [];
      const k = 2 / (period + 1);
      
      // Calcular SMA inicial
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += candles[i].close;
      }
      let ema = sum / period;
      
      emaData.push({ time: candles[period - 1].time, value: ema });
      
      // Calcular EMA para el resto
      for (let i = period; i < candles.length; i++) {
        ema = candles[i].close * k + ema * (1 - k);
        emaData.push({ time: candles[i].time, value: ema });
      }
      
      return emaData;
    }
    function updateEMAs() {
      if (!state.candles || state.candles.length < 21) return;
      
      try {
        const ema9Data = calculateEMAData(state.candles, 9);
        const ema21Data = calculateEMAData(state.candles, 21);
        
        if (ema9Series && ema9Data.length > 0) {
          ema9Series.setData(ema9Data);
        }
        if (ema21Series && ema21Data.length > 0) {
          ema21Series.setData(ema21Data);
        }
      } catch (e) {
        console.error('EMA update error:', e);
      }
    }
    // ============================================
    // AUTO TREND LINES (Professional Algorithm)
    // ============================================
    // Encontrar pivotes/swings significativos
    function findPivotPoints(candles, strength = 2) {
      if (candles.length < strength * 2 + 1) return { pivotHighs: [], pivotLows: [] };
      
      const pivotHighs = [];
      const pivotLows = [];
      const recentCandles = candles.slice(-50); // Solo ltimas 50 velas
      
      for (let i = strength; i < recentCandles.length - strength; i++) {
        let isPivotHigh = true;
        let isPivotLow = true;
        
        for (let j = 1; j <= strength; j++) {
          if (recentCandles[i].high < recentCandles[i - j].high || 
              recentCandles[i].high < recentCandles[i + j].high) {
            isPivotHigh = false;
          }
          if (recentCandles[i].low > recentCandles[i - j].low || 
              recentCandles[i].low > recentCandles[i + j].low) {
            isPivotLow = false;
          }
        }
        
        if (isPivotHigh) {
          pivotHighs.push({ 
            time: recentCandles[i].time, 
            value: recentCandles[i].high,
            index: candles.length - recentCandles.length + i
          });
        }
        if (isPivotLow) {
          pivotLows.push({ 
            time: recentCandles[i].time, 
            value: recentCandles[i].low,
            index: candles.length - recentCandles.length + i
          });
        }
      }
      
      return { pivotHighs, pivotLows };
    }
    // Encontrar la mejor lnea de tendencia usando los 2 puntos ms significativos
    function findBestTrendLine(pivots, isSupport = true) {
      if (pivots.length < 2) return null;
      
      // Tomar los ltimos 4-5 pivotes
      const recentPivots = pivots.slice(-5);
      if (recentPivots.length < 2) return null;
      
      let bestLine = null;
      let bestScore = -Infinity;
      
      // Probar combinaciones de 2 puntos
      for (let i = 0; i < recentPivots.length - 1; i++) {
        for (let j = i + 1; j < recentPivots.length; j++) {
          const p1 = recentPivots[i];
          const p2 = recentPivots[j];
          
          const timeDiff = p2.time - p1.time;
          if (timeDiff <= 0) continue;
          
          const slope = (p2.value - p1.value) / timeDiff;
          
          // Para soporte: preferir pendiente positiva o neutral
          // Para resistencia: preferir pendiente negativa o neutral
          let score = 0;
          
          if (isSupport) {
            // Soporte: contar cuntos puntos estn por encima de la lnea
            score = slope >= 0 ? 1 : 0;
            for (const p of recentPivots) {
              const expectedValue = p1.value + slope * (p.time - p1.time);
              if (p.value >= expectedValue * 0.998) score += 1;
            }
          } else {
            // Resistencia: contar cuntos puntos estn por debajo de la lnea
            score = slope <= 0 ? 1 : 0;
            for (const p of recentPivots) {
              const expectedValue = p1.value + slope * (p.time - p1.time);
              if (p.value <= expectedValue * 1.002) score += 1;
            }
          }
          
          // Preferir lneas ms recientes
          score += (j - i) * 0.5;
          
          if (score > bestScore) {
            bestScore = score;
            bestLine = { p1, p2, slope };
          }
        }
      }
      
      return bestLine;
    }
    function updateTrendLines() {
      if (!state.candles || state.candles.length < 20) {
        if (trendLineUp) trendLineUp.setData([]);
        if (trendLineDown) trendLineDown.setData([]);
        return;
      }
      
      const { pivotHighs, pivotLows } = findPivotPoints(state.candles, 2);
      
      // Lnea de soporte (conectando mnimos)
      if (pivotLows.length >= 2 && trendLineUp) {
        const supportTrend = findBestTrendLine(pivotLows, true);
        if (supportTrend) {
          const { p1, p2, slope } = supportTrend;
          
          // Extender ligeramente hacia el futuro (3 velas)
          const lastCandle = state.candles[state.candles.length - 1];
          const candleInterval = state.candles.length > 1 ? 
            (lastCandle.time - state.candles[state.candles.length - 2].time) : 60;
          const futureTime = lastCandle.time + candleInterval * 3;
          const futureValue = p1.value + slope * (futureTime - p1.time);
          
          try {
            trendLineUp.setData([
              { time: p1.time, value: p1.value },
              { time: p2.time, value: p2.value },
              { time: futureTime, value: futureValue }
            ]);
          } catch (e) {}
        }
      } else if (trendLineUp) {
        trendLineUp.setData([]);
      }
      
      // Lnea de resistencia (conectando mximos)
      if (pivotHighs.length >= 2 && trendLineDown) {
        const resistanceTrend = findBestTrendLine(pivotHighs, false);
        if (resistanceTrend) {
          const { p1, p2, slope } = resistanceTrend;
          
          // Extender ligeramente hacia el futuro (3 velas)
          const lastCandle = state.candles[state.candles.length - 1];
          const candleInterval = state.candles.length > 1 ? 
            (lastCandle.time - state.candles[state.candles.length - 2].time) : 60;
          const futureTime = lastCandle.time + candleInterval * 3;
          const futureValue = p1.value + slope * (futureTime - p1.time);
          
          try {
            trendLineDown.setData([
              { time: p1.time, value: p1.value },
              { time: p2.time, value: p2.value },
              { time: futureTime, value: futureValue }
            ]);
          } catch (e) {}
        }
      } else if (trendLineDown) {
        trendLineDown.setData([]);
      }
    }
    // ============================================
    // S/R LEVELS ON CHART
    // ============================================
    
    function updateSROnChart() {
      if (!state.candles || state.candles.length < 30) return;
      if (!supportLines || supportLines.length === 0) return;
      
      const supports = aiState.supportLevels || [];
      const resistances = aiState.resistanceLevels || [];
      
      const startTime = state.candles[0].time;
      const endTime = state.candles[state.candles.length - 1].time;
      
      // Dibujar soportes
      supports.slice(0, 3).forEach((s, i) => {
        if (supportLines[i]) {
          try {
            supportLines[i].setData([
              { time: startTime, value: s.price },
              { time: endTime, value: s.price }
            ]);
          } catch (e) {}
        }
      });
      
      // Limpiar lneas no usadas
      for (let i = supports.length; i < 3; i++) {
        if (supportLines[i]) supportLines[i].setData([]);
      }
      
      // Dibujar resistencias
      resistances.slice(0, 3).forEach((r, i) => {
        if (resistanceLines[i]) {
          try {
            resistanceLines[i].setData([
              { time: startTime, value: r.price },
              { time: endTime, value: r.price }
            ]);
          } catch (e) {}
        }
      });
      
      // Limpiar lneas no usadas
      for (let i = resistances.length; i < 3; i++) {
        if (resistanceLines[i]) resistanceLines[i].setData([]);
      }
    }
    // ============================================
    // FIBONACCI RETRACEMENT
    // ============================================
    
    function updateFibonacciLevels() {
      if (!state.candles || state.candles.length < 30) return;
      if (!fiboLines || fiboLines.length === 0) return;
      
      // Encontrar swing high y swing low en los ltimos 50 candles
      const recentCandles = state.candles.slice(-50);
      const swingHigh = Math.max(...recentCandles.map(c => c.high));
      const swingLow = Math.min(...recentCandles.map(c => c.low));
      const range = swingHigh - swingLow;
      
      // Determinar direccin de la tendencia
      const closes = recentCandles.map(c => c.close);
      const firstHalf = closes.slice(0, 25).reduce((a,b) => a+b, 0) / 25;
      const secondHalf = closes.slice(25).reduce((a,b) => a+b, 0) / 25;
      const isUptrend = secondHalf > firstHalf;
      
      // Niveles Fibonacci: 0.236, 0.382, 0.5, 0.618, 0.786
      const fiboLevels = [0.236, 0.382, 0.5, 0.618, 0.786];
      const startTime = state.candles[0].time;
      const endTime = state.candles[state.candles.length - 1].time;
      
      fiboLevels.forEach((level, i) => {
        if (fiboLines[i]) {
          let price;
          if (isUptrend) {
            // En tendencia alcista, retrocesos desde el mximo
            price = swingHigh - (range * level);
          } else {
            // En tendencia bajista, retrocesos desde el mnimo
            price = swingLow + (range * level);
          }
          
          try {
            fiboLines[i].setData([
              { time: startTime, value: price },
              { time: endTime, value: price }
            ]);
          } catch (e) {}
        }
      });
      
      // Actualizar display de Fibonacci
      const fiboDisplay = document.getElementById('fiboLevels');
      if (fiboDisplay) {
        const currentPrice = state.currentPrice;
        const levels = fiboLevels.map((l, i) => {
          const price = isUptrend ? swingHigh - (range * l) : swingLow + (range * l);
          const diff = ((currentPrice - price) / price * 100).toFixed(2);
          const color = Math.abs(parseFloat(diff)) < 0.5 ? 'var(--accent-cyan)' : 'var(--text-dim)';
          return `<span style="color:${color}">${(l*100).toFixed(1)}%: ${price.toFixed(4)}</span>`;
        }).join(' | ');
        fiboDisplay.innerHTML = `<span style="color:var(--accent-yellow)">ðŸ“ FIBO:</span> ${levels}`;
      }
    }
    // ============================================
    // SESSION DETECTOR
    // ============================================
    
    const tradingSessions = {
      asia: { name: 'ASIA', start: 0, end: 9, emoji: '', volatility: 'Low-Medium' },
      europe: { name: 'EUROPE', start: 7, end: 16, emoji: '', volatility: 'High' },
      us: { name: 'US', start: 13, end: 22, emoji: '', volatility: 'Very High' },
      overlap_eu_us: { name: 'EU/US OVERLAP', start: 13, end: 16, emoji: '', volatility: 'Maximum' }
    };
    
    function detectTradingSession() {
      const now = new Date();
      const utcHour = now.getUTCHours();
      
      let activeSessions = [];
      let sessionInfo = { name: 'OFF-HOURS', emoji: '', volatility: 'Low', color: 'var(--text-dim)' };
      
      // Detectar sesiones activas
      if (utcHour >= 0 && utcHour < 9) {
        activeSessions.push('asia');
      }
      if (utcHour >= 7 && utcHour < 16) {
        activeSessions.push('europe');
      }
      if (utcHour >= 13 && utcHour < 22) {
        activeSessions.push('us');
      }
      
      // Determinar sesin principal
      if (utcHour >= 13 && utcHour < 16) {
        sessionInfo = { 
          name: 'EU/US OVERLAP', 
          emoji: '', 
          volatility: 'Maximum',
          color: 'var(--accent-red)'
        };
      } else if (activeSessions.includes('us')) {
        sessionInfo = { 
          name: 'US SESSION', 
          emoji: '', 
          volatility: 'Very High',
          color: 'var(--accent-green)'
        };
      } else if (activeSessions.includes('europe')) {
        sessionInfo = { 
          name: 'EUROPE SESSION', 
          emoji: '', 
          volatility: 'High',
          color: 'var(--accent-cyan)'
        };
      } else if (activeSessions.includes('asia')) {
        sessionInfo = { 
          name: 'ASIA SESSION', 
          emoji: '', 
          volatility: 'Low-Medium',
          color: 'var(--accent-purple)'
        };
      }
      
      return sessionInfo;
    }
    
    function updateSessionDisplay() {
      const session = detectTradingSession();
      const sessionEl = document.getElementById('sessionDisplay');
      if (sessionEl) {
        sessionEl.innerHTML = `${session.emoji} <span style="color:${session.color}">${session.name}</span><span style="font-size:9px; color:var(--text-dim)">Vol: ${session.volatility}</span>`;
      }
    }
    // ============================================
    // SIGNAL HISTORY LOG
    // ============================================
    
    const signalHistory = [];
    const MAX_SIGNAL_HISTORY = 50;
    
    function logSignal(type, probability, quality, price, regime) {
      const now = new Date();
      const signal = {
        time: now.toLocaleTimeString(),
        timestamp: now.getTime(),
        type, // 'BULL' or 'BEAR'
        probability,
        quality,
        price,
        regime,
        result: null // Se llena despus
      };
      
      signalHistory.unshift(signal);
      if (signalHistory.length > MAX_SIGNAL_HISTORY) {
        signalHistory.pop();
      }
      
      updateSignalHistoryDisplay();
      return signal;
    }
    
    function updateSignalHistoryDisplay() {
      const container = document.getElementById('signalHistoryList');
      if (!container) return;
      
      if (signalHistory.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:var(--text-dim); padding:10px;">No signals yet...</div>';
        return;
      }
      
      container.innerHTML = signalHistory.slice(0, 10).map(s => {
        const color = s.type === 'BULL' ? 'var(--accent-green)' : 'var(--accent-red)';
        const arrow = s.type === 'BULL' ? '' : '';
        const resultIcon = s.result === true ? '' : s.result === false ? '' : '';
        
        return `
          <div style="display:flex; justify-content:space-between; align-items:center; padding:4px 6px; border-bottom:1px solid rgba(255,255,255,0.05); font-size:10px;"><span style="color:var(--text-dim)">${s.time}</span><span style="color:${color}">${arrow} ${s.type}</span><span>${s.probability.toFixed(0)}%</span><span style="color:var(--accent-purple)">Q:${s.quality.toFixed(0)}</span><span>${resultIcon}</span></div>
        `;
      }).join('');
    }
    
    function verifySignalResults() {
      const currentPrice = state.currentPrice;
      const now = Date.now();
      
      signalHistory.forEach(s => {
        if (s.result === null) {
          const elapsed = now - s.timestamp;
          const priceChange = (currentPrice - s.price) / s.price * 100;
          
          // Verificacin en 3 etapas: 2min, 5min, 10min
          if (elapsed > 120000 && elapsed <= 300000) {
            if (s.type === 'BULL' && priceChange > 0.15) s.result = true;
            else if (s.type === 'BEAR' && priceChange < -0.15) s.result = true;
          } else if (elapsed > 300000 && elapsed <= 600000) {
            if (s.type === 'BULL') s.result = priceChange > 0.08;
            else s.result = priceChange < -0.08;
          } else if (elapsed > 600000) {
            if (s.type === 'BULL') s.result = priceChange > 0;
            else s.result = priceChange < 0;
          }
        }
      });
      
      updateSignalHistoryDisplay();
    }
    // ============================================
    // SCREENSHOT FUNCTION
    // ============================================
    
    async function captureScreenshot() {
      try {
        // Usar html2canvas si est disponible
        if (typeof html2canvas === 'undefined') {
          // Cargar html2canvas dinmicamente
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
          script.onload = () => doCapture();
          document.head.appendChild(script);
        } else {
          doCapture();
        }
      } catch (e) {
        addAlert('Screenshot failed: ' + e.message, 'warning');
      }
    }
    
    function doCapture() {
      const mainEl = document.querySelector('main');
      if (!mainEl) return;
      
      addAlert(' Capturing screenshot...', 'info');
      
      html2canvas(mainEl, {
        backgroundColor: '#02060c',
        scale: 2,
        logging: false,
        useCORS: true
      }).then(canvas => {
        // Crear link de descarga
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        link.download = `ORACULUM_${timestamp}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        addAlert(' Screenshot saved!', 'bullish');
      }).catch(e => {
        addAlert('Screenshot error: ' + e.message, 'warning');
      });
    }
    // ============================================
    // TECHNICAL INDICATORS
    // ============================================
    function calcEMA(data, period) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i] * k + ema * (1 - k);
      }
      return ema;
    }
    function calcSMA(data, period) {
      if (data.length < period) return null;
      return data.slice(-period).reduce((a, b) => a + b, 0) / period;
    }
    function calcRSI(closes, period = 14) {
      if (closes.length < period + 1) return null;
      let gains = 0, losses = 0;
      for (let i = closes.length - period; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      return 100 - (100 / (1 + avgGain / avgLoss));
    }
    function calcMACD(closes) {
      const emaFast = calcEMA(closes, CONFIG.MACD_FAST);
      const emaSlow = calcEMA(closes, CONFIG.MACD_SLOW);
      if (!emaFast || !emaSlow) return { macd: null, signal: null, histogram: null };
      const macdLine = emaFast - emaSlow;
      const macdHistory = [];
      for (let i = CONFIG.MACD_SLOW; i <= closes.length; i++) {
        const fast = calcEMA(closes.slice(0, i), CONFIG.MACD_FAST);
        const slow = calcEMA(closes.slice(0, i), CONFIG.MACD_SLOW);
        if (fast && slow) macdHistory.push(fast - slow);
      }
      const signalLine = calcEMA(macdHistory, CONFIG.MACD_SIGNAL) || 0;
      return { macd: macdLine, signal: signalLine, histogram: macdLine - signalLine };
    }
    function calcStochRSI(closes, period = 14) {
      if (closes.length < period * 2) return null;
      const rsiValues = [];
      for (let i = period + 1; i <= closes.length; i++) {
        const rsi = calcRSI(closes.slice(0, i), period);
        if (rsi !== null) rsiValues.push(rsi);
      }
      if (rsiValues.length < period) return null;
      const recentRSI = rsiValues.slice(-period);
      const minRSI = Math.min(...recentRSI);
      const maxRSI = Math.max(...recentRSI);
      if (maxRSI === minRSI) return 50;
      return ((rsiValues[rsiValues.length - 1] - minRSI) / (maxRSI - minRSI)) * 100;
    }
    function calcWilliamsR(candles, period = 14) {
      if (candles.length < period) return null;
      const recent = candles.slice(-period);
      const highestHigh = Math.max(...recent.map(c => c.high));
      const lowestLow = Math.min(...recent.map(c => c.low));
      const currentClose = candles[candles.length - 1].close;
      if (highestHigh === lowestLow) return -50;
      return ((highestHigh - currentClose) / (highestHigh - lowestLow)) * -100;
    }
    function calcBollingerBands(closes, period = 20, stdDev = 2) {
      if (closes.length < period) return null;
      const sma = calcSMA(closes, period);
      const slice = closes.slice(-period);
      const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period;
      const std = Math.sqrt(variance);
      return {
        upper: sma + (std * stdDev),
        middle: sma,
        lower: sma - (std * stdDev),
        bandwidth: ((sma + std * stdDev) - (sma - std * stdDev)) / sma * 100
      };
    }
    function calcATR(candles, period = 14) {
      if (candles.length < period + 1) return null;
      const trueRanges = [];
      for (let i = 1; i < candles.length; i++) {
        const tr = Math.max(
          candles[i].high - candles[i].low,
          Math.abs(candles[i].high - candles[i - 1].close),
          Math.abs(candles[i].low - candles[i - 1].close)
        );
        trueRanges.push(tr);
      }
      return calcSMA(trueRanges.slice(-period), period);
    }
    function calcADX(candles, period = 14) {
      if (candles.length < period * 2) return null;
      const plusDM = [], minusDM = [], tr = [];
      
      for (let i = 1; i < candles.length; i++) {
        const highDiff = candles[i].high - candles[i - 1].high;
        const lowDiff = candles[i - 1].low - candles[i].low;
        
        plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
        minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
        
        tr.push(Math.max(
          candles[i].high - candles[i].low,
          Math.abs(candles[i].high - candles[i - 1].close),
          Math.abs(candles[i].low - candles[i - 1].close)
        ));
      }
      
      const atr = calcSMA(tr.slice(-period), period);
      const plusDI = (calcSMA(plusDM.slice(-period), period) / atr) * 100;
      const minusDI = (calcSMA(minusDM.slice(-period), period) / atr) * 100;
      
      const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100;
      return { adx: dx, plusDI, minusDI };
    }
    function calcVWAP(candles) {
      if (candles.length < 1) return null;
      let cumVolPrice = 0, cumVol = 0;
      for (const c of candles) {
        const typical = (c.high + c.low + c.close) / 3;
        cumVolPrice += typical * (c.volume || 1);
        cumVol += (c.volume || 1);
      }
      return cumVolPrice / cumVol;
    }
    function calcOBV(candles) {
      if (candles.length < 2) return { obv: 0, trend: 'neutral' };
      let obv = 0;
      for (let i = 1; i < candles.length; i++) {
        if (candles[i].close > candles[i - 1].close) {
          obv += candles[i].volume || 1;
        } else if (candles[i].close < candles[i - 1].close) {
          obv -= candles[i].volume || 1;
        }
      }
      
      // Trend based on OBV EMA
      state.obvHistory.push(obv);
      if (state.obvHistory.length > 20) state.obvHistory.shift();
      
      const obvEma = calcEMA(state.obvHistory, 10);
      const trend = obv > obvEma ? 'bullish' : (obv < obvEma ? 'bearish' : 'neutral');
      
      return { obv, trend };
    }
    function calcMomentum(closes, period = 10) {
      if (closes.length < period + 1) return null;
      return ((closes[closes.length - 1] / closes[closes.length - period - 1]) - 1) * 100;
    }
    // ============================================
    //  GOD MODE - ADVANCED INDICATORS
    // ============================================
    
    // 1. ICHIMOKU CLOUD
    function calcIchimoku(candles) {
      if (candles.length < 52) return null;
      
      const highs = candles.map(c => c.high);
      const lows = candles.map(c => c.low);
      const closes = candles.map(c => c.close);
      
      // Tenkan-sen (Conversion Line): (9-period high + 9-period low) / 2
      const tenkan = (Math.max(...highs.slice(-9)) + Math.min(...lows.slice(-9))) / 2;
      
      // Kijun-sen (Base Line): (26-period high + 26-period low) / 2
      const kijun = (Math.max(...highs.slice(-26)) + Math.min(...lows.slice(-26))) / 2;
      
      // Senkou Span A (Leading Span A): (Tenkan + Kijun) / 2
      const senkouA = (tenkan + kijun) / 2;
      
      // Senkou Span B (Leading Span B): (52-period high + 52-period low) / 2
      const senkouB = (Math.max(...highs.slice(-52)) + Math.min(...lows.slice(-52))) / 2;
      
      // Chikou Span (Lagging Span): Current close plotted 26 periods back
      const chikou = closes[closes.length - 1];
      
      const currentPrice = closes[closes.length - 1];
      const cloudTop = Math.max(senkouA, senkouB);
      const cloudBottom = Math.min(senkouA, senkouB);
      
      // Signal determination
      let signal = 'neutral';
      let strength = 0;
      
      if (currentPrice > cloudTop && tenkan > kijun) {
        signal = 'bullish';
        strength = Math.min(100, ((currentPrice - cloudTop) / cloudTop) * 1000 + 50);
      } else if (currentPrice < cloudBottom && tenkan < kijun) {
        signal = 'bearish';
        strength = Math.min(100, ((cloudBottom - currentPrice) / cloudBottom) * 1000 + 50);
      } else if (currentPrice > cloudBottom && currentPrice < cloudTop) {
        signal = 'neutral'; // In the cloud
        strength = 30;
      }
      
      return { tenkan, kijun, senkouA, senkouB, chikou, cloudTop, cloudBottom, signal, strength };
    }
    
    // 2. SUPERTREND
    function calcSupertrend(candles, period = 10, multiplier = 3) {
      if (candles.length < period + 1) return null;
      
      const atr = calcATR(candles, period);
      if (!atr) return null;
      
      const currentCandle = candles[candles.length - 1];
      const hl2 = (currentCandle.high + currentCandle.low) / 2;
      
      const upperBand = hl2 + (multiplier * atr);
      const lowerBand = hl2 - (multiplier * atr);
      
      // Simplified trend detection
      const closes = candles.map(c => c.close);
      const recentCloses = closes.slice(-period);
      const trend = currentCandle.close > hl2 ? 'bullish' : 'bearish';
      
      return {
        upperBand,
        lowerBand,
        trend,
        value: trend === 'bullish' ? lowerBand : upperBand
      };
    }
    
    // 3. SQUEEZE MOMENTUM (Bollinger + Keltner)
    function calcSqueezeMomentum(candles) {
      if (candles.length < 20) return null;
      
      const closes = candles.map(c => c.close);
      const bb = calcBollingerBands(closes, 20, 2);
      const atr = calcATR(candles, 20);
      
      if (!bb || !atr) return null;
      
      const sma = bb.middle;
      const keltnerUpper = sma + (1.5 * atr);
      const keltnerLower = sma - (1.5 * atr);
      
      // Squeeze is on when BB is inside Keltner
      const squeezeOn = bb.lower > keltnerLower && bb.upper < keltnerUpper;
      
      // Momentum using linear regression
      const momLength = 12;
      if (closes.length < momLength) return { squeezeOn, momentum: 0, signal: 'neutral' };
      
      const recentCloses = closes.slice(-momLength);
      const midline = (Math.max(...recentCloses) + Math.min(...recentCloses)) / 2;
      const momentum = closes[closes.length - 1] - midline;
      
      let signal = 'neutral';
      if (momentum > 0) signal = squeezeOn ? 'buildup_bull' : 'bullish';
      else if (momentum < 0) signal = squeezeOn ? 'buildup_bear' : 'bearish';
      
      return { squeezeOn, momentum, signal };
    }
    
    // 4. CHAIKIN MONEY FLOW
    function calcCMF(candles, period = 20) {
      if (candles.length < period) return null;
      
      let mfvSum = 0;
      let volSum = 0;
      
      const recent = candles.slice(-period);
      
      for (const c of recent) {
        const range = c.high - c.low;
        if (range === 0) continue;
        
        const mfm = ((c.close - c.low) - (c.high - c.close)) / range;
        const mfv = mfm * c.volume;
        
        mfvSum += mfv;
        volSum += c.volume;
      }
      
      if (volSum === 0) return 0;
      return mfvSum / volSum;
    }
    
    // 5. VOLUME PROFILE (POC - Point of Control)
    function calcVolumeProfile(candles, bins = 20) {
      if (candles.length < 50) return null;
      
      const prices = candles.map(c => (c.high + c.low) / 2);
      const volumes = candles.map(c => c.volume);
      
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const binSize = (maxPrice - minPrice) / bins;
      
      const volumeByPrice = new Array(bins).fill(0);
      
      for (let i = 0; i < prices.length; i++) {
        const binIndex = Math.min(bins - 1, Math.floor((prices[i] - minPrice) / binSize));
        volumeByPrice[binIndex] += volumes[i];
      }
      
      // Find POC (Point of Control) - price level with most volume
      let maxVol = 0;
      let pocIndex = 0;
      for (let i = 0; i < volumeByPrice.length; i++) {
        if (volumeByPrice[i] > maxVol) {
          maxVol = volumeByPrice[i];
          pocIndex = i;
        }
      }
      
      const poc = minPrice + (pocIndex + 0.5) * binSize;
      const currentPrice = candles[candles.length - 1].close;
      
      // Value Area (70% of volume)
      const totalVol = volumeByPrice.reduce((a, b) => a + b, 0);
      let vaVol = volumeByPrice[pocIndex];
      let vaHigh = pocIndex;
      let vaLow = pocIndex;
      
      while (vaVol < totalVol * 0.7 && (vaHigh < bins - 1 || vaLow > 0)) {
        const upVol = vaHigh < bins - 1 ? volumeByPrice[vaHigh + 1] : 0;
        const downVol = vaLow > 0 ? volumeByPrice[vaLow - 1] : 0;
        
        if (upVol > downVol && vaHigh < bins - 1) {
          vaHigh++;
          vaVol += volumeByPrice[vaHigh];
        } else if (vaLow > 0) {
          vaLow--;
          vaVol += volumeByPrice[vaLow];
        }
      }
      
      return {
        poc,
        vah: minPrice + (vaHigh + 1) * binSize,
        val: minPrice + vaLow * binSize,
        currentVsProfile: currentPrice > poc ? 'above_poc' : 'below_poc'
      };
    }
    
    // 6. ORDER FLOW IMBALANCE
    function calcOrderFlowImbalance(candles) {
      if (candles.length < 10) return null;
      
      const recent = candles.slice(-10);
      let buyPressure = 0;
      let sellPressure = 0;
      
      for (const c of recent) {
        const range = c.high - c.low;
        if (range === 0) continue;
        
        // Estimate buy/sell pressure from candle structure
        const buyRatio = (c.close - c.low) / range;
        const sellRatio = (c.high - c.close) / range;
        
        buyPressure += buyRatio * c.volume;
        sellPressure += sellRatio * c.volume;
      }
      
      const total = buyPressure + sellPressure;
      if (total === 0) return { imbalance: 0, signal: 'neutral' };
      
      const imbalance = ((buyPressure - sellPressure) / total) * 100;
      
      let signal = 'neutral';
      if (imbalance > 20) signal = 'bullish';
      else if (imbalance < -20) signal = 'bearish';
      
      return { imbalance, buyPressure, sellPressure, signal };
    }
    
    // 7. MARKET STRUCTURE (Higher Highs, Lower Lows)
    function calcMarketStructure(candles) {
      if (candles.length < 30) return null;
      
      const swings = [];
      const lookback = 5;
      
      // Find swing highs and lows
      for (let i = lookback; i < candles.length - lookback; i++) {
        let isSwingHigh = true;
        let isSwingLow = true;
        
        for (let j = i - lookback; j <= i + lookback; j++) {
          if (j === i) continue;
          if (candles[j].high >= candles[i].high) isSwingHigh = false;
          if (candles[j].low <= candles[i].low) isSwingLow = false;
        }
        
        if (isSwingHigh) swings.push({ type: 'high', price: candles[i].high, index: i });
        if (isSwingLow) swings.push({ type: 'low', price: candles[i].low, index: i });
      }
      
      // Analyze structure
      const recentSwings = swings.slice(-6);
      const highs = recentSwings.filter(s => s.type === 'high');
      const lows = recentSwings.filter(s => s.type === 'low');
      
      let structure = 'ranging';
      
      if (highs.length >= 2 && lows.length >= 2) {
        const hh = highs[highs.length - 1]?.price > highs[highs.length - 2]?.price;
        const hl = lows[lows.length - 1]?.price > lows[lows.length - 2]?.price;
        const lh = highs[highs.length - 1]?.price < highs[highs.length - 2]?.price;
        const ll = lows[lows.length - 1]?.price < lows[lows.length - 2]?.price;
        
        if (hh && hl) structure = 'uptrend';
        else if (lh && ll) structure = 'downtrend';
        else if (hh && ll) structure = 'expanding';
        else if (lh && hl) structure = 'contracting';
      }
      
      return { structure, swings: recentSwings, highs, lows };
    }
    
    // 8. SMART MONEY CONCEPTS
    function calcSmartMoneyConcepts(candles) {
      if (candles.length < 30) return { orderBlocks: [], fvg: [], liquidity: [] };
      
      const orderBlocks = [];
      const fvg = []; // Fair Value Gaps
      const liquidity = [];
      
      // Detect Order Blocks (last opposing candle before strong move)
      for (let i = 3; i < candles.length - 1; i++) {
        const c = candles[i];
        const prev = candles[i - 1];
        const next = candles[i + 1];
        
        const cBody = Math.abs(c.close - c.open);
        const cRange = c.high - c.low;
        const prevBody = Math.abs(prev.close - prev.open);
        const nextBody = Math.abs(next.close - next.open);
        
        // Bullish Order Block: bearish candle followed by strong bullish move
        if (prev.close < prev.open && c.close > c.open && cBody > prevBody * 2) {
          orderBlocks.push({
            type: 'bullish',
            high: prev.high,
            low: prev.low,
            index: i - 1
          });
        }
        
        // Bearish Order Block: bullish candle followed by strong bearish move
        if (prev.close > prev.open && c.close < c.open && cBody > prevBody * 2) {
          orderBlocks.push({
            type: 'bearish',
            high: prev.high,
            low: prev.low,
            index: i - 1
          });
        }
        
        // Fair Value Gap (FVG)
        if (i >= 2) {
          const c1 = candles[i - 2];
          const c2 = candles[i - 1];
          const c3 = candles[i];
          
          // Bullish FVG: gap between c1 high and c3 low
          if (c3.low > c1.high) {
            fvg.push({
              type: 'bullish',
              top: c3.low,
              bottom: c1.high,
              index: i
            });
          }
          
          // Bearish FVG: gap between c1 low and c3 high
          if (c3.high < c1.low) {
            fvg.push({
              type: 'bearish',
              top: c1.low,
              bottom: c3.high,
              index: i
            });
          }
        }
      }
      
      // Detect Liquidity zones (equal highs/lows)
      const tolerance = 0.001; // 0.1%
      const highs = candles.slice(-20).map((c, i) => ({ price: c.high, index: i }));
      const lows = candles.slice(-20).map((c, i) => ({ price: c.low, index: i }));
      
      // Find equal highs (potential sell-side liquidity)
      for (let i = 0; i < highs.length - 1; i++) {
        for (let j = i + 1; j < highs.length; j++) {
          if (Math.abs(highs[i].price - highs[j].price) / highs[i].price < tolerance) {
            liquidity.push({
              type: 'sell_side',
              price: (highs[i].price + highs[j].price) / 2
            });
          }
        }
      }
      
      // Find equal lows (potential buy-side liquidity)
      for (let i = 0; i < lows.length - 1; i++) {
        for (let j = i + 1; j < lows.length; j++) {
          if (Math.abs(lows[i].price - lows[j].price) / lows[i].price < tolerance) {
            liquidity.push({
              type: 'buy_side',
              price: (lows[i].price + lows[j].price) / 2
            });
          }
        }
      }
      
      return { 
        orderBlocks: orderBlocks.slice(-3), 
        fvg: fvg.slice(-3), 
        liquidity: liquidity.slice(-5),
        nearestOB: orderBlocks[orderBlocks.length - 1] || null,
        nearestFVG: fvg[fvg.length - 1] || null
      };
    }
    
    // 9. FIBONACCI LEVELS (Automatic)
    function calcAutoFibonacci(candles, lookback = 50) {
      if (candles.length < lookback) return null;
      
      const recent = candles.slice(-lookback);
      const high = Math.max(...recent.map(c => c.high));
      const low = Math.min(...recent.map(c => c.low));
      const diff = high - low;
      
      const currentPrice = candles[candles.length - 1].close;
      
      // Determine trend direction for Fib
      const firstHalf = recent.slice(0, lookback / 2);
      const secondHalf = recent.slice(lookback / 2);
      const firstAvg = firstHalf.reduce((a, c) => a + c.close, 0) / firstHalf.length;
      const secondAvg = secondHalf.reduce((a, c) => a + c.close, 0) / secondHalf.length;
      const isUptrend = secondAvg > firstAvg;
      
      const levels = isUptrend ? {
        // Retracement from low to high (uptrend)
        fib0: low,
        fib236: low + diff * 0.236,
        fib382: low + diff * 0.382,
        fib5: low + diff * 0.5,
        fib618: low + diff * 0.618,
        fib786: low + diff * 0.786,
        fib1: high
      } : {
        // Retracement from high to low (downtrend)
        fib0: high,
        fib236: high - diff * 0.236,
        fib382: high - diff * 0.382,
        fib5: high - diff * 0.5,
        fib618: high - diff * 0.618,
        fib786: high - diff * 0.786,
        fib1: low
      };
      
      // Find nearest Fib level
      const fibLevels = [
        { name: '0%', price: levels.fib0 },
        { name: '23.6%', price: levels.fib236 },
        { name: '38.2%', price: levels.fib382 },
        { name: '50%', price: levels.fib5 },
        { name: '61.8%', price: levels.fib618 },
        { name: '78.6%', price: levels.fib786 },
        { name: '100%', price: levels.fib1 }
      ];
      
      let nearest = fibLevels[0];
      let minDist = Math.abs(currentPrice - fibLevels[0].price);
      
      for (const level of fibLevels) {
        const dist = Math.abs(currentPrice - level.price);
        if (dist < minDist) {
          minDist = dist;
          nearest = level;
        }
      }
      
      return { levels, nearest, isUptrend, high, low };
    }
    
    // 10. MULTI-TIMEFRAME STATE
    const mtfState = {
      tf1m: { signal: 'neutral', strength: 0 },
      tf5m: { signal: 'neutral', strength: 0 },
      tf15m: { signal: 'neutral', strength: 0 },
      tf1h: { signal: 'neutral', strength: 0 },
      confluence: 0,
      lastUpdate: 0
    };
    
    // Simulate higher timeframe analysis from 1m data
    function analyzeMultiTimeframe(candles1m) {
      if (candles1m.length < 60) return mtfState;
      
      // Aggregate to higher timeframes
      const aggregate = (srcCandles, factor) => {
        const result = [];
        for (let i = 0; i < srcCandles.length; i += factor) {
          const chunk = srcCandles.slice(i, i + factor);
          if (chunk.length < factor) break;
          result.push({
            open: chunk[0].open,
            high: Math.max(...chunk.map(c => c.high)),
            low: Math.min(...chunk.map(c => c.low)),
            close: chunk[chunk.length - 1].close,
            volume: chunk.reduce((a, c) => a + c.volume, 0)
          });
        }
        return result;
      };
      
      const candles5m = aggregate(candles1m, 5);
      const candles15m = aggregate(candles1m, 15);
      const candles1h = aggregate(candles1m, 60);
      
      // Analyze each timeframe
      const analyzeTF = (candles) => {
        if (candles.length < 20) return { signal: 'neutral', strength: 0 };
        
        const closes = candles.map(c => c.close);
        const ema9 = calcEMA(closes, Math.min(9, closes.length));
        const ema21 = calcEMA(closes, Math.min(21, closes.length));
        const rsi = calcRSI(closes, 14);
        const currentPrice = closes[closes.length - 1];
        
        let bullPoints = 0;
        let bearPoints = 0;
        
        if (ema9 && ema21) {
          if (ema9 > ema21) bullPoints += 2;
          else bearPoints += 2;
        }
        
        if (currentPrice > ema9) bullPoints += 1;
        else bearPoints += 1;
        
        if (rsi !== null) {
          if (rsi > 50) bullPoints += 1;
          else bearPoints += 1;
          if (rsi > 70) bearPoints += 1; // Overbought
          if (rsi < 30) bullPoints += 1; // Oversold
        }
        
        const totalPoints = bullPoints + bearPoints;
        if (bullPoints > bearPoints) {
          return { signal: 'bullish', strength: Math.round((bullPoints / totalPoints) * 100) };
        } else if (bearPoints > bullPoints) {
          return { signal: 'bearish', strength: Math.round((bearPoints / totalPoints) * 100) };
        }
        return { signal: 'neutral', strength: 50 };
      };
      
      mtfState.tf1m = analyzeTF(candles1m.slice(-50));
      mtfState.tf5m = analyzeTF(candles5m);
      mtfState.tf15m = analyzeTF(candles15m);
      mtfState.tf1h = analyzeTF(candles1h);
      
      // Calculate confluence
      let confluence = 0;
      const signals = [mtfState.tf1m, mtfState.tf5m, mtfState.tf15m, mtfState.tf1h];
      const bullishCount = signals.filter(s => s.signal === 'bullish').length;
      const bearishCount = signals.filter(s => s.signal === 'bearish').length;
      
      mtfState.confluence = Math.max(bullishCount, bearishCount);
      mtfState.dominantSignal = bullishCount > bearishCount ? 'bullish' : (bearishCount > bullishCount ? 'bearish' : 'neutral');
      mtfState.lastUpdate = Date.now();
      
      return mtfState;
    }
    
    // 11. TRADING SIGNAL GENERATOR (Entry/SL/TP)
    function generateTradingSignal(currentPrice, atr, probability, regime, indicators) {
      const minProbability = 62;
      const minConfluence = 4;
      
      if (!atr || probability < minProbability) {
        return null;
      }
      
      const isBullish = probability >= 50 && (regime === 'trending_up' || regime === 'ranging');
      const direction = isBullish ? 'LONG' : 'SHORT';
      
      // ATR-based stops and targets (dinmicos segn rgimen)
      let atrMultiplierSL, atrMultiplierTP1, atrMultiplierTP2;
      
      if (regime === 'volatile') {
        atrMultiplierSL = 2.0;
        atrMultiplierTP1 = 1.8;
        atrMultiplierTP2 = 3.0;
      } else if (regime === 'trending_up' || regime === 'trending_down') {
        atrMultiplierSL = 1.3;
        atrMultiplierTP1 = 2.2;
        atrMultiplierTP2 = 4.0;
      } else {
        atrMultiplierSL = 1.5;
        atrMultiplierTP1 = 1.8;
        atrMultiplierTP2 = 2.8;
      }
      
      let entry, stopLoss, tp1, tp2;
      
      if (direction === 'LONG') {
        entry = currentPrice;
        stopLoss = currentPrice - (atr * atrMultiplierSL);
        tp1 = currentPrice + (atr * atrMultiplierTP1);
        tp2 = currentPrice + (atr * atrMultiplierTP2);
      } else {
        entry = currentPrice;
        stopLoss = currentPrice + (atr * atrMultiplierSL);
        tp1 = currentPrice - (atr * atrMultiplierTP1);
        tp2 = currentPrice - (atr * atrMultiplierTP2);
      }
      
      const risk = Math.abs(entry - stopLoss) / entry * 100;
      const reward = Math.abs(tp1 - entry) / entry * 100;
      const riskReward = reward / risk;
      
      const baseWinRate = probability * 0.55;
      const confluenceBonus = indicators.confluence * 2.5;
      const regimeBonus = (regime === 'trending_up' || regime === 'trending_down') ? 5 : 0;
      const estimatedWinRate = Math.min(78, baseWinRate + confluenceBonus + regimeBonus);
      
      return {
        direction,
        entry,
        stopLoss,
        tp1,
        tp2,
        risk,
        reward,
        riskReward,
        estimatedWinRate,
        probability,
        regime,
        timestamp: Date.now()
      };
    }
    
    // 12. WHALE IMPACT CALCULATOR
    function calculateWhaleImpact() {
      if (!state.whaleTransactions || state.whaleTransactions.length === 0) return 0;
      
      const recentWhales = state.whaleTransactions.filter(w => 
        Date.now() - new Date(w.time).getTime() < 300000 // Last 5 minutes
      );
      
      let buyVolume = 0;
      let sellVolume = 0;
      
      for (const whale of recentWhales) {
        const amount = parseFloat(whale.amount) || 0;
        if (whale.type === 'BUY') buyVolume += amount;
        else sellVolume += amount;
      }
      
      const totalVolume = buyVolume + sellVolume;
      if (totalVolume === 0) return 0;
      
      // Impact score: -100 (all sell) to +100 (all buy)
      return Math.round(((buyVolume - sellVolume) / totalVolume) * 100);
    }
    
    // 13. ADAPTIVE INDICATOR WEIGHTS
    const indicatorWeights = {
      rsi: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      macd: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      ema: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      bb: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      ichimoku: { weight: 1.2, accuracy: 0.5, hits: 0, misses: 0 },
      structure: { weight: 1.3, accuracy: 0.5, hits: 0, misses: 0 },
      mtf: { weight: 1.5, accuracy: 0.5, hits: 0, misses: 0 },
      whale: { weight: 1.1, accuracy: 0.5, hits: 0, misses: 0 }
    };
    
    function updateIndicatorWeight(indicator, wasCorrect) {
      if (!indicatorWeights[indicator]) return;
      
      if (wasCorrect) {
        indicatorWeights[indicator].hits++;
      } else {
        indicatorWeights[indicator].misses++;
      }
      
      const total = indicatorWeights[indicator].hits + indicatorWeights[indicator].misses;
      if (total > 0) {
        indicatorWeights[indicator].accuracy = indicatorWeights[indicator].hits / total;
        // Adjust weight based on accuracy (0.5 to 2.0 range)
        indicatorWeights[indicator].weight = 0.5 + (indicatorWeights[indicator].accuracy * 1.5);
      }
    }
    function detectRSIDivergence(prices, rsiValues) {
      if (prices.length < 20 || rsiValues.length < 20) return null;
      
      const recentPrices = prices.slice(-20);
      const recentRSI = rsiValues.slice(-20);
      
      // Find local highs and lows in last 20 periods
      let priceHigh1 = -Infinity, priceHigh2 = -Infinity;
      let priceLow1 = Infinity, priceLow2 = Infinity;
      let rsiHigh1 = -Infinity, rsiHigh2 = -Infinity;
      let rsiLow1 = Infinity, rsiLow2 = Infinity;
      
      const mid = Math.floor(recentPrices.length / 2);
      
      for (let i = 0; i < mid; i++) {
        if (recentPrices[i] > priceHigh1) priceHigh1 = recentPrices[i];
        if (recentPrices[i] < priceLow1) priceLow1 = recentPrices[i];
        if (recentRSI[i] > rsiHigh1) rsiHigh1 = recentRSI[i];
        if (recentRSI[i] < rsiLow1) rsiLow1 = recentRSI[i];
      }
      
      for (let i = mid; i < recentPrices.length; i++) {
        if (recentPrices[i] > priceHigh2) priceHigh2 = recentPrices[i];
        if (recentPrices[i] < priceLow2) priceLow2 = recentPrices[i];
        if (recentRSI[i] > rsiHigh2) rsiHigh2 = recentRSI[i];
        if (recentRSI[i] < rsiLow2) rsiLow2 = recentRSI[i];
      }
      
      // Bullish divergence: price makes lower low, RSI makes higher low
      if (priceLow2 < priceLow1 && rsiLow2 > rsiLow1) {
        return 'bullish';
      }
      
      // Bearish divergence: price makes higher high, RSI makes lower high
      if (priceHigh2 > priceHigh1 && rsiHigh2 < rsiHigh1) {
        return 'bearish';
      }
      
      return null;
    }
    // ============================================
    // CANDLE PATTERN DETECTION
    // ============================================
    function detectCandlePatterns(candles) {
      if (candles.length < 5) return [];
      const patterns = [];
      
      const c = candles[candles.length - 1];      // Current
      const prev = candles[candles.length - 2];   // Previous
      const prev2 = candles[candles.length - 3];  // 2 candles ago
      const prev3 = candles[candles.length - 4];  // 3 candles ago
      
      const body = Math.abs(c.close - c.open);
      const upperWick = c.high - Math.max(c.open, c.close);
      const lowerWick = Math.min(c.open, c.close) - c.low;
      const range = c.high - c.low;
      const isBullish = c.close > c.open;
      const isBearish = c.close < c.open;
      
      const prevBody = Math.abs(prev.close - prev.open);
      const prevRange = prev.high - prev.low;
      
      // Evitar divisin por cero
      if (range === 0 || body === 0) return patterns;
      
      // --- SINGLE CANDLE PATTERNS ---
      
      // Doji (cuerpo muy pequeo)
      if (body < range * 0.15 && range > 0) {
        if (upperWick > body * 1.5 && lowerWick > body * 1.5) {
          patterns.push({ name: 'DOJI', type: 'neutral' });
        } else if (upperWick > lowerWick * 2) {
          patterns.push({ name: 'GRAVESTONE', type: 'bearish' });
        } else if (lowerWick > upperWick * 2) {
          patterns.push({ name: 'DRAGONFLY', type: 'bullish' });
        }
      }
      
      // Hammer (bullish reversal) - mecha inferior larga
      if (lowerWick > body * 1.5 && upperWick < body * 0.8 && isBullish) {
        patterns.push({ name: 'HAMMER', type: 'bullish' });
      }
      
      // Inverted Hammer
      if (upperWick > body * 1.5 && lowerWick < body * 0.8 && isBullish) {
        patterns.push({ name: 'INV HAMMER', type: 'bullish' });
      }
      
      // Shooting Star (bearish reversal) - mecha superior larga
      if (upperWick > body * 1.5 && lowerWick < body * 0.8 && isBearish) {
        patterns.push({ name: 'SHOOTING STAR', type: 'bearish' });
      }
      
      // Hanging Man
      if (lowerWick > body * 1.5 && upperWick < body * 0.8 && isBearish) {
        patterns.push({ name: 'HANGING MAN', type: 'bearish' });
      }
      
      // Marubozu (vela de cuerpo completo sin mechas)
      if (body > range * 0.85) {
        if (isBullish) {
          patterns.push({ name: 'BULL MARUBOZU', type: 'bullish' });
        } else {
          patterns.push({ name: 'BEAR MARUBOZU', type: 'bearish' });
        }
      }
      
      // Spinning Top (cuerpo pequeo, mechas similares)
      if (body < range * 0.3 && Math.abs(upperWick - lowerWick) < range * 0.2) {
        patterns.push({ name: 'SPINNING TOP', type: 'neutral' });
      }
      
      // --- TWO CANDLE PATTERNS ---
      
      // Bullish Engulfing
      if (prev.close < prev.open && isBullish && 
          c.open <= prev.close && c.close >= prev.open &&
          body > prevBody) {
        patterns.push({ name: 'BULL ENGULF', type: 'bullish' });
      }
      
      // Bearish Engulfing
      if (prev.close > prev.open && isBearish && 
          c.open >= prev.close && c.close <= prev.open &&
          body > prevBody) {
        patterns.push({ name: 'BEAR ENGULF', type: 'bearish' });
      }
      
      // Piercing Line (bullish)
      if (prev.close < prev.open && isBullish &&
          c.open < prev.low && c.close > (prev.open + prev.close) / 2) {
        patterns.push({ name: 'PIERCING', type: 'bullish' });
      }
      
      // Dark Cloud Cover (bearish)
      if (prev.close > prev.open && isBearish &&
          c.open > prev.high && c.close < (prev.open + prev.close) / 2) {
        patterns.push({ name: 'DARK CLOUD', type: 'bearish' });
      }
      
      // Tweezer Bottom (bullish)
      if (Math.abs(c.low - prev.low) < range * 0.1 && isBullish && prev.close < prev.open) {
        patterns.push({ name: 'TWEEZER BTM', type: 'bullish' });
      }
      
      // Tweezer Top (bearish)
      if (Math.abs(c.high - prev.high) < range * 0.1 && isBearish && prev.close > prev.open) {
        patterns.push({ name: 'TWEEZER TOP', type: 'bearish' });
      }
      
      // --- THREE CANDLE PATTERNS ---
      
      // Morning Star (bullish reversal)
      if (prev2.close < prev2.open &&  // First: bearish
          Math.abs(prev.close - prev.open) < prevRange * 0.4 && // Second: small body
          isBullish && c.close > (prev2.open + prev2.close) / 2) { // Third: bullish
        patterns.push({ name: 'MORNING STAR', type: 'bullish' });
      }
      
      // Evening Star (bearish reversal)
      if (prev2.close > prev2.open && 
          Math.abs(prev.close - prev.open) < prevRange * 0.4 &&
          isBearish && c.close < (prev2.open + prev2.close) / 2) {
        patterns.push({ name: 'EVENING STAR', type: 'bearish' });
      }
      
      // Three White Soldiers (bullish)
      if (prev2.close > prev2.open && prev.close > prev.open && isBullish &&
          prev.close > prev2.close && c.close > prev.close) {
        patterns.push({ name: '3 WHITE SOLD', type: 'bullish' });
      }
      
      // Three Black Crows (bearish)
      if (prev2.close < prev2.open && prev.close < prev.open && isBearish &&
          prev.close < prev2.close && c.close < prev.close) {
        patterns.push({ name: '3 BLACK CROW', type: 'bearish' });
      }
      
      // --- TREND PATTERNS ---
      
      // Strong momentum up (3+ consecutive green candles)
      const lastFive = candles.slice(-5);
      const greenCount = lastFive.filter(c => c.close > c.open).length;
      const redCount = lastFive.filter(c => c.close < c.open).length;
      
      if (greenCount >= 4) {
        patterns.push({ name: 'STRONG UP', type: 'bullish' });
      } else if (redCount >= 4) {
        patterns.push({ name: 'STRONG DOWN', type: 'bearish' });
      }
      
      // Higher highs and higher lows (uptrend)
      if (c.high > prev.high && c.low > prev.low && prev.high > prev2.high) {
        patterns.push({ name: 'UPTREND', type: 'bullish' });
      }
      
      // Lower highs and lower lows (downtrend)
      if (c.high < prev.high && c.low < prev.low && prev.high < prev2.high) {
        patterns.push({ name: 'DOWNTREND', type: 'bearish' });
      }
      
      // ---  GOD MODE ADVANCED PATTERNS ---
      
      // Double Bottom Detection (bullish reversal)
      if (candles.length >= 20) {
        const recent20 = candles.slice(-20);
        const lows = recent20.map(c => c.low);
        const minLow = Math.min(...lows);
        const lowIndices = lows.map((l, i) => ({ low: l, index: i }))
                               .filter(x => Math.abs(x.low - minLow) / minLow < 0.005);
        if (lowIndices.length >= 2 && lowIndices[lowIndices.length - 1].index - lowIndices[0].index >= 5) {
          patterns.push({ name: 'DOUBLE BTM', type: 'bullish' });
        }
        
        // Double Top Detection (bearish reversal)
        const highs = recent20.map(c => c.high);
        const maxHigh = Math.max(...highs);
        const highIndices = highs.map((h, i) => ({ high: h, index: i }))
                                 .filter(x => Math.abs(x.high - maxHigh) / maxHigh < 0.005);
        if (highIndices.length >= 2 && highIndices[highIndices.length - 1].index - highIndices[0].index >= 5) {
          patterns.push({ name: 'DOUBLE TOP', type: 'bearish' });
        }
      }
      
      // Bull Flag (consolidation after strong move up)
      if (candles.length >= 15) {
        const recent15 = candles.slice(-15);
        const first5 = recent15.slice(0, 5);
        const last5 = recent15.slice(-5);
        
        const strongMove = first5.every(c => c.close > c.open);
        const consolidation = last5.every(c => Math.abs(c.close - c.open) < (c.high - c.low) * 0.5);
        const lowerHighs = last5[4].high < last5[0].high;
        
        if (strongMove && consolidation && lowerHighs) {
          patterns.push({ name: 'BULL FLAG', type: 'bullish' });
        }
        
        // Bear Flag
        const strongDown = first5.every(c => c.close < c.open);
        const higherLows = last5[4].low > last5[0].low;
        
        if (strongDown && consolidation && higherLows) {
          patterns.push({ name: 'BEAR FLAG', type: 'bearish' });
        }
      }
      
      // Ascending Triangle (bullish)
      if (candles.length >= 12) {
        const recent12 = candles.slice(-12);
        const highs12 = recent12.map(c => c.high);
        const lows12 = recent12.map(c => c.low);
        
        const flatTop = Math.max(...highs12) - Math.min(...highs12.slice(-6)) < range * 0.5;
        const risingBottom = lows12[11] > lows12[0] && lows12[8] > lows12[3];
        
        if (flatTop && risingBottom) {
          patterns.push({ name: 'ASC TRIANGLE', type: 'bullish' });
        }
        
        // Descending Triangle (bearish)
        const flatBottom = Math.max(...lows12.slice(-6)) - Math.min(...lows12) < range * 0.5;
        const fallingTop = highs12[11] < highs12[0] && highs12[8] < highs12[3];
        
        if (flatBottom && fallingTop) {
          patterns.push({ name: 'DESC TRIANGLE', type: 'bearish' });
        }
      }
      
      // Cup and Handle (bullish)
      if (candles.length >= 30) {
        const recent30 = candles.slice(-30);
        const midPoint = Math.floor(recent30.length / 2);
        const leftSide = recent30.slice(0, midPoint);
        const rightSide = recent30.slice(midPoint);
        
        const leftHighStart = leftSide[0].high;
        const cupBottom = Math.min(...recent30.map(c => c.low));
        const rightHighEnd = rightSide[rightSide.length - 1].high;
        
        const cupDepth = (leftHighStart - cupBottom) / leftHighStart;
        const rightRecovery = rightHighEnd > leftHighStart * 0.95;
        
        if (cupDepth > 0.03 && cupDepth < 0.15 && rightRecovery) {
          patterns.push({ name: 'CUP&HANDLE', type: 'bullish' });
        }
      }
      
      // Inside Bar (consolidation/breakout setup)
      if (c.high < prev.high && c.low > prev.low) {
        patterns.push({ name: 'INSIDE BAR', type: 'neutral' });
      }
      
      // Outside Bar / Engulfing Range
      if (c.high > prev.high && c.low < prev.low && body > prevBody * 1.5) {
        patterns.push({ name: 'OUTSIDE BAR', type: isBullish ? 'bullish' : 'bearish' });
      }
      
      return patterns.slice(0, 5); // Increased to 5 patterns for GOD MODE
    }
    // ============================================
    // SPOOF DETECTION
    // ============================================
    function detectSpoofing(currentBids, currentAsks) {
      const lastBids = state.lastOrderBook.bids;
      const lastAsks = state.lastOrderBook.asks;
      
      if (lastBids.length === 0) return false;
      
      // Check for large orders that disappeared
      for (const lastBid of lastBids) {
        const vol = parseFloat(lastBid[1]);
        if (vol > CONFIG.SPOOF_THRESHOLD) {
          const stillExists = currentBids.some(b => 
            parseFloat(b[0]) === parseFloat(lastBid[0]) && 
            parseFloat(b[1]) > vol * 0.5
          );
          if (!stillExists) return true;
        }
      }
      
      for (const lastAsk of lastAsks) {
        const vol = parseFloat(lastAsk[1]);
        if (vol > CONFIG.SPOOF_THRESHOLD) {
          const stillExists = currentAsks.some(a => 
            parseFloat(a[0]) === parseFloat(lastAsk[0]) && 
            parseFloat(a[1]) > vol * 0.5
          );
          if (!stillExists) return true;
        }
      }
      
      return false;
    }
    // ============================================
    // ALERTS SYSTEM
    // ============================================
    function addAlert(message, type = 'info') {
      state.alertCount++;
      ui.alertCount.innerText = state.alertCount;
      
      const div = document.createElement('div');
      div.className = `alert-item alert-${type}`;
      const time = new Date().toLocaleTimeString();
      const timeSpan = document.createElement('span');
      timeSpan.style.color = 'var(--text-dim)';
      timeSpan.textContent = `[${time}]`;
      div.appendChild(timeSpan);
      div.appendChild(document.createTextNode(' ' + String(message)));
      ui.alertsContainer.prepend(div);
      
      // Reproducir sonido segn tipo de alerta
      if (state.soundEnabled) {
        if (type === 'bullish') playSound('bullish');
        else if (type === 'bearish') playSound('bearish');
        else if (type === 'warning') playSound('alert');
      }
      
      while (ui.alertsContainer.children.length > 20) {
        ui.alertsContainer.lastChild.remove();
      }
    }
    // ============================================
    // PREDICTION TRACKING
    // ============================================
    function trackPrediction(targetPrice, currentPrice) {
      const rsi = state.rsiHistory.length > 0 ? state.rsiHistory[state.rsiHistory.length - 1] : null;
      
      state.predictions.push({
        timestamp: Date.now(),
        target: targetPrice,
        actual: currentPrice,
        direction: targetPrice > currentPrice ? 'up' : 'down',
        rsi: rsi
      });
      
      // Keep last 50 predictions
      if (state.predictions.length > 50) state.predictions.shift();
      
      // Calculate accuracy after we have some results
      if (state.predictions.length >= 10) {
        let correct = 0;
        for (let i = 0; i < state.predictions.length - 5; i++) {
          const pred = state.predictions[i];
          const futurePrice = state.predictions[Math.min(i + 5, state.predictions.length - 1)].actual;
          
          const actualDirection = futurePrice > pred.actual ? 'up' : 'down';
          const isCorrect = actualDirection === pred.direction;
          if (isCorrect) correct++;
          
          // Guardar en historial si no est ya
          if (state.predictionHistory.length < i + 1) {
            state.predictionHistory.push(isCorrect);
          }
        }
        
        // Limitar historial a 100
        if (state.predictionHistory.length > 100) {
          state.predictionHistory = state.predictionHistory.slice(-100);
        }
        
        const accuracy = (correct / (state.predictions.length - 5)) * 100;
        ui.modelAccuracy.innerText = accuracy.toFixed(0) + '%';
        ui.accuracyBar.style.width = accuracy + '%';
        ui.accuracyPct.innerText = accuracy.toFixed(0) + '%';
        
        ui.accuracyBar.style.background = accuracy > 60 ? 'var(--accent-green)' : 
          (accuracy > 50 ? 'var(--accent-orange)' : 'var(--accent-red)');
      }
      
      // Actualizar grfico de historial SIEMPRE (muestra progreso)
      updatePredictionHistoryChart();
    }
    // ============================================
    // AI ENGINE v2.0 - ADVANCED PREDICTIVE SYSTEM
    // ============================================
    
    // Estado del motor AI
    const aiState = {
      marketRegime: 'unknown',        // trending_up, trending_down, ranging, volatile
      regimeStrength: 0,              // 0-100
      supportLevels: [],              // Niveles de soporte dinmicos
      resistanceLevels: [],           // Niveles de resistencia dinmicos
      signalQuality: 0,               // 0-100 calidad de la seal actual
      confluenceScore: 0,             // Nmero de indicadores en confluencia
      probabilityBull: 50,            // Probabilidad alcista %
      probabilityBear: 50,            // Probabilidad bajista %
      noiseLevel: 0,                  // Nivel de ruido del mercado
      lastSignals: [],                // Historial de seales para backtesting
      predictionAccuracy: [],         // Tracking de precisin
      volumeProfile: [],              // Perfil de volumen
      lastDivergence: null,           // ltima divergencia detectada (para evitar repetir alertas)
      priceAction: {                  // Anlisis de price action
        higherHighs: 0,
        lowerLows: 0,
        swingHigh: 0,
        swingLow: 0
      }
    };
    // ============================================
    // 1. MARKET REGIME DETECTION
    // ============================================
    
    function detectMarketRegime(candles, closes) {
      if (candles.length < 50) return { regime: 'unknown', strength: 0, details: {} };
      
      // Calcular EMAs para tendencia
      const ema20 = calcEMA(closes, 20);
      const ema50 = calcEMA(closes, 50);
      const currentPrice = closes[closes.length - 1];
      
      // Calcular ATR para volatilidad
      const atr = calcATR(candles, 14);
      const avgPrice = closes.slice(-20).reduce((a,b) => a+b, 0) / 20;
      const atrPercent = (atr / avgPrice) * 100;
      
      // Calcular ADX para fuerza de tendencia
      const adx = calcADX(candles, 14);
      
      // Analizar estructura de precios (higher highs, lower lows)
      let higherHighs = 0, lowerLows = 0;
      const recentCandles = candles.slice(-20);
      
      for (let i = 2; i < recentCandles.length; i++) {
        if (recentCandles[i].high > recentCandles[i-1].high && recentCandles[i-1].high > recentCandles[i-2].high) {
          higherHighs++;
        }
        if (recentCandles[i].low < recentCandles[i-1].low && recentCandles[i-1].low < recentCandles[i-2].low) {
          lowerLows++;
        }
      }
      
      // Calcular pendiente de precio
      const priceSlope = (closes[closes.length-1] - closes[closes.length-20]) / closes[closes.length-20] * 100;
      
      // Determinar rgimen
      let regime = 'ranging';
      let strength = 0;
      let details = {
        emaAlignment: ema20 > ema50 ? 'bullish' : 'bearish',
        atrPercent: atrPercent.toFixed(2),
        adxValue: adx ? adx.adx.toFixed(1) : 0,
        priceSlope: priceSlope.toFixed(2),
        higherHighs,
        lowerLows
      };
      
      // Alta volatilidad = mercado voltil
      if (atrPercent > 3) {
        regime = 'volatile';
        strength = Math.min(100, atrPercent * 20);
      }
      // ADX alto + estructura clara = tendencia
      else if (adx && adx.adx > 25) {
        if (ema20 > ema50 && higherHighs >= 3 && currentPrice > ema20) {
          regime = 'trending_up';
          strength = Math.min(100, adx.adx * 2 + higherHighs * 10);
        } else if (ema20 < ema50 && lowerLows >= 3 && currentPrice < ema20) {
          regime = 'trending_down';
          strength = Math.min(100, adx.adx * 2 + lowerLows * 10);
        } else if (adx.plusDI > adx.minusDI + 10) {
          regime = 'trending_up';
          strength = Math.min(100, (adx.plusDI - adx.minusDI) * 3);
        } else if (adx.minusDI > adx.plusDI + 10) {
          regime = 'trending_down';
          strength = Math.min(100, (adx.minusDI - adx.plusDI) * 3);
        }
      }
      // ADX bajo = rango/consolidacin
      else {
        regime = 'ranging';
        strength = Math.max(0, 100 - (adx ? adx.adx * 3 : 50));
      }
      
      aiState.priceAction = { higherHighs, lowerLows, swingHigh: Math.max(...recentCandles.map(c => c.high)), swingLow: Math.min(...recentCandles.map(c => c.low)) };
      
      return { regime, strength, details };
    }
    // ============================================
    // 2. SUPPORT & RESISTANCE DETECTION
    // ============================================
    
    function detectSupportResistance(candles) {
      if (candles.length < 50) return { supports: [], resistances: [] };
      
      const supports = [];
      const resistances = [];
      const lookback = Math.min(candles.length, 100);
      const recentCandles = candles.slice(-lookback);
      
      // Mtodo 1: Pivot Points
      const pivotCandles = recentCandles.slice(-20);
      for (let i = 2; i < pivotCandles.length - 2; i++) {
        const candle = pivotCandles[i];
        const prevHigh = Math.max(pivotCandles[i-1].high, pivotCandles[i-2].high);
        const nextHigh = Math.max(pivotCandles[i+1].high, pivotCandles[i+2].high);
        const prevLow = Math.min(pivotCandles[i-1].low, pivotCandles[i-2].low);
        const nextLow = Math.min(pivotCandles[i+1].low, pivotCandles[i+2].low);
        
        if (candle.high > prevHigh && candle.high > nextHigh) {
          resistances.push({ price: candle.high, strength: 1, type: 'pivot' });
        }
        if (candle.low < prevLow && candle.low < nextLow) {
          supports.push({ price: candle.low, strength: 1, type: 'pivot' });
        }
      }
      
      // Mtodo 2: Volume Profile (zonas de alto volumen)
      const priceRange = Math.max(...recentCandles.map(c => c.high)) - Math.min(...recentCandles.map(c => c.low));
      const bucketSize = priceRange / 20;
      const volumeProfile = {};
      
      recentCandles.forEach(c => {
        const bucket = Math.floor((c.close - Math.min(...recentCandles.map(x => x.low))) / bucketSize);
        volumeProfile[bucket] = (volumeProfile[bucket] || 0) + c.volume;
      });
      
      // Encontrar High Volume Nodes (HVN)
      const avgVolume = Object.values(volumeProfile).reduce((a,b) => a+b, 0) / Object.keys(volumeProfile).length;
      Object.entries(volumeProfile).forEach(([bucket, vol]) => {
        if (vol > avgVolume * 1.5) {
          const price = Math.min(...recentCandles.map(c => c.low)) + (parseInt(bucket) + 0.5) * bucketSize;
          const currentPrice = candles[candles.length-1].close;
          if (price < currentPrice) {
            supports.push({ price, strength: vol / avgVolume, type: 'volume' });
          } else {
            resistances.push({ price, strength: vol / avgVolume, type: 'volume' });
          }
        }
      });
      
      // Mtodo 3: Round Numbers (niveles psicolgicos)
      const currentPrice = candles[candles.length-1].close;
      const roundInterval = currentPrice > 1 ? 0.1 : currentPrice > 0.1 ? 0.01 : 0.001;
      const nearestRound = Math.round(currentPrice / roundInterval) * roundInterval;
      
      for (let i = -3; i <= 3; i++) {
        if (i === 0) continue;
        const level = nearestRound + (i * roundInterval);
        if (level < currentPrice) {
          supports.push({ price: level, strength: 0.5, type: 'psychological' });
        } else {
          resistances.push({ price: level, strength: 0.5, type: 'psychological' });
        }
      }
      
      // Consolidar niveles cercanos
      const consolidate = (levels) => {
        const consolidated = [];
        const sorted = levels.sort((a, b) => a.price - b.price);
        
        sorted.forEach(level => {
          const existing = consolidated.find(l => Math.abs(l.price - level.price) / level.price < 0.005);
          if (existing) {
            existing.strength += level.strength;
            existing.touches = (existing.touches || 1) + 1;
          } else {
            consolidated.push({ ...level, touches: 1 });
          }
        });
        
        return consolidated.sort((a, b) => b.strength - a.strength).slice(0, 5);
      };
      
      return {
        supports: consolidate(supports),
        resistances: consolidate(resistances)
      };
    }
    // ============================================
    // 3. CONFLUENCE ANALYSIS
    // ============================================
    
    function analyzeConfluence(indicators) {
      const bullishSignals = [];
      const bearishSignals = [];
      const neutralSignals = [];
      
      // RSI
      if (indicators.rsi !== null) {
        if (indicators.rsi < 30) bullishSignals.push({ name: 'RSI Oversold', weight: 1.5, value: indicators.rsi });
        else if (indicators.rsi > 70) bearishSignals.push({ name: 'RSI Overbought', weight: 1.5, value: indicators.rsi });
        else if (indicators.rsi > 50) bullishSignals.push({ name: 'RSI Bullish', weight: 0.5, value: indicators.rsi });
        else bearishSignals.push({ name: 'RSI Bearish', weight: 0.5, value: indicators.rsi });
      }
      
      // MACD
      if (indicators.macd) {
        if (indicators.macd.histogram > 0 && indicators.macd.macd > indicators.macd.signal) {
          bullishSignals.push({ name: 'MACD Bullish', weight: 1.3, value: indicators.macd.histogram });
        } else if (indicators.macd.histogram < 0 && indicators.macd.macd < indicators.macd.signal) {
          bearishSignals.push({ name: 'MACD Bearish', weight: 1.3, value: indicators.macd.histogram });
        }
        // MACD Crossover detection
        if (indicators.macdPrev && indicators.macd.macd > indicators.macd.signal && indicators.macdPrev.macd <= indicators.macdPrev.signal) {
          bullishSignals.push({ name: 'MACD Cross Up', weight: 2, value: 'crossover' });
        } else if (indicators.macdPrev && indicators.macd.macd < indicators.macd.signal && indicators.macdPrev.macd >= indicators.macdPrev.signal) {
          bearishSignals.push({ name: 'MACD Cross Down', weight: 2, value: 'crossover' });
        }
      }
      
      // EMA Cross
      if (indicators.emaFast && indicators.emaSlow) {
        if (indicators.emaFast > indicators.emaSlow) {
          bullishSignals.push({ name: 'EMA Bullish', weight: 1.2, value: (indicators.emaFast - indicators.emaSlow) / indicators.emaSlow * 100 });
        } else {
          bearishSignals.push({ name: 'EMA Bearish', weight: 1.2, value: (indicators.emaFast - indicators.emaSlow) / indicators.emaSlow * 100 });
        }
      }
      
      // Bollinger Bands
      if (indicators.bb) {
        if (indicators.currentPrice < indicators.bb.lower) {
          bullishSignals.push({ name: 'BB Oversold', weight: 1.4, value: 'below lower' });
        } else if (indicators.currentPrice > indicators.bb.upper) {
          bearishSignals.push({ name: 'BB Overbought', weight: 1.4, value: 'above upper' });
        }
      }
      
      // Stochastic RSI
      if (indicators.stochRSI !== null) {
        if (indicators.stochRSI < 20) bullishSignals.push({ name: 'StochRSI Oversold', weight: 1.1, value: indicators.stochRSI });
        else if (indicators.stochRSI > 80) bearishSignals.push({ name: 'StochRSI Overbought', weight: 1.1, value: indicators.stochRSI });
      }
      
      // Williams %R
      if (indicators.willR !== null) {
        if (indicators.willR < -80) bullishSignals.push({ name: 'Williams %R Oversold', weight: 0.9, value: indicators.willR });
        else if (indicators.willR > -20) bearishSignals.push({ name: 'Williams %R Overbought', weight: 0.9, value: indicators.willR });
      }
      
      // OBV Trend
      if (indicators.obv && indicators.obv.trend === 'bullish') {
        bullishSignals.push({ name: 'OBV Bullish', weight: 1.0, value: indicators.obv.obv });
      } else if (indicators.obv && indicators.obv.trend === 'bearish') {
        bearishSignals.push({ name: 'OBV Bearish', weight: 1.0, value: indicators.obv.obv });
      }
      
      // VWAP
      if (indicators.vwap) {
        if (indicators.currentPrice > indicators.vwap * 1.005) {
          bullishSignals.push({ name: 'Above VWAP', weight: 1.0, value: indicators.vwap });
        } else if (indicators.currentPrice < indicators.vwap * 0.995) {
          bearishSignals.push({ name: 'Below VWAP', weight: 1.0, value: indicators.vwap });
        }
      }
      
      // ADX Trend Strength
      if (indicators.adx && indicators.adx.adx > 25) {
        if (indicators.adx.plusDI > indicators.adx.minusDI) {
          bullishSignals.push({ name: 'ADX Bullish', weight: 1.3, value: indicators.adx.adx });
        } else {
          bearishSignals.push({ name: 'ADX Bearish', weight: 1.3, value: indicators.adx.adx });
        }
      }
      
      // RSI Divergence
      if (indicators.divergence === 'bullish') {
        bullishSignals.push({ name: 'RSI Bull Divergence', weight: 2.5, value: 'divergence' });
      } else if (indicators.divergence === 'bearish') {
        bearishSignals.push({ name: 'RSI Bear Divergence', weight: 2.5, value: 'divergence' });
      }
      
      // CVD
      if (indicators.cvd > 20000) bullishSignals.push({ name: 'CVD Bullish', weight: 0.8, value: indicators.cvd });
      else if (indicators.cvd < -20000) bearishSignals.push({ name: 'CVD Bearish', weight: 0.8, value: indicators.cvd });
      
      // Whale Flow
      if (indicators.whaleFlow > 100000) bullishSignals.push({ name: 'Whale Accumulation', weight: 1.5, value: indicators.whaleFlow });
      else if (indicators.whaleFlow < -100000) bearishSignals.push({ name: 'Whale Distribution', weight: 1.5, value: indicators.whaleFlow });
      
      // Candle Patterns
      if (indicators.patterns) {
        indicators.patterns.forEach(p => {
          if (p.type === 'bullish') bullishSignals.push({ name: p.name, weight: 0.7, value: 'pattern' });
          else if (p.type === 'bearish') bearishSignals.push({ name: p.name, weight: 0.7, value: 'pattern' });
        });
      }
      
      // Calcular peso total
      const bullWeight = bullishSignals.reduce((sum, s) => sum + s.weight, 0);
      const bearWeight = bearishSignals.reduce((sum, s) => sum + s.weight, 0);
      const totalWeight = bullWeight + bearWeight;
      
      // Calcular confluencia (seales en la misma direccin)
      const maxConfluence = Math.max(bullishSignals.length, bearishSignals.length);
      const confluenceRatio = maxConfluence / (bullishSignals.length + bearishSignals.length + neutralSignals.length || 1);
      
      return {
        bullishSignals,
        bearishSignals,
        neutralSignals,
        bullWeight,
        bearWeight,
        totalWeight,
        confluenceCount: maxConfluence,
        confluenceRatio,
        dominantDirection: bullWeight > bearWeight ? 'bullish' : bearWeight > bullWeight ? 'bearish' : 'neutral'
      };
    }
    // ============================================
    // 4. PROBABILITY CALCULATION
    // ============================================
    
    function calculateProbability(confluence, regime, srLevels, currentPrice, atr) {
      let baseProbBull = 50;
      let baseProbBear = 50;
      
      // Ajuste por confluencia de indicadores
      const totalWeight = confluence.totalWeight || 1;
      const bullRatio = confluence.bullWeight / totalWeight;
      const bearRatio = confluence.bearWeight / totalWeight;
      
      baseProbBull = bullRatio * 100;
      baseProbBear = bearRatio * 100;
      
      // Ajuste por rgimen de mercado
      if (regime.regime === 'trending_up') {
        baseProbBull += regime.strength * 0.15;
        baseProbBear -= regime.strength * 0.1;
      } else if (regime.regime === 'trending_down') {
        baseProbBear += regime.strength * 0.15;
        baseProbBull -= regime.strength * 0.1;
      } else if (regime.regime === 'volatile') {
        // En mercado voltil, reducir certeza
        baseProbBull = 50 + (baseProbBull - 50) * 0.7;
        baseProbBear = 50 + (baseProbBear - 50) * 0.7;
      }
      
      // Ajuste por proximidad a S/R
      if (srLevels.supports.length > 0) {
        const nearestSupport = srLevels.supports.reduce((a, b) => 
          Math.abs(b.price - currentPrice) < Math.abs(a.price - currentPrice) ? b : a
        );
        const distanceToSupport = (currentPrice - nearestSupport.price) / atr;
        
        if (distanceToSupport > 0 && distanceToSupport < 1) {
          // Cerca del soporte - ms probable rebote alcista
          baseProbBull += (1 - distanceToSupport) * 10 * nearestSupport.strength;
        }
      }
      
      if (srLevels.resistances.length > 0) {
        const nearestResistance = srLevels.resistances.reduce((a, b) => 
          Math.abs(b.price - currentPrice) < Math.abs(a.price - currentPrice) ? b : a
        );
        const distanceToResistance = (nearestResistance.price - currentPrice) / atr;
        
        if (distanceToResistance > 0 && distanceToResistance < 1) {
          // Cerca de resistencia - ms probable rechazo bajista
          baseProbBear += (1 - distanceToResistance) * 10 * nearestResistance.strength;
        }
      }
      
      // Ajuste por nmero de confluencias
      const confluenceBonus = Math.min(15, confluence.confluenceCount * 2);
      if (confluence.dominantDirection === 'bullish') {
        baseProbBull += confluenceBonus;
      } else if (confluence.dominantDirection === 'bearish') {
        baseProbBear += confluenceBonus;
      }
      
      // Normalizar a 100%
      const total = baseProbBull + baseProbBear;
      baseProbBull = (baseProbBull / total) * 100;
      baseProbBear = (baseProbBear / total) * 100;
      
      // Limitar extremos (nunca 100% o 0%)
      baseProbBull = Math.max(5, Math.min(95, baseProbBull));
      baseProbBear = 100 - baseProbBull;
      
      return {
        bullish: baseProbBull,
        bearish: baseProbBear,
        confidence: Math.abs(baseProbBull - 50) * 2 // 0-100, mayor = ms confianza
      };
    }
    // ============================================
    // 5. NOISE FILTER
    // ============================================
    
    function calculateNoiseLevel(candles, atr, volume) {
      if (candles.length < 20) return 50;
      
      const recentCandles = candles.slice(-20);
      
      // Factor 1: Relacin body/wick (muchas mechas = ruido)
      let wickRatio = 0;
      recentCandles.forEach(c => {
        const body = Math.abs(c.close - c.open);
        const totalRange = c.high - c.low;
        if (totalRange > 0) {
          wickRatio += (totalRange - body) / totalRange;
        }
      });
      wickRatio /= recentCandles.length;
      
      // Factor 2: Cambios de direccin frecuentes
      let directionChanges = 0;
      for (let i = 1; i < recentCandles.length; i++) {
        const prevDir = recentCandles[i-1].close > recentCandles[i-1].open ? 1 : -1;
        const currDir = recentCandles[i].close > recentCandles[i].open ? 1 : -1;
        if (prevDir !== currDir) directionChanges++;
      }
      const directionChangeRatio = directionChanges / (recentCandles.length - 1);
      
      // Factor 3: Volumen bajo = ms susceptible a ruido
      const avgVolume = recentCandles.reduce((sum, c) => sum + c.volume, 0) / recentCandles.length;
      const currentVolume = recentCandles[recentCandles.length - 1].volume;
      const volumeRatio = currentVolume / avgVolume;
      const lowVolumeNoise = volumeRatio < 0.5 ? 30 : volumeRatio < 0.8 ? 15 : 0;
      
      // Factor 4: ATR muy bajo = ruido de consolidacin
      const avgPrice = recentCandles.reduce((sum, c) => sum + c.close, 0) / recentCandles.length;
      const atrPercent = (atr / avgPrice) * 100;
      const lowVolatilityNoise = atrPercent < 0.5 ? 25 : atrPercent < 1 ? 10 : 0;
      
      // Calcular nivel de ruido total (0-100)
      const noiseLevel = Math.min(100, 
        (wickRatio * 40) + 
        (directionChangeRatio * 30) + 
        lowVolumeNoise + 
        lowVolatilityNoise
      );
      
      return {
        level: noiseLevel,
        isNoisy: noiseLevel > 50,
        factors: {
          wickRatio: (wickRatio * 100).toFixed(1) + '%',
          directionChanges: directionChangeRatio.toFixed(2),
          volumeRatio: volumeRatio.toFixed(2),
          atrPercent: atrPercent.toFixed(3) + '%'
        }
      };
    }
    // ============================================
    // 6. SIGNAL QUALITY SCORE
    // ============================================
    
    function calculateSignalQuality(confluence, regime, noise, probability) {
      let quality = 50;
      
      // +20 por alta confluencia
      if (confluence.confluenceCount >= 6) quality += 20;
      else if (confluence.confluenceCount >= 4) quality += 12;
      else if (confluence.confluenceCount >= 3) quality += 5;
      
      // +15 por rgimen claro
      if (regime.regime !== 'ranging' && regime.regime !== 'volatile' && regime.strength > 60) {
        quality += 15;
      } else if (regime.regime === 'volatile') {
        quality -= 10;
      }
      
      // -20 por ruido alto
      if (noise.level > 60) quality -= 20;
      else if (noise.level > 40) quality -= 10;
      else quality += 10;
      
      // +15 por probabilidad extrema
      if (probability.confidence > 70) quality += 15;
      else if (probability.confidence > 50) quality += 8;
      
      // +10 si hay divergencia RSI
      if (confluence.bullishSignals.some(s => s.name.includes('Divergence')) ||
          confluence.bearishSignals.some(s => s.name.includes('Divergence'))) {
        quality += 10;
      }
      
      return Math.max(0, Math.min(100, quality));
    }
    // ============================================
    // 7. PRICE TARGET CALCULATION
    // ============================================
    
    function calculatePriceTarget(currentPrice, atr, probability, regime, srLevels) {
      const direction = probability.bullish > probability.bearish ? 1 : -1;
      const confidence = probability.confidence / 100;
      
      // Base target: ATR-based
      let baseMove = atr * (0.5 + confidence);
      
      // Ajuste por rgimen
      if (regime.regime === 'trending_up' && direction > 0) {
        baseMove *= 1.3;
      } else if (regime.regime === 'trending_down' && direction < 0) {
        baseMove *= 1.3;
      } else if (regime.regime === 'ranging') {
        baseMove *= 0.6; // Movimientos ms pequeos en rango
      }
      
      let target = currentPrice + (baseMove * direction);
      
      // Ajustar target a niveles S/R cercanos
      if (direction > 0 && srLevels.resistances.length > 0) {
        const nearestResistance = srLevels.resistances.find(r => r.price > currentPrice);
        if (nearestResistance && nearestResistance.price < target) {
          target = nearestResistance.price * 0.998; // Justo antes de la resistencia
        }
      } else if (direction < 0 && srLevels.supports.length > 0) {
        const nearestSupport = srLevels.supports.find(s => s.price < currentPrice);
        if (nearestSupport && nearestSupport.price > target) {
          target = nearestSupport.price * 1.002; // Justo antes del soporte
        }
      }
      
      return {
        target,
        direction: direction > 0 ? 'bullish' : 'bearish',
        expectedMove: Math.abs(target - currentPrice),
        expectedMovePercent: Math.abs((target - currentPrice) / currentPrice * 100)
      };
    }
    // ============================================
    // MAIN AI ENGINE v2
    // ============================================
    function runPredictionEngine(currentPrice) {
      if (state.candles.length < 30) {
        ui.aiTarget.innerText = 'Collecting data...';
        return;
      }
      const closes = state.candles.map(c => c.close);
      
      // Store price history for divergence detection
      state.priceHistory.push(currentPrice);
      if (state.priceHistory.length > 50) state.priceHistory.shift();
      // ==========================================
      // PHASE 1: Calculate All Indicators
      // ==========================================
      
      const rsi = calcRSI(closes, CONFIG.RSI_PERIOD);
      if (rsi !== null) {
        state.rsiHistory.push(rsi);
        if (state.rsiHistory.length > 50) state.rsiHistory.shift();
      }
      
      const macd = calcMACD(closes);
      const stochRSI = calcStochRSI(closes, CONFIG.STOCH_PERIOD);
      const willR = calcWilliamsR(state.candles, CONFIG.WILLR_PERIOD);
      const bb = calcBollingerBands(closes, CONFIG.BB_PERIOD, CONFIG.BB_STD);
      const emaFast = calcEMA(closes, CONFIG.EMA_FAST);
      const emaSlow = calcEMA(closes, CONFIG.EMA_SLOW);
      const adx = calcADX(state.candles, CONFIG.ADX_PERIOD);
      const vwap = calcVWAP(state.candles);
      const obv = calcOBV(state.candles);
      const momentum = calcMomentum(closes, 10);
      const atr = calcATR(state.candles, CONFIG.ATR_PERIOD);
      const divergence = detectRSIDivergence(state.priceHistory, state.rsiHistory);
      const patterns = detectCandlePatterns(state.candles);
      const whaleFlow = state.whaleBuyVol - state.whaleSellVol;
      //  GOD MODE INDICATORS
      const ichimoku = calcIchimoku(state.candles);
      const supertrend = calcSupertrend(state.candles, 10, 3);
      const squeeze = calcSqueezeMomentum(state.candles);
      const cmf = calcCMF(state.candles, 20);
      const volumeProfile = calcVolumeProfile(state.candles, 20);
      const orderFlowImbalance = calcOrderFlowImbalance(state.candles);
      const marketStructure = calcMarketStructure(state.candles);
      const smartMoney = calcSmartMoneyConcepts(state.candles);
      const autoFibo = calcAutoFibonacci(state.candles, 50);
      const mtfAnalysis = analyzeMultiTimeframe(state.candles);
      const whaleImpact = calculateWhaleImpact();
      // ==========================================
      // PHASE 2: AI Analysis
      // ==========================================
      
      // 2.1 Detect Market Regime
      const regime = detectMarketRegime(state.candles, closes);
      aiState.marketRegime = regime.regime;
      aiState.regimeStrength = regime.strength;
      
      // 2.2 Detect Support/Resistance
      const srLevels = detectSupportResistance(state.candles);
      aiState.supportLevels = srLevels.supports;
      aiState.resistanceLevels = srLevels.resistances;
      
      // 2.3 Calculate Confluence
      const indicators = {
        rsi, macd, stochRSI, willR, bb, emaFast, emaSlow, adx, vwap, obv,
        momentum, divergence, patterns, currentPrice,
        cvd: state.cvd, whaleFlow
      };
      const confluence = analyzeConfluence(indicators);
      aiState.confluenceScore = confluence.confluenceCount;
      
      // 2.4 Calculate Noise Level
      const avgVol = state.candles.slice(-20).reduce((s,c) => s + c.volume, 0) / 20;
      const noise = calculateNoiseLevel(state.candles, atr || 0.001, avgVol);
      aiState.noiseLevel = noise.level;
      
      // 2.5 Calculate Probability
      const probability = calculateProbability(confluence, regime, srLevels, currentPrice, atr || 0.001);
      aiState.probabilityBull = probability.bullish;
      aiState.probabilityBear = probability.bearish;
      
      // 2.6 Calculate Signal Quality
      const signalQuality = calculateSignalQuality(confluence, regime, noise, probability);
      aiState.signalQuality = signalQuality;
      
      // 2.7 AI Learning Integration
      if (AILearning.isInitialized && signalQuality.score >= 20) {
        // DEBUG: Log learning conditions
        if (!window._aiDebugLogged || Date.now() - window._aiDebugLogged > 10000) {
          console.log('[AI-DEBUG] SignalQuality:', signalQuality.score, '| ProbBull:', aiState.probabilityBull?.toFixed(1), '| Deviation:', Math.abs(aiState.probabilityBull - 50).toFixed(1));
          window._aiDebugLogged = Date.now();
        }
        // Query pattern memory for boost
        const patternMatch = AILearning.queryPatterns({
          regime: regime.regime,
          indicators: {
            rsi: rsi / 100,
            macd: macd.histogram > 0 ? 1 : -1,
            stochRsi: stochRSI / 100,
            adx: adx / 100
          }
        });
        
        // Apply memory boost if pattern found
        if (patternMatch.found && patternMatch.confidence > 0.7) {
          const boost = patternMatch.confidence * 8;
          if (patternMatch.direction === 'BULL') {
            aiState.probabilityBull = Math.min(95, aiState.probabilityBull + boost);
            aiState.probabilityBear = 100 - aiState.probabilityBull;
          } else {
            aiState.probabilityBear = Math.min(95, aiState.probabilityBear + boost);
            aiState.probabilityBull = 100 - aiState.probabilityBear;
          }
          aiState.memoryBoost = true;
        }
        
        // Record prediction for learning (only significant signals)
        if (Math.abs(aiState.probabilityBull - 50) > 2) {
          const direction = aiState.probabilityBull > 50 ? 'BULL' : 'BEAR';
          console.log('[AI-DEBUG] Recording prediction:', direction, '| Prob:', Math.max(aiState.probabilityBull, aiState.probabilityBear).toFixed(1));
          AILearning.recordPrediction({
            direction,
            probability: Math.max(aiState.probabilityBull, aiState.probabilityBear),
            regime: regime.regime,
            indicators: {
              rsi: rsi,
              macd: macd.histogram > 0 ? 'bull' : 'bear',
              stoch_rsi: stochRSI,
              adx: adx,
              divergence: divergence || 'none',
              ema_cross: ema9 > ema21 ? 'bull' : 'bear'
            }
          });
        }
      }
      
      // 2.8 Calculate Price Target
      const priceTarget = calculatePriceTarget(currentPrice, atr || 0.001, probability, regime, srLevels);
      // ==========================================
      // PHASE 3: Update UI - Indicators
      // ==========================================
      
      // RSI
      if (rsi !== null) {
        document.getElementById('rsiValue').innerText = rsi.toFixed(1);
        const rsiEl = document.getElementById('rsiSignal');
        if (rsi > 70) { rsiEl.className = 'indicator-signal signal-sell'; rsiEl.innerText = 'OVERBOUGHT'; }
        else if (rsi < 30) { rsiEl.className = 'indicator-signal signal-buy'; rsiEl.innerText = 'OVERSOLD'; }
        else { rsiEl.className = 'indicator-signal signal-neutral'; rsiEl.innerText = 'NEUTRAL'; }
      }
      // RSI Divergence
      const divEl = document.getElementById('divSignal');
      const divValEl = document.getElementById('divValue');
      if (divergence === 'bullish') {
        divEl.className = 'indicator-signal signal-buy'; divEl.innerText = 'BULLISH';
        divValEl.innerText = ' DETECTED';
        ui.divergenceBadge.style.display = 'block';
        ui.divergenceBadge.className = 'divergence-badge div-bullish';
        ui.divergenceBadge.innerText = ' BULL DIV';
        // Voice alert for divergence
        if (aiState.lastDivergence !== 'bullish') {
          voiceAlertDivergence('Bullish');
          aiState.lastDivergence = 'bullish';
        }
      } else if (divergence === 'bearish') {
        divEl.className = 'indicator-signal signal-sell'; divEl.innerText = 'BEARISH';
        divValEl.innerText = ' DETECTED';
        ui.divergenceBadge.style.display = 'block';
        ui.divergenceBadge.className = 'divergence-badge div-bearish';
        ui.divergenceBadge.innerText = ' BEAR DIV';
        // Voice alert for divergence
        if (aiState.lastDivergence !== 'bearish') {
          voiceAlertDivergence('Bearish');
          aiState.lastDivergence = 'bearish';
        }
      } else {
        divEl.className = 'indicator-signal signal-neutral'; divEl.innerText = 'NONE';
        divValEl.innerText = 'No signal';
        ui.divergenceBadge.style.display = 'none';
        aiState.lastDivergence = null;
      }
      // MACD
      if (macd.macd !== null) {
        document.getElementById('macdValue').innerText = macd.histogram.toFixed(5);
        const macdEl = document.getElementById('macdSignal');
        if (macd.histogram > 0 && macd.macd > macd.signal) {
          macdEl.className = 'indicator-signal signal-buy'; macdEl.innerText = 'BULLISH';
        } else if (macd.histogram < 0 && macd.macd < macd.signal) {
          macdEl.className = 'indicator-signal signal-sell'; macdEl.innerText = 'BEARISH';
        } else {
          macdEl.className = 'indicator-signal signal-neutral'; macdEl.innerText = 'CROSSING';
        }
      }
      // Stochastic RSI
      if (stochRSI !== null) {
        document.getElementById('stochValue').innerText = stochRSI.toFixed(1);
        const stochEl = document.getElementById('stochSignal');
        if (stochRSI > 80) { stochEl.className = 'indicator-signal signal-sell'; stochEl.innerText = 'OVERBOUGHT'; }
        else if (stochRSI < 20) { stochEl.className = 'indicator-signal signal-buy'; stochEl.innerText = 'OVERSOLD'; }
        else { stochEl.className = 'indicator-signal signal-neutral'; stochEl.innerText = 'NEUTRAL'; }
      }
      // Williams %R
      if (willR !== null) {
        document.getElementById('willrValue').innerText = willR.toFixed(1);
        const willEl = document.getElementById('willrSignal');
        if (willR > -20) { willEl.className = 'indicator-signal signal-sell'; willEl.innerText = 'OVERBOUGHT'; }
        else if (willR < -80) { willEl.className = 'indicator-signal signal-buy'; willEl.innerText = 'OVERSOLD'; }
        else { willEl.className = 'indicator-signal signal-neutral'; willEl.innerText = 'NEUTRAL'; }
      }
      // Bollinger Bands
      if (bb) {
        const bbPosition = ((currentPrice - bb.lower) / (bb.upper - bb.lower)) * 100;
        document.getElementById('bbValue').innerText = bbPosition.toFixed(0) + '%';
        const bbEl = document.getElementById('bbSignal');
        if (currentPrice > bb.upper) { bbEl.className = 'indicator-signal signal-sell'; bbEl.innerText = 'ABOVE'; }
        else if (currentPrice < bb.lower) { bbEl.className = 'indicator-signal signal-buy'; bbEl.innerText = 'BELOW'; }
        else { bbEl.className = 'indicator-signal signal-neutral'; bbEl.innerText = 'IN BAND'; }
      }
      // EMA Cross
      if (emaFast && emaSlow) {
        const emaDiff = ((emaFast - emaSlow) / emaSlow) * 100;
        document.getElementById('emaValue').innerText = emaDiff.toFixed(3) + '%';
        const emaEl = document.getElementById('emaSignal');
        if (emaFast > emaSlow && currentPrice > emaFast) {
          emaEl.className = 'indicator-signal signal-buy'; emaEl.innerText = 'BULLISH';
        } else if (emaFast < emaSlow && currentPrice < emaFast) {
          emaEl.className = 'indicator-signal signal-sell'; emaEl.innerText = 'BEARISH';
        } else {
          emaEl.className = 'indicator-signal signal-neutral'; emaEl.innerText = 'MIXED';
        }
      }
      // ADX
      if (adx) {
        document.getElementById('adxValue').innerText = adx.adx.toFixed(1);
        const adxEl = document.getElementById('adxSignal');
        if (adx.adx > 25) {
          if (adx.plusDI > adx.minusDI) { adxEl.className = 'indicator-signal signal-buy'; adxEl.innerText = 'STRONG '; }
          else { adxEl.className = 'indicator-signal signal-sell'; adxEl.innerText = 'STRONG '; }
        } else {
          adxEl.className = 'indicator-signal signal-neutral'; adxEl.innerText = 'WEAK';
        }
      }
      // VWAP
      if (vwap) {
        document.getElementById('vwapValue').innerText = vwap.toFixed(4);
        const vwapEl = document.getElementById('vwapSignal');
        if (currentPrice > vwap * 1.002) { vwapEl.className = 'indicator-signal signal-buy'; vwapEl.innerText = 'ABOVE'; }
        else if (currentPrice < vwap * 0.998) { vwapEl.className = 'indicator-signal signal-sell'; vwapEl.innerText = 'BELOW'; }
        else { vwapEl.className = 'indicator-signal signal-neutral'; vwapEl.innerText = 'AT VWAP'; }
      }
      // OBV
      document.getElementById('obvValue').innerText = (obv.obv / 1000000).toFixed(2) + 'M';
      const obvEl = document.getElementById('obvSignal');
      if (obv.trend === 'bullish') { obvEl.className = 'indicator-signal signal-buy'; obvEl.innerText = 'BULLISH'; }
      else if (obv.trend === 'bearish') { obvEl.className = 'indicator-signal signal-sell'; obvEl.innerText = 'BEARISH'; }
      else { obvEl.className = 'indicator-signal signal-neutral'; obvEl.innerText = 'NEUTRAL'; }
      // Momentum
      if (momentum !== null) {
        document.getElementById('momValue').innerText = momentum.toFixed(2) + '%';
        const momEl = document.getElementById('momSignal');
        if (momentum > 0.5) { momEl.className = 'indicator-signal signal-buy'; momEl.innerText = 'POSITIVE'; }
        else if (momentum < -0.5) { momEl.className = 'indicator-signal signal-sell'; momEl.innerText = 'NEGATIVE'; }
        else { momEl.className = 'indicator-signal signal-neutral'; momEl.innerText = 'FLAT'; }
      }
      // CVD
      const cvdEl = document.getElementById('cvdSignal');
      document.getElementById('cvdValue').innerText = (state.cvd / 1000).toFixed(1) + 'K';
      if (state.cvd > 10000) { cvdEl.className = 'indicator-signal signal-buy'; cvdEl.innerText = 'BUYING'; }
      else if (state.cvd < -10000) { cvdEl.className = 'indicator-signal signal-sell'; cvdEl.innerText = 'SELLING'; }
      else { cvdEl.className = 'indicator-signal signal-neutral'; cvdEl.innerText = 'NEUTRAL'; }
      // Whale Flow
      const whaleFlowEl = document.getElementById('whaleFlowSignal');
      document.getElementById('whaleFlowValue').innerText = (whaleFlow / 1000).toFixed(0) + 'K';
      if (whaleFlow > 100000) { whaleFlowEl.className = 'indicator-signal signal-buy'; whaleFlowEl.innerText = 'ACCUMULATING'; }
      else if (whaleFlow < -100000) { whaleFlowEl.className = 'indicator-signal signal-sell'; whaleFlowEl.innerText = 'DISTRIBUTING'; }
      else { whaleFlowEl.className = 'indicator-signal signal-neutral'; whaleFlowEl.innerText = 'NEUTRAL'; }
      // ATR Levels
      if (atr) {
        document.getElementById('r2').innerText = (currentPrice + atr * 2).toFixed(4);
        document.getElementById('r1').innerText = (currentPrice + atr).toFixed(4);
        document.getElementById('currentLevel').innerText = currentPrice.toFixed(4);
        document.getElementById('s1').innerText = (currentPrice - atr).toFixed(4);
        document.getElementById('s2').innerText = (currentPrice - atr * 2).toFixed(4);
      }
      // Candle Patterns
      if (patterns.length > 0) {
        ui.patternsContainer.innerHTML = patterns.map(p => 
          `<span class="pattern-tag" style="color:${p.type === 'bullish' ? 'var(--accent-green)' : (p.type === 'bearish' ? 'var(--accent-red)' : 'var(--accent-purple)')}">${p.name}</span>`
        ).join('');
      } else {
        ui.patternsContainer.innerHTML = '<span style="color:var(--text-dim); font-size:10px;">No patterns</span>';
      }
      // ==========================================
      // PHASE 4: Update AI Dashboard
      // ==========================================
      
      // Track prediction for accuracy
      trackPrediction(priceTarget.target, currentPrice);
      // Main Target Display
      ui.aiTarget.innerText = '$ ' + priceTarget.target.toFixed(4);
      ui.aiTarget.style.color = priceTarget.direction === 'bullish' ? 'var(--accent-green)' : 'var(--accent-red)';
      
      // Confidence (now based on probability)
      ui.conf.innerText = probability.confidence.toFixed(0) + '%';
      // Score Bar (based on probability)
      const normalizedScore = probability.bullish;
      const fillWidth = Math.abs(normalizedScore - 50);
      const fillColor = normalizedScore > 50 ? 'var(--accent-green)' : 'var(--accent-red)';
      const fillLeft = normalizedScore > 50 ? '50%' : (50 - fillWidth) + '%';
      
      ui.scoreFill.style.width = fillWidth + '%';
      ui.scoreFill.style.left = fillLeft;
      ui.scoreFill.style.background = fillColor;
      // Signal Counts
      ui.bullCount.innerText = confluence.bullishSignals.length;
      ui.neutCount.innerText = confluence.neutralSignals.length;
      ui.bearCount.innerText = confluence.bearishSignals.length;
      // Total Score (Signal Quality)
      ui.totalScore.innerText = signalQuality.toFixed(0) + '/100';
      ui.totalScore.style.color = signalQuality > 70 ? 'var(--accent-green)' : (signalQuality > 40 ? 'var(--accent-orange)' : 'var(--accent-red)');
      // Consensus with Probability
      const probBull = probability.bullish;
      if (probBull >= 70 && signalQuality >= 60) {
        ui.consensus.innerText = `STRONG BULL ${probBull.toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-green)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} signals aligned  ${regime.regime.replace('_', ' ').toUpperCase()}`;
      } else if (probBull >= 55) {
        ui.consensus.innerText = `BULLISH ${probBull.toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-green)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} confluences  Quality: ${signalQuality.toFixed(0)}%`;
      } else if (probBull <= 30 && signalQuality >= 60) {
        ui.consensus.innerText = `STRONG BEAR ${(100-probBull).toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-red)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} signals aligned  ${regime.regime.replace('_', ' ').toUpperCase()}`;
      } else if (probBull <= 45) {
        ui.consensus.innerText = `BEARISH ${(100-probBull).toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-red)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} confluences  Quality: ${signalQuality.toFixed(0)}%`;
      } else {
        ui.consensus.innerText = 'NEUTRAL 50%';
        ui.consensus.style.color = 'var(--accent-orange)';
        ui.scoreLabel.innerText = noise.isNoisy ? ' Noisy market - wait for clarity' : 'Mixed signals - no clear direction';
      }
      // ==========================================
      // PHASE 5: Update AI v2 Dashboard Elements
      // ==========================================
      
      // Market Regime Display
      if (ui.marketRegime) {
        const regimeNames = {
          'trending_up': ' TRENDING UP',
          'trending_down': ' TRENDING DOWN',
          'ranging': ' RANGING',
          'volatile': ' VOLATILE',
          'unknown': ' ANALYZING'
        };
        const regimeColors = {
          'trending_up': 'var(--accent-green)',
          'trending_down': 'var(--accent-red)',
          'ranging': 'var(--accent-orange)',
          'volatile': 'var(--accent-purple)',
          'unknown': 'var(--text-dim)'
        };
        ui.marketRegime.innerText = regimeNames[regime.regime] || regime.regime.toUpperCase();
        ui.marketRegime.style.color = regimeColors[regime.regime] || 'var(--accent-cyan)';
      }
      
      // Signal Quality
      if (ui.signalQuality) {
        ui.signalQuality.innerText = signalQuality.toFixed(0) + '%';
        ui.signalQuality.style.color = signalQuality >= 70 ? 'var(--accent-green)' : signalQuality >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';
      }
      
      // Probability Display
      if (ui.probBull) {
        ui.probBull.innerText = probability.bullish.toFixed(0) + '%';
        ui.probBull.style.color = probability.bullish >= 60 ? 'var(--accent-green)' : 'var(--text-dim)';
      }
      if (ui.probBear) {
        ui.probBear.innerText = probability.bearish.toFixed(0) + '%';
        ui.probBear.style.color = probability.bearish >= 60 ? 'var(--accent-red)' : 'var(--text-dim)';
      }
      
      // Confluence Count
      if (ui.confluenceCount) {
        ui.confluenceCount.innerText = confluence.confluenceCount;
        ui.confluenceCount.style.color = confluence.confluenceCount >= 6 ? 'var(--accent-green)' : confluence.confluenceCount >= 4 ? 'var(--accent-cyan)' : 'var(--accent-purple)';
      }
      
      // Noise Level
      if (ui.noiseLevel) {
        ui.noiseLevel.innerText = noise.level.toFixed(0) + '%';
        ui.noiseLevel.style.color = noise.level > 60 ? 'var(--accent-red)' : noise.level > 40 ? 'var(--accent-orange)' : 'var(--accent-green)';
      }
      
      // ==========================================
      //  GOD MODE UI UPDATES
      // ==========================================
      
      // Multi-Timeframe Display
      const updateMTFBox = (id, data) => {
        const box = document.getElementById(id);
        if (box) {
          const valueSpan = box.querySelector('span:last-child');
          if (valueSpan) {
            if (data.signal === 'bullish') {
              valueSpan.innerText = 'â–²';
              valueSpan.style.color = 'var(--accent-green)';
            } else if (data.signal === 'bearish') {
              valueSpan.innerText = 'â–¼';
              valueSpan.style.color = 'var(--accent-red)';
            } else {
              valueSpan.innerText = 'â—';
              valueSpan.style.color = 'var(--text-dim)';
            }
          }
        }
      };
      
      updateMTFBox('mtf1m', mtfAnalysis.tf1m);
      updateMTFBox('mtf5m', mtfAnalysis.tf5m);
      updateMTFBox('mtf15m', mtfAnalysis.tf15m);
      updateMTFBox('mtf1h', mtfAnalysis.tf1h);
      
      const mtfScoreBox = document.getElementById('mtfScore');
      if (mtfScoreBox) {
        const scoreSpan = mtfScoreBox.querySelector('span');
        if (scoreSpan) {
          scoreSpan.innerText = mtfAnalysis.confluence + '/4';
          scoreSpan.style.color = mtfAnalysis.confluence >= 3 ? 'var(--accent-green)' : mtfAnalysis.confluence >= 2 ? 'var(--accent-cyan)' : 'var(--accent-purple)';
        }
      }
      
      // Whale Impact
      const whaleImpactEl = document.getElementById('whaleImpact');
      if (whaleImpactEl) {
        whaleImpactEl.innerText = whaleImpact >= 0 ? '+' + whaleImpact : whaleImpact;
        whaleImpactEl.style.color = whaleImpact > 20 ? 'var(--accent-green)' : whaleImpact < -20 ? 'var(--accent-red)' : 'var(--accent-cyan)';
      }
      
      // Smart Money Concepts Display
      const smcOB = document.getElementById('smcOB');
      const smcFVG = document.getElementById('smcFVG');
      const smcLiq = document.getElementById('smcLiq');
      const smcStruct = document.getElementById('smcStruct');
      
      if (smcOB && smartMoney.nearestOB) {
        smcOB.innerText = smartMoney.nearestOB.type === 'bullish' ? ' BUY' : ' SELL';
        smcOB.style.color = smartMoney.nearestOB.type === 'bullish' ? 'var(--accent-green)' : 'var(--accent-red)';
      } else if (smcOB) {
        smcOB.innerText = 'NONE';
        smcOB.style.color = 'var(--text-dim)';
      }
      
      if (smcFVG && smartMoney.nearestFVG) {
        smcFVG.innerText = smartMoney.nearestFVG.type === 'bullish' ? ' GAP' : ' GAP';
        smcFVG.style.color = smartMoney.nearestFVG.type === 'bullish' ? 'var(--accent-green)' : 'var(--accent-red)';
      } else if (smcFVG) {
        smcFVG.innerText = 'NONE';
        smcFVG.style.color = 'var(--text-dim)';
      }
      
      if (smcLiq && smartMoney.liquidity.length > 0) {
        const nearestLiq = smartMoney.liquidity[0];
        smcLiq.innerText = nearestLiq.type === 'buy_side' ? 'BUY $' + nearestLiq.price.toFixed(3) : 'SELL $' + nearestLiq.price.toFixed(3);
        smcLiq.style.color = nearestLiq.type === 'buy_side' ? 'var(--accent-green)' : 'var(--accent-red)';
      } else if (smcLiq) {
        smcLiq.innerText = 'NONE';
        smcLiq.style.color = 'var(--text-dim)';
      }
      
      if (smcStruct && marketStructure) {
        const structNames = {
          'uptrend': ' UPTREND',
          'downtrend': ' DOWNTREND',
          'ranging': ' RANGE',
          'expanding': ' EXPAND',
          'contracting': ' CONTRACT'
        };
        smcStruct.innerText = structNames[marketStructure.structure] || marketStructure.structure;
        smcStruct.style.color = marketStructure.structure === 'uptrend' ? 'var(--accent-green)' : 
                               marketStructure.structure === 'downtrend' ? 'var(--accent-red)' : 'var(--accent-orange)';
      }
      
      // Advanced Tab Indicators
      // Ichimoku
      const ichiValue = document.getElementById('ichiValue');
      const ichiSignal = document.getElementById('ichiSignal');
      if (ichiValue && ichiSignal && ichimoku) {
        ichiValue.innerText = ichimoku.signal === 'bullish' ? 'Above Cloud' : ichimoku.signal === 'bearish' ? 'Below Cloud' : 'In Cloud';
        ichiSignal.className = 'indicator-signal ' + (ichimoku.signal === 'bullish' ? 'signal-buy' : ichimoku.signal === 'bearish' ? 'signal-sell' : 'signal-neutral');
        ichiSignal.innerText = ichimoku.signal.toUpperCase();
      }
      
      // Fibonacci
      const fiboValue = document.getElementById('fiboValue');
      const fiboSignal = document.getElementById('fiboSignal');
      if (fiboValue && fiboSignal && autoFibo) {
        fiboValue.innerText = autoFibo.nearest.name;
        const nearSupport = autoFibo.nearest.name === '61.8%' || autoFibo.nearest.name === '78.6%';
        const nearResist = autoFibo.nearest.name === '23.6%' || autoFibo.nearest.name === '38.2%';
        fiboSignal.className = 'indicator-signal ' + (nearSupport ? 'signal-buy' : nearResist ? 'signal-sell' : 'signal-neutral');
        fiboSignal.innerText = nearSupport ? 'SUPPORT' : nearResist ? 'RESIST' : 'MID';
      }
      
      // Volume Profile
      const vpValue = document.getElementById('vpValue');
      const vpSignal = document.getElementById('vpSignal');
      if (vpValue && vpSignal && volumeProfile) {
        vpValue.innerText = volumeProfile.currentVsProfile === 'above_poc' ? 'Above POC' : 'Below POC';
        vpSignal.className = 'indicator-signal ' + (volumeProfile.currentVsProfile === 'above_poc' ? 'signal-buy' : 'signal-sell');
        vpSignal.innerText = volumeProfile.currentVsProfile === 'above_poc' ? 'BULLISH' : 'BEARISH';
      }
      
      // Order Flow Imbalance
      const ofiValue = document.getElementById('ofiValue');
      const ofiSignal = document.getElementById('ofiSignal');
      if (ofiValue && ofiSignal && orderFlowImbalance) {
        ofiValue.innerText = orderFlowImbalance.imbalance.toFixed(0) + '%';
        ofiSignal.className = 'indicator-signal ' + (orderFlowImbalance.signal === 'bullish' ? 'signal-buy' : orderFlowImbalance.signal === 'bearish' ? 'signal-sell' : 'signal-neutral');
        ofiSignal.innerText = orderFlowImbalance.signal.toUpperCase();
      }
      
      // Market Structure
      const structValue = document.getElementById('structValue');
      const structSignal = document.getElementById('structSignal');
      if (structValue && structSignal && marketStructure) {
        structValue.innerText = marketStructure.structure;
        structSignal.className = 'indicator-signal ' + (marketStructure.structure === 'uptrend' ? 'signal-buy' : marketStructure.structure === 'downtrend' ? 'signal-sell' : 'signal-neutral');
        structSignal.innerText = marketStructure.structure === 'uptrend' ? 'BULLISH' : marketStructure.structure === 'downtrend' ? 'BEARISH' : 'NEUTRAL';
      }
      
      // Whale Order Book
      const whaleOBValue = document.getElementById('whaleOBValue');
      const whaleOBSignal = document.getElementById('whaleOBSignal');
      if (whaleOBValue && whaleOBSignal) {
        const obDelta = state.bidWall - state.askWall;
        whaleOBValue.innerText = (obDelta / 1000).toFixed(0) + 'K';
        whaleOBSignal.className = 'indicator-signal ' + (obDelta > 50000 ? 'signal-buy' : obDelta < -50000 ? 'signal-sell' : 'signal-neutral');
        whaleOBSignal.innerText = obDelta > 50000 ? 'BID WALL' : obDelta < -50000 ? 'ASK WALL' : 'BALANCED';
      }
      
      // Squeeze Momentum
      const squeezeValue = document.getElementById('squeezeValue');
      const squeezeSignal = document.getElementById('squeezeSignal');
      if (squeezeValue && squeezeSignal && squeeze) {
        squeezeValue.innerText = squeeze.squeezeOn ? 'ðŸ”¥ ON' : 'â„ï¸ OFF';
        squeezeSignal.className = 'indicator-signal ' + (squeeze.signal.includes('bull') ? 'signal-buy' : squeeze.signal.includes('bear') ? 'signal-sell' : 'signal-neutral');
        squeezeSignal.innerText = squeeze.squeezeOn ? 'BUILDING' : squeeze.signal.includes('bull') ? 'BULLISH' : squeeze.signal.includes('bear') ? 'BEARISH' : 'NEUTRAL';
      }
      
      // Supertrend
      const strendValue = document.getElementById('strendValue');
      const strendSignal = document.getElementById('strendSignal');
      if (strendValue && strendSignal && supertrend) {
        strendValue.innerText = supertrend.value.toFixed(4);
        strendSignal.className = 'indicator-signal ' + (supertrend.trend === 'bullish' ? 'signal-buy' : 'signal-sell');
        strendSignal.innerText = supertrend.trend.toUpperCase();
      }
      
      // Chaikin Money Flow
      const cmfValue = document.getElementById('cmfValue');
      const cmfSignal = document.getElementById('cmfSignal');
      if (cmfValue && cmfSignal && cmf !== null) {
        cmfValue.innerText = (cmf * 100).toFixed(1) + '%';
        cmfSignal.className = 'indicator-signal ' + (cmf > 0.05 ? 'signal-buy' : cmf < -0.05 ? 'signal-sell' : 'signal-neutral');
        cmfSignal.innerText = cmf > 0.05 ? 'INFLOW' : cmf < -0.05 ? 'OUTFLOW' : 'NEUTRAL';
      }
      
      // ==========================================
      //  TRADING SIGNAL BOX (Entry/SL/TP)
      // ==========================================
      
      const tradingSignalBox = document.getElementById('tradingSignalBox');
      const godModeConfluence = confluence.confluenceCount + mtfAnalysis.confluence;
      
      // Generate trading signal if conditions met
      if (signalQuality >= 65 && godModeConfluence >= 6 && tradingSignalBox) {
        const tradingSignal = generateTradingSignal(currentPrice, atr, probability.bullish > 50 ? probability.bullish : probability.bearish, regime.regime, { confluence: godModeConfluence });
        
        if (tradingSignal) {
          tradingSignalBox.style.display = 'block';
          
          const dirEl = document.getElementById('signalDirection');
          const entryEl = document.getElementById('signalEntry');
          const slEl = document.getElementById('signalSL');
          const tp1El = document.getElementById('signalTP1');
          const tp2El = document.getElementById('signalTP2');
          const rrEl = document.getElementById('signalRR');
          const riskEl = document.getElementById('signalRisk');
          const rewardEl = document.getElementById('signalReward');
          const winRateEl = document.getElementById('signalWinRate');
          
          if (dirEl) {
            dirEl.innerText = tradingSignal.direction === 'LONG' ? ' LONG SIGNAL' : ' SHORT SIGNAL';
            dirEl.style.color = tradingSignal.direction === 'LONG' ? 'var(--accent-green)' : 'var(--accent-red)';
            tradingSignalBox.style.borderColor = tradingSignal.direction === 'LONG' ? 'rgba(0,255,136,0.3)' : 'rgba(255,68,102,0.3)';
          }
          if (entryEl) entryEl.innerText = '$' + tradingSignal.entry.toFixed(4);
          if (slEl) slEl.innerText = '$' + tradingSignal.stopLoss.toFixed(4);
          if (tp1El) tp1El.innerText = '$' + tradingSignal.tp1.toFixed(4);
          if (tp2El) tp2El.innerText = '$' + tradingSignal.tp2.toFixed(4);
          if (rrEl) rrEl.innerText = 'R:R 1:' + tradingSignal.riskReward.toFixed(1);
          if (riskEl) riskEl.innerText = '-' + tradingSignal.risk.toFixed(2) + '%';
          if (rewardEl) rewardEl.innerText = '+' + tradingSignal.reward.toFixed(2) + '%';
          if (winRateEl) winRateEl.innerText = tradingSignal.estimatedWinRate.toFixed(0) + '%';
        }
      } else if (tradingSignalBox) {
        tradingSignalBox.style.display = 'none';
      }
      // Update S/R and Fibonacci on chart
      updateSROnChart();
      updateFibonacciLevels();
      // Alert and log high-quality signals
      if (signalQuality >= 70 && probability.confidence >= 55) {
        const direction = probability.bullish > 50 ? 'BULL' : 'BEAR';
        const alertType = probability.bullish > 50 ? 'bullish' : 'bearish';
        const prob = probability.bullish > 50 ? probability.bullish : probability.bearish;
        
        // Log signal to history
        logSignal(direction, prob, signalQuality, currentPrice, regime.regime);
        
        // Only alert on very high quality signals
        if (signalQuality >= 75 && probability.confidence >= 60) {
          addAlert(` HIGH QUALITY ${direction} SIGNAL: ${prob.toFixed(0)}% prob, ${signalQuality.toFixed(0)}% quality`, alertType);
          
          //  AI Voice Alert
          const voiceText = generateSignalVoiceText(direction, prob, signalQuality, regime.regime);
          speakAlert(voiceText, 'high');
        }
      }
      
      // Update Paper Trading UI
      updatePaperTradingUI();
      
      // Update AI Narrator
      updateNarratorUI();
    }
    // ============================================
    // API CALLS
    // ============================================
    async function fetchFearGreed() {
      try {
        const response = await fetch('https://api.alternative.me/fng/?limit=1');
        const data = await response.json();
        if (data?.data?.[0]) {
          const fng = data.data[0];
          ui.fg.innerText = fng.value;
          ui.fgLabel.innerText = fng.value_classification;
          const val = parseInt(fng.value);
          ui.fg.style.color = val <= 25 ? 'var(--accent-red)' : val <= 45 ? 'var(--accent-orange)' : val <= 55 ? 'var(--text-main)' : val <= 75 ? '#90EE90' : 'var(--accent-green)';
        }
      } catch (err) {
        console.error('Fear & Greed error:', err);
      }
    }
    async function fetchDerivativesData() {
      try {
        // Funding Rate
        const fundingRes = await fetch('https://fapi.binance.com/fapi/v1/fundingRate?symbol=XRPUSDT&limit=1');
        const fundingData = await fundingRes.json();
        if (fundingData?.[0]) {
          const rate = parseFloat(fundingData[0].fundingRate) * 100;
          if (ui.fundingRate) {
            ui.fundingRate.innerText = rate.toFixed(4) + '%';
            ui.fundingRate.style.color = rate > 0 ? 'var(--accent-green)' : 'var(--accent-red)';
          }
          
          if (Math.abs(rate) > 0.1) {
            addAlert(`High Funding Rate: ${rate.toFixed(4)}% - ${rate > 0 ? 'Longs paying shorts' : 'Shorts paying longs'}`, rate > 0 ? 'warning' : 'info');
          }
        }
        // Open Interest
        const oiRes = await fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=XRPUSDT');
        const oiData = await oiRes.json();
        if (oiData?.openInterest) {
          const oi = parseFloat(oiData.openInterest);
          if (ui.openInterest) {
            ui.openInterest.innerText = (oi / 1000000).toFixed(1) + 'M';
          }
        }
        // Long/Short Ratio
        const lsRes = await fetch('https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=XRPUSDT&period=5m&limit=1');
        const lsData = await lsRes.json();
        if (lsData?.[0]) {
          const ratio = parseFloat(lsData[0].longShortRatio);
          const _lsValueEl = document.getElementById('lsValue');
          if (_lsValueEl) _lsValueEl.innerText = ratio.toFixed(2);
          
          const lsEl = document.getElementById('lsSignal');
          if (!lsEl) return;
          if (ratio > 1.5) {
            lsEl.className = 'indicator-signal signal-warning'; lsEl.innerText = 'CROWDED LONG';
          } else if (ratio < 0.7) {
            lsEl.className = 'indicator-signal signal-warning'; lsEl.innerText = 'CROWDED SHORT';
          } else if (ratio > 1) {
            lsEl.className = 'indicator-signal signal-buy'; lsEl.innerText = 'LONG BIAS';
          } else {
            lsEl.className = 'indicator-signal signal-sell'; lsEl.innerText = 'SHORT BIAS';
          }
        }
      } catch (err) {
        console.error('Derivatives fetch error:', err);
      }
    }
    async function fetchBTCPrice() {
      try {
        const res = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');
        const data = await res.json();
        if (data?.price) {
          state.btcPrice = parseFloat(data.price);
          ui.btcPrice.innerText = '$' + (state.btcPrice / 1000).toFixed(1) + 'K';
        }
      } catch (err) {
        console.error('BTC price error:', err);
      }
    }
    async function fetchHistoricalData() {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=${state.currentTimeframe}&limit=100`);
        const data = await response.json();
        
        state.candles = data.map(k => ({
          time: k[0] / 1000,
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
        
        if (candleSeries) candleSeries.setData(state.candles);
        
        // Actualizar EMAs y lneas de tendencia
        updateEMAs();
        updateTrendLines();
        
        if (state.candles.length > 0) {
          state.currentPrice = state.candles[state.candles.length - 1].close;
          runPredictionEngine(state.currentPrice);
        }
        
        // Ajustar zoom inicial - mostrar ltimas 50 velas para mejor visibilidad
        if (chart && state.candles.length > 0) {
          const visibleBars = Math.min(50, state.candles.length);
          chart.timeScale().setVisibleLogicalRange({
            from: state.candles.length - visibleBars,
            to: state.candles.length
          });
        }
        
        console.log(`Historical data loaded (${state.currentTimeframe}):`, state.candles.length, 'candles');
      } catch (err) {
        console.error('Historical fetch error:', err);
      }
    }
    // ============================================
    // WEBSOCKET
    // ============================================
    let ws;
    function getWsUrl() {
      return `wss://stream.binance.com:9443/stream?streams=xrpusdt@kline_${state.currentTimeframe}/xrpusdt@depth20@100ms/xrpusdt@ticker/xrpusdt@aggTrade`;
    }
    function connectAPI() {
      ui.statusText.innerText = 'CONNECTING...';
      ui.statusPill.className = 'status-pill';
      
      const wsUrl = getWsUrl();
      ws = new WebSocket(wsUrl);
      ws.onopen = () => {
        ui.statusText.innerText = 'LIVE';
        ui.statusPill.classList.add('status-live');
        addAlert('System connected to Binance streams', 'info');
      };
      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        const data = msg.data;
        const stream = msg.stream;
        if (stream.includes('kline') && candleSeries) {
          const k = data.k;
          const candle = {
            time: k.t / 1000,
            open: parseFloat(k.o),
            high: parseFloat(k.h),
            low: parseFloat(k.l),
            close: parseFloat(k.c),
            volume: parseFloat(k.v)
          };
          
          candleSeries.update(candle);
          if (k.x) {
            state.candles.push(candle);
            if (state.candles.length > CONFIG.HISTORY_SIZE) state.candles.shift();
            runPredictionEngine(candle.close);
            // Actualizar EMAs y lneas de tendencia cuando se cierra una vela
            updateEMAs();
            updateTrendLines();
          }
        }
        if (stream.includes('ticker')) {
          const price = parseFloat(data.c);
          const change = parseFloat(data.P);
          const volume = parseFloat(data.q);
          
          state.currentPrice = price;
          state.price = price; // Mantener ambos para compatibilidad
          
          ui.price.innerText = price.toFixed(4);
          ui.midPrice.innerText = price.toFixed(4);
          ui.priceChange.innerHTML = `<span class="${change >= 0 ? 'c-green' : 'c-red'}">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</span>`;
          ui.volume.innerText = (volume / 1000000).toFixed(2) + 'M';
          
          if (state.candles.length > 0) {
            runPredictionEngine(price);
          }
        }
        if (stream.includes('depth')) {
          // Spoof detection
          const spoofDetected = detectSpoofing(data.bids, data.asks);
          ui.spoofWarning.style.display = spoofDetected ? 'inline' : 'none';
          if (spoofDetected) {
            addAlert('Potential SPOOFING detected in order book!', 'warning');
          }
          
          state.lastOrderBook = { bids: data.bids, asks: data.asks };
          updateOrderBook(data.bids, data.asks);
        }
        if (stream.includes('aggtrade') || stream.includes('aggTrade')) {
          const qty = parseFloat(data.q);
          const price = parseFloat(data.p);
          const isBuy = !data.m;
          
          state.cvd += isBuy ? qty : -qty;
          ui.cvdText.innerHTML = `CVD: <span class="${state.cvd >= 0 ? 'c-green' : 'c-red'}">${state.cvd >= 0 ? '+' : ''}${(state.cvd / 1000).toFixed(1)}K</span>`;
          
          if (qty >= CONFIG.WHALE_THRESHOLD) {
            addWhaleAlert(qty, price, isBuy, 'BINANCE');
            if (isBuy) state.whaleBuyVol += qty;
            else state.whaleSellVol += qty;
          }
        }
      };
      ws.onerror = () => {
        ui.statusText.innerText = 'ERROR';
        ui.statusPill.classList.add('status-err');
      };
      ws.onclose = () => {
        ui.statusText.innerText = 'RECONNECTING...';
        ui.statusPill.classList.remove('status-live');
        setTimeout(connectAPI, 3000);
      };
    }
    function updateOrderBook(bids, asks) {
      ui.bids.innerHTML = '';
      ui.asks.innerHTML = '';
      
      let totalBidVol = 0, totalAskVol = 0;
      let walls = [];
      const reversedAsks = asks.slice(0, 7).reverse();
      for (const ask of reversedAsks) {
        const price = parseFloat(ask[0]);
        const vol = parseFloat(ask[1]);
        totalAskVol += vol;
        if (vol >= CONFIG.WALL_THRESHOLD) walls.push({ type: 'SELL', price, vol });
        
        const row = document.createElement('div');
        row.className = 'ob-row ob-ask';
        row.innerHTML = `<span>${price.toFixed(4)}</span><span>${(vol/1000).toFixed(1)}K</span>`;
        if (vol >= CONFIG.WALL_THRESHOLD) row.style.background = 'rgba(255,68,102,0.15)';
        ui.asks.appendChild(row);
      }
      for (let i = 0; i < 7 && i < bids.length; i++) {
        const price = parseFloat(bids[i][0]);
        const vol = parseFloat(bids[i][1]);
        totalBidVol += vol;
        if (vol >= CONFIG.WALL_THRESHOLD) walls.push({ type: 'BUY', price, vol });
        
        const row = document.createElement('div');
        row.className = 'ob-row ob-bid';
        row.innerHTML = `<span>${price.toFixed(4)}</span><span>${(vol/1000).toFixed(1)}K</span>`;
        if (vol >= CONFIG.WALL_THRESHOLD) row.style.background = 'rgba(0,255,136,0.15)';
        ui.bids.appendChild(row);
      }
      const total = totalBidVol + totalAskVol;
      if (total > 0) {
        const bidPct = (totalBidVol / total) * 100;
        ui.liqBarBid.style.width = bidPct + '%';
        ui.liqBarAsk.style.width = (100 - bidPct) + '%';
        
        const dominant = bidPct > 55 ? 'BULLS' : (bidPct < 45 ? 'BEARS' : 'BALANCED');
        const domColor = bidPct > 55 ? 'c-green' : (bidPct < 45 ? 'c-red' : '');
        ui.liqText.innerHTML = `<span class="${domColor}"><strong>${dominant}</strong></span> ${bidPct.toFixed(0)}% / ${(100-bidPct).toFixed(0)}%`;
        
        const imbalance = ((totalBidVol - totalAskVol) / total) * 100;
        document.getElementById('obValue').innerText = imbalance.toFixed(1) + '%';
        const obEl = document.getElementById('obSignal');
        
        if (imbalance > 15) {
          obEl.className = 'indicator-signal signal-buy'; obEl.innerText = 'BUY WALL';
        } else if (imbalance < -15) {
          obEl.className = 'indicator-signal signal-sell'; obEl.innerText = 'SELL WALL';
        } else {
          obEl.className = 'indicator-signal signal-neutral'; obEl.innerText = 'BALANCED';
        }
      }
      ui.wallDetection.innerHTML = '';
      walls.slice(0, 2).forEach(wall => {
        const div = document.createElement('div');
        div.className = 'wall-indicator';
        div.innerHTML = `<span class="${wall.type === 'BUY' ? 'c-green' : 'c-red'}"> ${wall.type}</span> @ ${wall.price.toFixed(4)} (${(wall.vol/1000).toFixed(0)}K)`;
        ui.wallDetection.appendChild(div);
      });
    }
    function addWhaleAlert(qty, price, isBuy, exchange = 'BINANCE') {
      state.whaleCount++;
      ui.whaleCount.innerText = state.whaleCount;
      
      // Limpiar mensaje inicial si es el primer whale
      if (state.whaleCount === 1) {
        ui.whaleList.innerHTML = '';
      }
      
      const div = document.createElement('div');
      div.className = `whale-item ${isBuy ? 'buy' : 'sell'}`;
      
      const time = new Date().toLocaleTimeString();
      const value = (qty * price / 1000).toFixed(1);
      
      // Colores por exchange
      const exchangeColors = {
        'BINANCE': { bg: 'rgba(243,186,47,0.2)', color: '#f3ba2f' },
        'KRAKEN': { bg: 'rgba(113,84,255,0.2)', color: '#7154ff' },
        'BITSTAMP': { bg: 'rgba(57,181,74,0.2)', color: '#39b54a' },
        'BYBIT': { bg: 'rgba(247,147,26,0.2)', color: '#f7931a' },
        'COINBASE': { bg: 'rgba(0,82,255,0.2)', color: '#0052ff' },
        'CRYPTO.COM': { bg: 'rgba(17,60,92,0.3)', color: '#00b4e6' },
        'OKX': { bg: 'rgba(0,0,0,0.3)', color: '#ffffff' }
      };
      
      const exColor = exchangeColors[exchange] || exchangeColors['BINANCE'];
      
      div.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; width:100%;"><span><span class="${isBuy ? 'c-green' : 'c-red'}"> ${isBuy ? 'BUY' : 'SELL'}</span><strong>${(qty/1000).toFixed(1)}K</strong></span><span style="font-size:8px; background:${exColor.bg}; color:${exColor.color}; padding:1px 4px; border-radius:2px; font-weight:600;">${exchange}</span><span style="color:var(--text-dim); font-size:9px;">${value}K$ ${time}</span></div>
      `;
      
      ui.whaleList.prepend(div);
      
      // Alert for big whales (>25K ahora que el threshold base es 5K)
      if (qty >= 25000) {
        addAlert(` BIG WHALE: ${isBuy ? 'BUY' : 'SELL'} ${(qty/1000).toFixed(0)}K XRP ($${value}K) on ${exchange}`, isBuy ? 'bullish' : 'bearish');
        if (state.soundEnabled) playSound('whale');
      }
      
      // Check smart whale alerts
      if (typeof checkWhaleAlerts === 'function') {
        checkWhaleAlerts(isBuy ? 'BUY' : 'SELL', qty, price);
      }
      
      while (ui.whaleList.children.length > 15) {
        ui.whaleList.lastChild.remove();
      }
    }
    // ============================================
    // INIT
    // ============================================
    window.addEventListener('DOMContentLoaded', () => {
      console.log('ORACULUM OkrtSystem Labs - INITIALIZING...');
      
      // Initialize AI Learning System
      AILearning.init().then(() => {
        console.log('[AI] Learning system ready');
        const stats = AILearning.getStats();
        if (stats.weights.totalPredictions > 0) {
          console.log('[AI] Historical accuracy:', stats.weights.accuracy + '%');
        }
      });
      
      // Clock
      setInterval(() => {
        ui.clock.innerText = new Date().toLocaleTimeString();
      }, 1000);
      
      // Timeframe selector
      const tfSelect = document.getElementById('timeframeSelect');
      if (tfSelect) {
        tfSelect.addEventListener('change', (e) => {
          changeTimeframe(e.target.value);
        });
      }
      
      // Initialize voice language selector
      const langSelect = document.getElementById('voiceLangSelect');
      if (langSelect) {
        const savedLang = localStorage.getItem('oraculum_voice_lang') || 'en';
        langSelect.value = savedLang;
        voiceState.lang = savedLang;
      }
      
      // Initialize audio context on first user interaction
      document.body.addEventListener('click', () => {
        initAudio();
      }, { once: true });
      
      setTimeout(() => {
        initChart();
        connectAPI();
        fetchHistoricalData();
        fetchFearGreed();
        fetchDerivativesData();
        fetchBTCPrice();
        updatePredictionHistoryChart();
        updateSessionDisplay(); // Session detector
        updatePaperTradingUI(); // Paper Trading
      }, 100);
      
      // Periodic updates (optimized intervals)
      setInterval(fetchFearGreed, 300000);
      setInterval(fetchDerivativesData, 120000); // Optimizado: 60s -> 120s
      setInterval(fetchBTCPrice, 60000); // Optimizado: 30s -> 60s
      
      // Reset CVD and whale flow hourly
      setInterval(() => {
        state.cvd = 0;
        state.whaleBuyVol = 0;
        state.whaleSellVol = 0;
        addAlert('Hourly reset: CVD and Whale Flow counters cleared', 'info');
      }, 3600000);
      // Cargar alertas guardadas
      loadCustomAlerts();
      
      // Actualizar Multi-TF cada 60 segundos (optimizado: 30s -> 60s)
      setInterval(updateMultiTimeframe, 60000);
      
      // Actualizar lneas de tendencia cada 60 segundos (optimizado: 30s -> 60s)
      setInterval(updateTrendLines, 60000);
      
      // Actualizar S/R y Fibonacci cada 60 segundos (optimizado: 30s -> 60s)
      setInterval(() => {
        updateSROnChart();
        updateFibonacciLevels();
      }, 60000);
      
      // Actualizar Session Display cada 2 minutos (optimizado: 60s -> 120s)
      setInterval(updateSessionDisplay, 120000);
      
      // Verificar resultados de seales cada 5 minutos
      setInterval(verifySignalResults, 300000);
      
      // Conectar a otros exchanges para whale tracking
      connectKraken();
      connectBitstamp();
      connectBybit();
      connectCoinbase();
      connectCryptoCom();
    });
    // ============================================
    // MULTI-EXCHANGE WHALE TRACKING
    // ============================================
    // KRAKEN WebSocket
    let wsKraken;
    function connectKraken() {
      try {
        // Close existing connection if any
        if (wsKraken && wsKraken.readyState !== WebSocket.CLOSED) {
          try { wsKraken.close(); } catch(e) {}
        }
        wsKraken = new WebSocket('wss://ws.kraken.com');
        
        wsKraken.onopen = () => {
          console.log('Kraken WebSocket connected');
          // Suscribirse a trades de XRP/USD
          wsKraken.send(JSON.stringify({
            event: 'subscribe',
            pair: ['XRP/USD'],
            subscription: { name: 'trade' }
          }));
        };
        
        wsKraken.onmessage = (event) => {
          if (!Performance.shouldProcessWsMessage()) return; // Throttle
          try {
            const data = JSON.parse(event.data);
            // Los trades vienen como array: [channelID, [[price, volume, time, side, orderType, misc]], "trade", "XRP/USD"]
            if (Array.isArray(data) && data[2] === 'trade') {
              const trades = data[1];
              trades.forEach(trade => {
                const price = parseFloat(trade[0]);
                const qty = parseFloat(trade[1]);
                const isBuy = trade[3] === 'b';
                
                if (qty >= CONFIG.WHALE_THRESHOLD) {
                  addWhaleAlert(qty, price, isBuy, 'KRAKEN');
                  if (isBuy) state.whaleBuyVol += qty;
                  else state.whaleSellVol += qty;
                }
              });
            }
          } catch (e) {}
        };
        
        wsKraken.onerror = () => console.log('Kraken WebSocket error');
        wsKraken.onclose = () => setTimeout(connectKraken, 10000);
      } catch (e) {
        console.log('Kraken connection failed');
      }
    }
    // BITSTAMP WebSocket
    let wsBitstamp;
    function connectBitstamp() {
      try {
        // Close existing connection if any
        if (wsBitstamp && wsBitstamp.readyState !== WebSocket.CLOSED) {
          try { wsBitstamp.close(); } catch(e) {}
        }
        wsBitstamp = new WebSocket('wss://ws.bitstamp.net');
        
        wsBitstamp.onopen = () => {
          console.log('Bitstamp WebSocket connected');
          // Suscribirse a live trades de XRP/USD
          wsBitstamp.send(JSON.stringify({
            event: 'bts:subscribe',
            data: { channel: 'live_trades_xrpusd' }
          }));
        };
        
        wsBitstamp.onmessage = (event) => {
          if (!Performance.shouldProcessWsMessage()) return; // Throttle
          try {
            const msg = JSON.parse(event.data);
            if (msg.event === 'trade' && msg.data) {
              const price = parseFloat(msg.data.price);
              const qty = parseFloat(msg.data.amount);
              const isBuy = msg.data.type === 0; // 0 = buy, 1 = sell
              
              if (qty >= CONFIG.WHALE_THRESHOLD) {
                addWhaleAlert(qty, price, isBuy, 'BITSTAMP');
                if (isBuy) state.whaleBuyVol += qty;
                else state.whaleSellVol += qty;
              }
            }
          } catch (e) {}
        };
        
        wsBitstamp.onerror = () => console.log('Bitstamp WebSocket error');
        wsBitstamp.onclose = () => setTimeout(connectBitstamp, 10000);
      } catch (e) {
        console.log('Bitstamp connection failed');
      }
    }
    // BYBIT WebSocket  
    let wsBybit;
    function connectBybit() {
      try {
        // Close existing connection if any
        if (wsBybit && wsBybit.readyState !== WebSocket.CLOSED) {
          try { wsBybit.close(); } catch(e) {}
        }
        wsBybit = new WebSocket('wss://stream.bybit.com/v5/public/spot');
        
        wsBybit.onopen = () => {
          console.log('Bybit WebSocket connected');
          // Suscribirse a trades de XRPUSDT
          wsBybit.send(JSON.stringify({
            op: 'subscribe',
            args: ['publicTrade.XRPUSDT']
          }));
        };
        
        wsBybit.onmessage = (event) => {
          if (!Performance.shouldProcessWsMessage()) return; // Throttle
          try {
            const msg = JSON.parse(event.data);
            if (msg.topic === 'publicTrade.XRPUSDT' && msg.data) {
              msg.data.forEach(trade => {
                const price = parseFloat(trade.p);
                const qty = parseFloat(trade.v);
                const isBuy = trade.S === 'Buy';
                
                if (qty >= CONFIG.WHALE_THRESHOLD) {
                  addWhaleAlert(qty, price, isBuy, 'BYBIT');
                  if (isBuy) state.whaleBuyVol += qty;
                  else state.whaleSellVol += qty;
                }
              });
            }
          } catch (e) {}
        };
        
        wsBybit.onerror = () => console.log('Bybit WebSocket error');
        wsBybit.onclose = () => setTimeout(connectBybit, 10000);
      } catch (e) {
        console.log('Bybit connection failed');
      }
    }
    // COINBASE WebSocket
    let wsCoinbase;
    function connectCoinbase() {
      try {
        wsCoinbase = new WebSocket('wss://ws-feed.exchange.coinbase.com');
        
        wsCoinbase.onopen = () => {
          console.log('Coinbase WebSocket connected');
          // Suscribirse a trades de XRP-USD
          wsCoinbase.send(JSON.stringify({
            type: 'subscribe',
            product_ids: ['XRP-USD'],
            channels: ['matches']
          }));
        };
        
        wsCoinbase.onmessage = (event) => {
          if (!Performance.shouldProcessWsMessage()) return; // Throttle
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'match' || data.type === 'last_match') {
              const price = parseFloat(data.price);
              const qty = parseFloat(data.size);
              const isBuy = data.side === 'buy';
              
              if (qty >= CONFIG.WHALE_THRESHOLD) {
                addWhaleAlert(qty, price, isBuy, 'COINBASE');
                if (isBuy) state.whaleBuyVol += qty;
                else state.whaleSellVol += qty;
              }
            }
          } catch (e) {}
        };
        
        wsCoinbase.onerror = () => console.log('Coinbase WebSocket error');
        wsCoinbase.onclose = () => setTimeout(connectCoinbase, 10000);
      } catch (e) {
        console.log('Coinbase connection failed');
      }
    }
    // CRYPTO.COM WebSocket
    let wsCryptoCom;
    function connectCryptoCom() {
      try {
        wsCryptoCom = new WebSocket('wss://stream.crypto.com/v2/market');
        
        wsCryptoCom.onopen = () => {
          console.log('Crypto.com WebSocket connected');
          // Suscribirse a trades de XRP_USD
          wsCryptoCom.send(JSON.stringify({
            id: 1,
            method: 'subscribe',
            params: {
              channels: ['trade.XRP_USD']
            }
          }));
        };
        
        wsCryptoCom.onmessage = (event) => {
          if (!Performance.shouldProcessWsMessage()) return; // Throttle
          try {
            const msg = JSON.parse(event.data);
            if (msg.method === 'subscribe' && msg.result && msg.result.data) {
              msg.result.data.forEach(trade => {
                const price = parseFloat(trade.p);
                const qty = parseFloat(trade.q);
                const isBuy = trade.s === 'BUY';
                
                if (qty >= CONFIG.WHALE_THRESHOLD) {
                  addWhaleAlert(qty, price, isBuy, 'CRYPTO.COM');
                  if (isBuy) state.whaleBuyVol += qty;
                  else state.whaleSellVol += qty;
                }
              });
            }
          } catch (e) {}
        };
        
        wsCryptoCom.onerror = () => console.log('Crypto.com WebSocket error');
        wsCryptoCom.onclose = () => setTimeout(connectCryptoCom, 10000);
      } catch (e) {
        console.log('Crypto.com connection failed');
      }
    }
  </script><!-- ============================================
       TOOLS PANEL OVERLAY
       ============================================ --><div class="tools-overlay" id="toolsOverlay" onclick="closeToolsIfClickOutside(event)"><div class="tools-panel" onclick="event.stopPropagation()"><div class="tools-header"><h2>ðŸ› ï¸ TRADING TOOLS</h2><button class="tools-close" onclick="toggleToolsPanel()"></button></div><div class="tools-tabs"><button class="tools-tab active" onclick="switchToolTab('mtf')">ðŸ“Š Multi-TF</button><button class="tools-tab" onclick="switchToolTab('backtest')">ðŸ”„ Backtest</button><button class="tools-tab" onclick="switchToolTab('alerts')">ðŸ”” Smart Alerts</button><button class="tools-tab" onclick="switchToolTab('risk')">âš–ï¸ Risk Calc</button><button class="tools-tab" onclick="switchToolTab('fibo')">ðŸ“ Fibonacci</button><button class="tools-tab" onclick="switchToolTab('session')">â° Session</button><button class="tools-tab" onclick="switchToolTab('strategy')">ðŸ“‹ Strategy</button><button class="tools-tab" onclick="switchToolTab('corr')">ðŸ”— Correlation</button></div><div class="tools-content"><!-- MULTI-TIMEFRAME SECTION --><div class="tool-section active" id="mtfSection"><div class="mtf-grid" id="mtfGrid"><div class="mtf-card" data-tf="1m"><div class="mtf-tf">1M</div><div class="mtf-price" id="mtf-price-1m">--</div><div class="mtf-signal neutral" id="mtf-signal-1m">LOADING</div><div class="mtf-indicators"><div>RSI: <span class="mtf-rsi" id="mtf-rsi-1m">--</span></div><div>MACD: <span id="mtf-macd-1m">--</span></div><div>Trend: <span id="mtf-trend-1m">--</span></div></div></div><div class="mtf-card" data-tf="5m"><div class="mtf-tf">5M</div><div class="mtf-price" id="mtf-price-5m">--</div><div class="mtf-signal neutral" id="mtf-signal-5m">LOADING</div><div class="mtf-indicators"><div>RSI: <span class="mtf-rsi" id="mtf-rsi-5m">--</span></div><div>MACD: <span id="mtf-macd-5m">--</span></div><div>Trend: <span id="mtf-trend-5m">--</span></div></div></div><div class="mtf-card" data-tf="15m"><div class="mtf-tf">15M</div><div class="mtf-price" id="mtf-price-15m">--</div><div class="mtf-signal neutral" id="mtf-signal-15m">LOADING</div><div class="mtf-indicators"><div>RSI: <span class="mtf-rsi" id="mtf-rsi-15m">--</span></div><div>MACD: <span id="mtf-macd-15m">--</span></div><div>Trend: <span id="mtf-trend-15m">--</span></div></div></div><div class="mtf-card" data-tf="1h"><div class="mtf-tf">1H</div><div class="mtf-price" id="mtf-price-1h">--</div><div class="mtf-signal neutral" id="mtf-signal-1h">LOADING</div><div class="mtf-indicators"><div>RSI: <span class="mtf-rsi" id="mtf-rsi-1h">--</span></div><div>MACD: <span id="mtf-macd-1h">--</span></div><div>Trend: <span id="mtf-trend-1h">--</span></div></div></div><div class="mtf-card" data-tf="4h"><div class="mtf-tf">4H</div><div class="mtf-price" id="mtf-price-4h">--</div><div class="mtf-signal neutral" id="mtf-signal-4h">LOADING</div><div class="mtf-indicators"><div>RSI: <span class="mtf-rsi" id="mtf-rsi-4h">--</span></div><div>MACD: <span id="mtf-macd-4h">--</span></div><div>Trend: <span id="mtf-trend-4h">--</span></div></div></div></div><div style="margin-top:15px; padding:15px; background:rgba(0,212,255,0.05); border-radius:8px; border:1px solid rgba(0,212,255,0.2);"><div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;">ðŸ“Š MTF CONSENSUS</div><div style="display:flex; justify-content:space-around; text-align:center;"><div><div id="mtf-bullish-count" style="font-size:24px; font-weight:bold; color:var(--accent-green);">0</div><div style="font-size:10px; color:var(--text-dim);">BULLISH</div></div><div><div id="mtf-neutral-count" style="font-size:24px; font-weight:bold; color:var(--text-dim);">0</div><div style="font-size:10px; color:var(--text-dim);">NEUTRAL</div></div><div><div id="mtf-bearish-count" style="font-size:24px; font-weight:bold; color:var(--accent-red);">0</div><div style="font-size:10px; color:var(--text-dim);">BEARISH</div></div></div><div id="mtf-verdict" style="text-align:center; margin-top:10px; font-size:14px; font-weight:bold;">ANALYZING...</div></div></div><!--  BACKTESTING ENGINE SECTION --><div class="tool-section" id="backtestSection"><div style="display:grid; grid-template-columns:1fr 1fr; gap:20px;"><!-- Backtesting Controls --><div style="background:rgba(0,0,0,0.2); border-radius:10px; padding:15px;"><h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;"> BACKTEST SETTINGS</h3><div class="input-group" style="margin-bottom:12px;"><label style="font-size:10px; color:var(--text-dim);">Period (Days)</label><select id="btPeriod" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;"><option value="1">Last 24 Hours</option><option value="3">Last 3 Days</option><option selected="" value="7">Last 7 Days</option><option value="14">Last 14 Days</option><option value="30">Last 30 Days</option></select></div><div class="input-group" style="margin-bottom:12px;"><label style="font-size:10px; color:var(--text-dim);">Timeframe</label><select id="btTimeframe" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;"><option value="5m">5 Minutes</option><option selected="" value="15m">15 Minutes</option><option value="4h">4 Hours</option></select></div><div class="input-group" style="margin-bottom:12px;"><label style="font-size:10px; color:var(--text-dim);">Signal Quality Threshold</label><input id="btQualityThreshold" max="90" min="30" style="width:100%;" type="range" value="60"/><div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);"><span>Low (30)</span><span id="btQualityValue">60</span><span>High (90)</span></div></div><div class="input-group" style="margin-bottom:12px;"><label style="font-size:10px; color:var(--text-dim);">Probability Threshold (%)</label><input id="btProbThreshold" max="85" min="55" style="width:100%;" type="range" value="65"/><div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);"><span>55%</span><span id="btProbValue">65%</span><span>85%</span></div></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;"><div class="input-group"><label style="font-size:10px; color:var(--text-dim);">Take Profit (%)</label><input id="btTakeProfit" max="10" min="0.5" step="0.5" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;" type="number" value="2"/></div><div class="input-group"><label style="font-size:10px; color:var(--text-dim);">Stop Loss (%)</label><input id="btStopLoss" max="10" min="0.5" step="0.5" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;" type="number" value="1"/></div></div><button onclick="runBacktest()" style="width:100%; padding:12px; background:linear-gradient(135deg, var(--accent-cyan), var(--accent-purple)); border:none; border-radius:8px; color:#fff; font-family:var(--font-tech); font-size:12px; cursor:pointer; font-weight:bold;">
                 RUN BACKTEST
              </button><div id="btProgress" style="display:none; margin-top:10px;"><div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">Processing...</div><div style="height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;"><div id="btProgressBar" style="height:100%; width:0%; background:var(--accent-cyan); transition:width 0.3s;"></div></div></div></div><!-- Backtesting Results --><div style="background:rgba(0,0,0,0.2); border-radius:10px; padding:15px;"><h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-green); margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;"> RESULTS</h3><div id="btResults" style="display:none;"><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;"><div style="background:rgba(0,255,136,0.1); padding:12px; border-radius:8px; text-align:center; border:1px solid rgba(0,255,136,0.2);"><div style="font-size:9px; color:var(--accent-green);">WIN RATE</div><div id="btWinRate" style="font-size:24px; font-weight:bold; color:var(--accent-green);">--%</div></div><div style="background:rgba(0,212,255,0.1); padding:12px; border-radius:8px; text-align:center; border:1px solid rgba(0,212,255,0.2);"><div style="font-size:9px; color:var(--accent-cyan);">PROFIT FACTOR</div><div id="btProfitFactor" style="font-size:24px; font-weight:bold; color:var(--accent-cyan);">--</div></div></div><div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; margin-bottom:15px;"><div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px; text-align:center;"><div style="font-size:8px; color:var(--text-dim);">TOTAL TRADES</div><div id="btTotalTrades" style="font-size:16px; font-weight:bold;">0</div></div><div style="background:rgba(0,255,136,0.05); padding:10px; border-radius:6px; text-align:center;"><div style="font-size:8px; color:var(--accent-green);">WINS</div><div id="btWins" style="font-size:16px; font-weight:bold; color:var(--accent-green);">0</div></div><div style="background:rgba(255,68,102,0.05); padding:10px; border-radius:6px; text-align:center;"><div style="font-size:8px; color:var(--accent-red);">LOSSES</div><div id="btLosses" style="font-size:16px; font-weight:bold; color:var(--accent-red);">0</div></div></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;"><div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px;"><div style="font-size:8px; color:var(--text-dim);">TOTAL RETURN</div><div id="btTotalReturn" style="font-size:18px; font-weight:bold;">0%</div></div><div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px;"><div style="font-size:8px; color:var(--text-dim);">MAX DRAWDOWN</div><div id="btMaxDrawdown" style="font-size:18px; font-weight:bold; color:var(--accent-red);">0%</div></div></div><div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px; margin-bottom:15px;"><div style="font-size:8px; color:var(--text-dim); margin-bottom:8px;">EQUITY CURVE</div><div id="btEquityChart" style="height:80px; display:flex; align-items:flex-end; gap:2px;"></div></div><div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px;"><div style="font-size:8px; color:var(--text-dim); margin-bottom:8px;">TRADE LOG (Last 10)</div><div id="btTradeLog" style="max-height:100px; overflow-y:auto; font-size:9px;"></div></div></div><div id="btNoResults" style="text-align:center; padding:40px 20px; color:var(--text-dim);"><div style="font-size:40px; margin-bottom:10px;"></div><div style="font-size:12px;">Configure settings and run backtest</div><div style="font-size:10px; margin-top:5px;">to see AI Engine performance</div></div></div></div></div><!-- RISK CALCULATOR SECTION --><div class="tool-section" id="riskSection"><div class="risk-grid"><div class="risk-inputs"><h3> PARAMETERS</h3><div class="input-group"><label>Account Balance (USDT)</label><input id="riskBalance" placeholder="1000" type="number" value="1000"/></div><div class="input-group"><label>Risk per Trade (%)</label><input id="riskPercent" placeholder="2" step="0.5" type="number" value="2"/></div><div class="input-row"><div class="input-group"><label>Entry Price</label><input id="riskEntry" placeholder="Current price" step="0.0001" type="number"/></div><div class="input-group"><label>Leverage (1-125x)</label><input id="riskLeverage" max="125" min="1" placeholder="1" type="number" value="1"/></div></div><div class="input-row"><div class="input-group"><label>Stop Loss Price</label><input id="riskSL" placeholder="SL price" step="0.0001" type="number"/></div><div class="input-group"><label>Take Profit Price</label><input id="riskTP" placeholder="TP price" step="0.0001" type="number"/></div></div><button class="add-alert-btn" onclick="calculateRisk()" style="margin-top:10px;">
                 CALCULATE
              </button><div style="display:flex; gap:10px; margin-top:10px;"><button class="control-btn" onclick="setCurrentPriceAsEntry()" style="flex:1; padding:8px;">
                   Use Current Price
                </button><button class="control-btn" onclick="suggestSLTP()" style="flex:1; padding:8px;">
                   Auto SL/TP
                </button></div></div><div class="risk-results"><h3> RESULTS</h3><div class="result-item"><span class="result-label">Risk Amount</span><span class="result-value red" id="riskAmount">$0.00</span></div><div class="result-item"><span class="result-label">Position Size</span><span class="result-value cyan" id="positionSize">0 XRP</span></div><div class="result-item"><span class="result-label">Position Value</span><span class="result-value cyan" id="positionValue">$0.00</span></div><div class="result-item"><span class="result-label">Distance to SL</span><span class="result-value red" id="slDistance">0%</span></div><div class="result-item"><span class="result-label">Distance to TP</span><span class="result-value green" id="tpDistance">0%</span></div><div class="result-item"><span class="result-label">Potential Loss</span><span class="result-value red" id="potentialLoss">-$0.00</span></div><div class="result-item"><span class="result-label">Potential Profit</span><span class="result-value green" id="potentialProfit">+$0.00</span></div><div class="result-item"><span class="result-label">Liquidation Price</span><span class="result-value red" id="liqPrice">$0.00</span></div><div class="risk-ratio"><div class="risk-ratio-value" id="rrRatio">0:0</div><div class="risk-ratio-label">RISK:REWARD RATIO</div></div></div></div></div><!--  SMART ALERTS SECTION --><div class="tool-section" id="alertsSection"><div class="alerts-container"><div class="alerts-form"><h3> CREATE SMART ALERT</h3><!-- Alert Type Selection --><div style="margin-bottom:15px;"><label style="font-size:10px; color:var(--text-dim); display:block; margin-bottom:8px;">Alert Type</label><div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;"><button class="alert-type-btn active" id="alertTypePrice" onclick="setSmartAlertType('price')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(0,212,255,0.2); border:1px solid var(--accent-cyan); color:var(--accent-cyan);">
                     Price Level
                  </button><button class="alert-type-btn" id="alertTypeRSI" onclick="setSmartAlertType('rsi')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-dim);">
                     RSI Level
                  </button><button class="alert-type-btn" id="alertTypeWhale" onclick="setSmartAlertType('whale')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-dim);">
                     Whale Trade
                  </button><button class="alert-type-btn" id="alertTypeSignal" onclick="setSmartAlertType('signal')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-dim);">
                     AI Signal
                  </button></div></div><!-- Price Alert Config --><div id="priceAlertConfig"><div class="alert-type-btns" style="margin-bottom:10px;"><button class="alert-type-btn active above" id="alertAboveBtn" onclick="setAlertType('above')" style="flex:1; padding:8px; font-size:10px;">
                     Above
                  </button><button class="alert-type-btn below" id="alertBelowBtn" onclick="setAlertType('below')" style="flex:1; padding:8px; font-size:10px;">
                     Below
                  </button></div><div class="input-group"><label>Alert Price (USDT)</label><input id="customAlertPrice" placeholder="Enter price..." step="0.0001" type="number"/></div></div><!-- RSI Alert Config --><div id="rsiAlertConfig" style="display:none;"><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px;"><button class="control-btn active" id="rsiOversoldBtn" onclick="setRSIAlertType('oversold')" style="padding:10px; background:rgba(0,255,136,0.2); border-color:var(--accent-green); color:var(--accent-green);">
                     Oversold (&lt;30)
                  </button><button class="control-btn" id="rsiOverboughtBtn" onclick="setRSIAlertType('overbought')" style="padding:10px;">
                     Overbought (&gt;70)
                  </button></div><div class="input-group"><label>Custom RSI Level (optional)</label><input id="customRSILevel" max="99" min="1" placeholder="e.g., 25 or 75" type="number"/></div></div><!-- Whale Alert Config --><div id="whaleAlertConfig" style="display:none;"><div class="input-group"><label>Minimum Trade Size (USDT)</label><input id="whaleMinSize" placeholder="50000" step="10000" type="number" value="50000"/></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;"><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input checked="" id="whaleBuyAlert" type="checkbox"/>  Buy Orders
                  </label><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input checked="" id="whaleSellAlert" type="checkbox"/>  Sell Orders
                  </label></div></div><!-- AI Signal Alert Config --><div id="signalAlertConfig" style="display:none;"><div class="input-group"><label>Minimum Signal Quality</label><input id="signalQualityMin" max="95" min="50" style="width:100%;" type="range" value="75"/><div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);"><span>50</span><span id="signalQualityDisplay">75</span><span>95</span></div></div><div class="input-group" style="margin-top:10px;"><label>Minimum Probability</label><input id="signalProbMin" max="90" min="60" style="width:100%;" type="range" value="70"/><div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);"><span>60%</span><span id="signalProbDisplay">70%</span><span>90%</span></div></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;"><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input checked="" id="signalBullAlert" type="checkbox"/>  Bullish
                  </label><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input checked="" id="signalBearAlert" type="checkbox"/>  Bearish
                  </label></div></div><div class="input-group" style="margin-top:10px;"><label>Note (optional)</label><input id="customAlertNote" maxlength="50" placeholder="e.g., Resistance level" type="text"/></div><!-- Notification Options --><div style="margin:15px 0; padding:10px; background:rgba(255,255,255,0.03); border-radius:6px;"><div style="font-size:9px; color:var(--text-dim); margin-bottom:8px;">NOTIFICATION OPTIONS</div><div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;"><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input checked="" id="alertSound" type="checkbox"/>  Sound
                  </label><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input id="alertVoice" type="checkbox"/>  Voice
                  </label><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input id="alertBrowser" type="checkbox"/>  Browser
                  </label><label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);"><input id="alertRepeat" type="checkbox"/>  Repeat
                  </label></div></div><button class="add-alert-btn" onclick="addSmartAlert()" style="width:100%; padding:12px; background:linear-gradient(135deg, var(--accent-cyan), var(--accent-purple)); border:none; border-radius:8px; color:#fff; font-family:var(--font-tech); cursor:pointer;">
                 CREATE ALERT
              </button><div style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px;"><div style="font-size:10px; color:var(--text-dim); margin-bottom:8px;">QUICK PRICE ALERTS</div><div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:6px;"><button class="control-btn" onclick="addQuickAlert(1)" style="font-size:9px; padding:6px;">+1%</button><button class="control-btn" onclick="addQuickAlert(2)" style="font-size:9px; padding:6px;">+2%</button><button class="control-btn" onclick="addQuickAlert(5)" style="font-size:9px; padding:6px;">+5%</button><button class="control-btn" onclick="addQuickAlert(-1)" style="font-size:9px; padding:6px;">-1%</button><button class="control-btn" onclick="addQuickAlert(-2)" style="font-size:9px; padding:6px;">-2%</button><button class="control-btn" onclick="addQuickAlert(-5)" style="font-size:9px; padding:6px;">-5%</button></div></div></div><div class="alerts-list-panel"><h3> ACTIVEðŸ”” ALERTS <span id="alertsCount" style="opacity:0.5; font-weight:normal;">(0)</span></h3><div class="custom-alerts-list" id="customAlertsList"><div class="no-alerts">No alerts configured. Create your first alert!</div></div><!-- Alert History --><div style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:15px;"><h3 style="font-size:11px; color:var(--text-dim); margin-bottom:10px;"> TRIGGERED HISTORY</h3><div id="alertHistory" style="max-height:120px; overflow-y:auto; font-size:9px;"><div style="color:var(--text-dim); text-align:center; padding:10px;">No alerts triggered yet</div></div></div><button class="control-btn" onclick="clearAllAlerts()" style="width:100%; margin-top:10px; padding:10px; color:var(--accent-red);">
                 Clear All Alerts
              </button></div></div></div><!-- FIBONACCI SECTION --><div class="tool-section" id="fiboSection"><div class="fibo-container"><div class="fibo-levels"><h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);"> FIBONACCI RETRACEMENT</h3><div class="fibo-level-row"><span class="fibo-label">0% (High)</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:100%; background:var(--accent-green);"></div></div><span class="fibo-price c-green" id="fibo-0">--</span></div><div class="fibo-level-row"><span class="fibo-label">23.6%</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:76.4%; background:var(--accent-cyan);"></div></div><span class="fibo-price c-cyan" id="fibo-236">--</span></div><div class="fibo-level-row"><span class="fibo-label">38.2%</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:61.8%; background:var(--accent-purple);"></div></div><span class="fibo-price c-purple" id="fibo-382">--</span></div><div class="fibo-level-row"><span class="fibo-label">50%</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:50%; background:var(--accent-orange);"></div></div><span class="fibo-price c-orange" id="fibo-50">--</span></div><div class="fibo-level-row"><span class="fibo-label">61.8%</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:38.2%; background:var(--accent-yellow);"></div></div><span class="fibo-price" id="fibo-618" style="color:var(--accent-yellow);">--</span></div><div class="fibo-level-row"><span class="fibo-label">78.6%</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:21.4%; background:var(--accent-red);"></div></div><span class="fibo-price c-red" id="fibo-786">--</span></div><div class="fibo-level-row"><span class="fibo-label">100% (Low)</span><div class="fibo-bar"><div class="fibo-bar-fill" style="width:0%; background:var(--accent-red);"></div></div><span class="fibo-price c-red" id="fibo-100">--</span></div><div style="margin-top:15px; padding:12px; background:rgba(0,212,255,0.05); border-radius:8px; text-align:center;"><div style="font-size:10px; color:var(--text-dim);">CURRENT PRICE</div><div id="fibo-current" style="font-family:var(--font-data); font-size:20px; color:var(--accent-cyan);">--</div><div id="fibo-zone" style="font-size:10px; color:var(--text-dim);">--</div></div></div><div class="fibo-info"><h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);"> SWING DETECTION</h3><div style="margin-bottom:15px;"><div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">SWING HIGH (24H)</div><div id="swing-high" style="font-family:var(--font-data); font-size:18px; color:var(--accent-green);">--</div></div><div style="margin-bottom:15px;"><div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">SWING LOW (24H)</div><div id="swing-low" style="font-family:var(--font-data); font-size:18px; color:var(--accent-red);">--</div></div><div style="margin-bottom:15px;"><div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">RANGE</div><div id="fibo-range" style="font-family:var(--font-data); font-size:16px; color:var(--text-main);">--</div></div><div style="padding:15px; background:rgba(168,85,247,0.1); border-radius:8px; border:1px solid rgba(168,85,247,0.2);"><div style="font-size:11px; font-weight:600; color:var(--accent-purple); margin-bottom:8px;"> KEY LEVELS</div><div style="font-size:10px; color:var(--text-dim); line-height:1.6;"><div> <strong>38.2% &amp; 61.8%</strong>: Strongest retracement zones</div><div> <strong>50%</strong>: Psychological level</div><div> <strong>78.6%</strong>: Last defense before trend reversal</div></div></div><button class="add-alert-btn" onclick="updateFibonacci()" style="margin-top:15px;"> Refresh Levels</button></div></div></div><!-- SESSION STATS SECTION --><div class="tool-section" id="sessionSection"><div class="session-grid"><div class="session-stat"><div class="session-stat-value c-cyan" id="session-duration">00:00:00</div><div class="session-stat-label">Session Time</div></div><div class="session-stat"><div class="session-stat-value" id="session-high">--</div><div class="session-stat-label">Session High</div></div><div class="session-stat"><div class="session-stat-value" id="session-low">--</div><div class="session-stat-label">Session Low</div></div><div class="session-stat"><div class="session-stat-value" id="session-range">--</div><div class="session-stat-label">Range %</div></div><div class="session-stat"><div class="session-stat-value c-green" id="session-signals-bull">0</div><div class="session-stat-label">Bullish Signals</div></div><div class="session-stat"><div class="session-stat-value c-red" id="session-signals-bear">0</div><div class="session-stat-label">Bearish Signals</div></div><div class="session-stat"><div class="session-stat-value c-purple" id="session-patterns">0</div><div class="session-stat-label">Patterns Detected</div></div><div class="session-stat"><div class="session-stat-value c-orange" id="session-whales">0</div><div class="session-stat-label">Whale Trades</div></div></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;"><div class="session-timeline"><div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;"> PRICE ACTION</div><div class="timeline-row"><span style="color:var(--text-dim);">Open Price</span><span id="session-open" style="font-family:var(--font-data);">--</span></div><div class="timeline-row"><span style="color:var(--text-dim);">Current Price</span><span id="session-current" style="font-family:var(--font-data);">--</span></div><div class="timeline-row"><span style="color:var(--text-dim);">Change</span><span id="session-change" style="font-family:var(--font-data);">--</span></div><div class="timeline-row"><span style="color:var(--text-dim);">Volatility (ATR)</span><span id="session-volatility" style="font-family:var(--font-data);">--</span></div></div><div class="session-timeline"><div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;"> PREDICTIONS</div><div class="timeline-row"><span style="color:var(--text-dim);">Total Predictions</span><span id="session-predictions" style="font-family:var(--font-data);">0</span></div><div class="timeline-row"><span style="color:var(--text-dim);">Correct</span><span id="session-correct" style="font-family:var(--font-data); color:var(--accent-green);">0</span></div><div class="timeline-row"><span style="color:var(--text-dim);">Incorrect</span><span id="session-incorrect" style="font-family:var(--font-data); color:var(--accent-red);">0</span></div><div class="timeline-row"><span style="color:var(--text-dim);">Session Accuracy</span><span id="session-accuracy" style="font-family:var(--font-data); color:var(--accent-cyan);">--%</span></div></div></div><button class="add-alert-btn" onclick="resetSessionStats()" style="margin-top:15px;"> Reset Session Stats</button></div><!-- STRATEGY BUILDER SECTION --><div class="tool-section" id="strategySection"><div class="strategy-container"><div class="strategy-builder"><h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);"> CREATE STRATEGY</h3><div class="input-group"><label>Strategy Name</label><input id="strategyName" maxlength="30" placeholder="e.g., RSI Oversold Buy" type="text"/></div><div style="font-size:10px; color:var(--text-dim); margin:10px 0 5px;">CONDITION 1</div><div class="condition-row"><select id="strategy-ind-1"><option value="rsi">RSI</option><option value="stochRsi">Stoch RSI</option><option value="macd">MACD</option><option value="price">Price</option><option value="volume">Volume 24h</option><option value="funding">Funding Rate</option></select><select id="strategy-op-1"><option value="&lt;">&lt; Less than</option><option value="&gt;">&gt; Greater than</option><option value="cross_up"> Cross Up</option><option value="cross_down"> Cross Down</option></select><input id="strategy-val-1" placeholder="Value" type="number"/></div><div class="logic-connector"><select id="strategy-logic" style="background:rgba(168,85,247,0.2); border-color:var(--accent-purple); color:var(--accent-purple);"><option value="AND">AND</option><option value="OR">OR</option></select></div><div style="font-size:10px; color:var(--text-dim); margin:5px 0;">CONDITION 2 (optional)</div><div class="condition-row"><select id="strategy-ind-2"><option value="">-- None --</option><option value="rsi">RSI</option><option value="stochRsi">Stoch RSI</option><option value="macd">MACD</option><option value="price">Price</option><option value="volume">Volume 24h</option><option value="funding">Funding Rate</option></select><select id="strategy-op-2"><option value="&lt;">&lt; Less than</option><option value="&gt;">&gt; Greater than</option><option value="cross_up"> Cross Up</option><option value="cross_down"> Cross Down</option></select><input id="strategy-val-2" placeholder="Value" type="number"/></div><div class="input-group" style="margin-top:15px;"><label>Alert Type</label><select id="strategy-alert-type" style="width:100%; padding:10px;"><option value="bullish"> Bullish Signal</option><option value="bearish"> Bearish Signal</option><option value="warning"> Warning</option></select></div><button class="add-alert-btn" onclick="createStrategy()" style="margin-top:15px;"> CreateðŸ“‹ Strategy</button></div><div class="strategy-list"><h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);"> MY STRATEGIES <span id="strategiesCount" style="opacity:0.5;">(0)</span></h3><div id="strategiesList"><div class="no-alerts">No strategies created yet. Build your first strategy!</div></div></div></div></div><!-- CORRELATION SECTION --><div class="tool-section" id="corrSection"><div class="corr-grid"><div class="corr-card"><div class="corr-pair">XRP / BTC</div><div class="corr-value positive" id="corr-btc">0.00</div><div class="corr-label">24H CORRELATION</div><div class="corr-bar"><div class="corr-bar-fill" id="corr-btc-bar" style="width:50%; background:var(--accent-green);"></div></div><div style="margin-top:10px; font-size:10px; color:var(--text-dim);">
                BTC: <span id="corr-btc-price" style="color:var(--accent-cyan);">--</span><span id="corr-btc-change">--</span></div></div><div class="corr-card"><div class="corr-pair">XRP / ETH</div><div class="corr-value positive" id="corr-eth">0.00</div><div class="corr-label">24H CORRELATION</div><div class="corr-bar"><div class="corr-bar-fill" id="corr-eth-bar" style="width:50%; background:var(--accent-green);"></div></div><div style="margin-top:10px; font-size:10px; color:var(--text-dim);">
                ETH: <span id="corr-eth-price" style="color:var(--accent-cyan);">--</span><span id="corr-eth-change">--</span></div></div><div class="corr-card"><div class="corr-pair">XRP / SOL</div><div class="corr-value positive" id="corr-sol">0.00</div><div class="corr-label">24H CORRELATION</div><div class="corr-bar"><div class="corr-bar-fill" id="corr-sol-bar" style="width:50%; background:var(--accent-green);"></div></div><div style="margin-top:10px; font-size:10px; color:var(--text-dim);">
                SOL: <span id="corr-sol-price" style="color:var(--accent-cyan);">--</span><span id="corr-sol-change">--</span></div></div></div><div style="margin-top:20px; padding:15px; background:rgba(0,212,255,0.05); border-radius:8px; border:1px solid rgba(0,212,255,0.2);"><div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;"> CORRELATION GUIDE</div><div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:15px; text-align:center; font-size:10px;"><div><div style="color:var(--accent-green); font-weight:bold;">+0.7 to +1.0</div><div style="color:var(--text-dim);">Strong Positive</div><div style="color:var(--text-dim); font-size:9px;">Move together</div></div><div><div style="color:var(--accent-orange); font-weight:bold;">-0.3 to +0.3</div><div style="color:var(--text-dim);">Weak/None</div><div style="color:var(--text-dim); font-size:9px;">Independent</div></div><div><div style="color:var(--accent-red); font-weight:bold;">-0.7 to -1.0</div><div style="color:var(--text-dim);">Strong Negative</div><div style="color:var(--text-dim); font-size:9px;">Move opposite</div></div></div></div><button class="add-alert-btn" onclick="updateCorrelations()" style="margin-top:15px;"> Refresh Correlations</button></div><!-- WATCHLIST SECTION --><div class="tool-section" id="watchlistSection"><div class="watchlist-grid" id="watchlistGrid"><div class="watchlist-card" data-symbol="BTCUSDT"><div class="watchlist-icon"></div><div class="watchlist-info"><div class="watchlist-symbol">BTC</div><div class="watchlist-name">Bitcoin</div></div><div class="watchlist-mini-chart" id="chart-btc"></div><div class="watchlist-price"><div class="watchlist-price-value" id="watch-btc-price">--</div><div class="watchlist-change" id="watch-btc-change">--</div></div></div><div class="watchlist-card" data-symbol="ETHUSDT"><div class="watchlist-icon"></div><div class="watchlist-info"><div class="watchlist-symbol">ETH</div><div class="watchlist-name">Ethereum</div></div><div class="watchlist-mini-chart" id="chart-eth"></div><div class="watchlist-price"><div class="watchlist-price-value" id="watch-eth-price">--</div><div class="watchlist-change" id="watch-eth-change">--</div></div></div><div class="watchlist-card" data-symbol="SOLUSDT"><div class="watchlist-icon"></div><div class="watchlist-info"><div class="watchlist-symbol">SOL</div><div class="watchlist-name">Solana</div></div><div class="watchlist-mini-chart" id="chart-sol"></div><div class="watchlist-price"><div class="watchlist-price-value" id="watch-sol-price">--</div><div class="watchlist-change" id="watch-sol-change">--</div></div></div><div class="watchlist-card" data-symbol="XRPUSDT"><div class="watchlist-icon" style="background:rgba(0,212,255,0.2);"></div><div class="watchlist-info"><div class="watchlist-symbol" style="color:var(--accent-cyan);">XRP</div><div class="watchlist-name">Ripple</div></div><div class="watchlist-mini-chart" id="chart-xrp"></div><div class="watchlist-price"><div class="watchlist-price-value" id="watch-xrp-price" style="color:var(--accent-cyan);">--</div><div class="watchlist-change" id="watch-xrp-change">--</div></div></div><div class="watchlist-card" data-symbol="ADAUSDT"><div class="watchlist-icon"></div><div class="watchlist-info"><div class="watchlist-symbol">ADA</div><div class="watchlist-name">Cardano</div></div><div class="watchlist-mini-chart" id="chart-ada"></div><div class="watchlist-price"><div class="watchlist-price-value" id="watch-ada-price">--</div><div class="watchlist-change" id="watch-ada-change">--</div></div></div><div class="watchlist-card" data-symbol="DOGEUSDT"><div class="watchlist-icon"></div><div class="watchlist-info"><div class="watchlist-symbol">DOGE</div><div class="watchlist-name">Dogecoin</div></div><div class="watchlist-mini-chart" id="chart-doge"></div><div class="watchlist-price"><div class="watchlist-price-value" id="watch-doge-price">--</div><div class="watchlist-change" id="watch-doge-change">--</div></div></div></div><div style="margin-top:20px; padding:15px; background:rgba(0,0,0,0.2); border-radius:8px;"><div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;"> MARKET OVERVIEW</div><div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:15px; text-align:center;"><div><div style="font-size:10px; color:var(--text-dim);">TOTAL MARKET CAP</div><div id="total-mcap" style="font-family:var(--font-data); font-size:16px; color:var(--text-main);">--</div></div><div><div style="font-size:10px; color:var(--text-dim);">BTC DOMINANCE</div><div id="btc-dom" style="font-family:var(--font-data); font-size:16px; color:var(--accent-orange);">--</div></div><div><div style="font-size:10px; color:var(--text-dim);">24H VOLUME</div><div id="total-vol" style="font-family:var(--font-data); font-size:16px; color:var(--accent-purple);">--</div></div></div></div></div></div></div></div><script nonce="okrt-oraculum-nonce-2026">
    // ============================================
    // TOOLS PANEL FUNCTIONALITY
    // ============================================
    // State for tools
    const toolsState = {
      alertType: 'above',
      customAlerts: [],
      mtfData: {}
    };
    // Toggle tools panel
    function toggleToolsPanel() {
      const overlay = document.getElementById('toolsOverlay');
      overlay.classList.toggle('active');
      if (overlay.classList.contains('active')) {
        updateMultiTimeframe();
        setCurrentPriceAsEntry();
      }
    }
    function closeToolsIfClickOutside(e) {
      if (e.target.id === 'toolsOverlay') {
        toggleToolsPanel();
      }
    }
    // Switch between tool tabs
    function switchToolTab(tab) {
      document.querySelectorAll('.tools-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tool-section').forEach(s => s.classList.remove('active'));
      
      document.querySelector(`[onclick="switchToolTab('${tab}')"]`).classList.add('active');
      document.getElementById(tab + 'Section').classList.add('active');
    }
    // ============================================
    // 1. MULTI-TIMEFRAME ANALYSIS
    // ============================================
    async function fetchTimeframeData(tf) {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=${tf}&limit=100`);
        const data = await response.json();
        return data.map(k => ({
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
      } catch (e) {
        console.error('Error fetching ' + tf, e);
        return null;
      }
    }
    function calculateTFIndicators(candles) {
      if (!candles || candles.length < 26) return null;
      
      const closes = candles.map(c => c.close);
      const currentPrice = closes[closes.length - 1];
      
      // RSI
      let gains = 0, losses = 0;
      for (let i = closes.length - 14; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / 14;
      const avgLoss = losses / 14;
      const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
      const rsi = 100 - (100 / (1 + rs));
      // EMA helper
      const ema = (data, period) => {
        const k = 2 / (period + 1);
        let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < data.length; i++) {
          ema = data[i] * k + ema * (1 - k);
        }
        return ema;
      };
      // MACD
      const ema12 = ema(closes, 12);
      const ema26 = ema(closes, 26);
      const macdLine = ema12 - ema26;
      // Trend (EMA 9 vs 21)
      const ema9 = ema(closes, 9);
      const ema21 = ema(closes, 21);
      const trend = ema9 > ema21 ? 'UP' : ema9 < ema21 ? 'DOWN' : 'FLAT';
      // Signal
      let signal = 'NEUTRAL';
      let bullScore = 0, bearScore = 0;
      
      if (rsi < 30) bullScore += 2;
      else if (rsi > 70) bearScore += 2;
      
      if (macdLine > 0) bullScore++;
      else if (macdLine < 0) bearScore++;
      
      if (trend === 'UP') bullScore++;
      else if (trend === 'DOWN') bearScore++;
      if (bullScore >= 3) signal = 'BULLISH';
      else if (bearScore >= 3) signal = 'BEARISH';
      return { price: currentPrice, rsi, macd: macdLine, trend, signal };
    }
    async function updateMultiTimeframe() {
      const timeframes = ['1m', '5m', '15m', '1h', '4h'];
      let bullish = 0, bearish = 0, neutral = 0;
      for (const tf of timeframes) {
        const candles = await fetchTimeframeData(tf);
        const indicators = calculateTFIndicators(candles);
        
        if (indicators) {
          toolsState.mtfData[tf] = indicators;
          
          // Update card
          const card = document.querySelector(`.mtf-card[data-tf="${tf}"]`);
          document.getElementById(`mtf-price-${tf}`).textContent = '$' + indicators.price.toFixed(4);
          
          const signalEl = document.getElementById(`mtf-signal-${tf}`);
          signalEl.textContent = indicators.signal;
          signalEl.className = 'mtf-signal ' + indicators.signal.toLowerCase();
          
          const rsiEl = document.getElementById(`mtf-rsi-${tf}`);
          rsiEl.textContent = indicators.rsi.toFixed(1);
          rsiEl.className = 'mtf-rsi ' + (indicators.rsi < 30 ? 'oversold' : indicators.rsi > 70 ? 'overbought' : 'neutral');
          
          document.getElementById(`mtf-macd-${tf}`).textContent = indicators.macd > 0 ? '' : indicators.macd < 0 ? '' : '';
          document.getElementById(`mtf-trend-${tf}`).textContent = indicators.trend;
          // Update card border
          card.className = 'mtf-card ' + (indicators.signal === 'BULLISH' ? 'bullish' : indicators.signal === 'BEARISH' ? 'bearish' : '');
          // Count signals
          if (indicators.signal === 'BULLISH') bullish++;
          else if (indicators.signal === 'BEARISH') bearish++;
          else neutral++;
        }
      }
      // Update consensus
      document.getElementById('mtf-bullish-count').textContent = bullish;
      document.getElementById('mtf-neutral-count').textContent = neutral;
      document.getElementById('mtf-bearish-count').textContent = bearish;
      const verdict = document.getElementById('mtf-verdict');
      if (bullish >= 4) {
        verdict.textContent = ' STRONG BULLISH';
        verdict.style.color = 'var(--accent-green)';
      } else if (bearish >= 4) {
        verdict.textContent = ' STRONG BEARISH';
        verdict.style.color = 'var(--accent-red)';
      } else if (bullish > bearish) {
        verdict.textContent = ' BULLISH BIAS';
        verdict.style.color = 'var(--accent-green)';
      } else if (bearish > bullish) {
        verdict.textContent = ' BEARISH BIAS';
        verdict.style.color = 'var(--accent-red)';
      } else {
        verdict.textContent = ' MIXED SIGNALS';
        verdict.style.color = 'var(--accent-orange)';
      }
    }
    // ============================================
    // 2. RISK CALCULATOR
    // ============================================
    function setCurrentPriceAsEntry() {
      const currentPrice = state.price || 0;
      document.getElementById('riskEntry').value = currentPrice.toFixed(4);
    }
    function suggestSLTP() {
      const entry = parseFloat(document.getElementById('riskEntry').value);
      if (!entry) {
        alert('Please set entry price first');
        return;
      }
      // 2% SL, 4% TP (1:2 ratio)
      document.getElementById('riskSL').value = (entry * 0.98).toFixed(4);
      document.getElementById('riskTP').value = (entry * 1.04).toFixed(4);
      calculateRisk();
    }
    function calculateRisk() {
      const balance = parseFloat(document.getElementById('riskBalance').value) || 0;
      const riskPct = parseFloat(document.getElementById('riskPercent').value) || 0;
      const entry = parseFloat(document.getElementById('riskEntry').value) || 0;
      const sl = parseFloat(document.getElementById('riskSL').value) || 0;
      const tp = parseFloat(document.getElementById('riskTP').value) || 0;
      const leverage = parseFloat(document.getElementById('riskLeverage').value) || 1;
      if (!entry || !sl) {
        alert('Please fill Entry and Stop Loss prices');
        return;
      }
      // Calculations
      const riskAmount = balance * (riskPct / 100);
      const slDistancePct = Math.abs((entry - sl) / entry) * 100;
      const tpDistancePct = tp ? Math.abs((tp - entry) / entry) * 100 : 0;
      
      // Position size based on risk
      const positionValue = riskAmount / (slDistancePct / 100);
      const positionSize = positionValue / entry;
      
      // Actual position with leverage
      const leveragedPosition = positionValue * leverage;
      const actualXRP = leveragedPosition / entry;
      // P&L
      const potentialLoss = riskAmount;
      const potentialProfit = tp ? positionValue * (tpDistancePct / 100) : 0;
      // Risk:Reward ratio
      const rr = potentialProfit > 0 ? (potentialProfit / potentialLoss).toFixed(2) : 0;
      // Liquidation price (simplified)
      const liqPrice = entry > sl 
        ? entry * (1 - (1 / leverage) + 0.005) // Long
        : entry * (1 + (1 / leverage) - 0.005); // Short
      // Update UI
      document.getElementById('riskAmount').textContent = '$' + riskAmount.toFixed(2);
      document.getElementById('positionSize').textContent = actualXRP.toFixed(2) + ' XRP';
      document.getElementById('positionValue').textContent = '$' + leveragedPosition.toFixed(2);
      document.getElementById('slDistance').textContent = slDistancePct.toFixed(2) + '%';
      document.getElementById('tpDistance').textContent = tp ? tpDistancePct.toFixed(2) + '%' : '--';
      document.getElementById('potentialLoss').textContent = '-$' + potentialLoss.toFixed(2);
      document.getElementById('potentialProfit').textContent = tp ? '+$' + potentialProfit.toFixed(2) : '--';
      document.getElementById('liqPrice').textContent = leverage > 1 ? '$' + liqPrice.toFixed(4) : 'N/A (Spot)';
      document.getElementById('rrRatio').textContent = '1:' + rr;
      // Color code RR ratio
      const rrEl = document.getElementById('rrRatio');
      if (rr >= 2) rrEl.style.color = 'var(--accent-green)';
      else if (rr >= 1) rrEl.style.color = 'var(--accent-orange)';
      else rrEl.style.color = 'var(--accent-red)';
    }
    // ============================================
    // 3. CUSTOM PRICE ALERTS
    // ============================================
    function setAlertType(type) {
      toolsState.alertType = type;
      document.getElementById('alertAboveBtn').classList.remove('active');
      document.getElementById('alertBelowBtn').classList.remove('active');
      document.getElementById('alert' + type.charAt(0).toUpperCase() + type.slice(1) + 'Btn').classList.add('active');
    }
    function addCustomAlert() {
      const price = parseFloat(document.getElementById('customAlertPrice').value);
      const note = document.getElementById('customAlertNote').value || '';
      
      if (!price) {
        alert('Please enter a valid price');
        return;
      }
      const alert = {
        id: Date.now(),
        price: price,
        type: toolsState.alertType,
        note: note,
        triggered: false,
        createdAt: new Date().toISOString()
      };
      toolsState.customAlerts.push(alert);
      saveCustomAlerts();
      renderCustomAlerts();
      
      document.getElementById('customAlertPrice').value = '';
      document.getElementById('customAlertNote').value = '';
      
      addAlert(`Price alert set: ${toolsState.alertType === 'above' ? '' : ''} $${price.toFixed(4)}`, 'info');
    }
    function addQuickAlert(pct) {
      const currentPrice = state.price || 0;
      if (!currentPrice) return;
      
      const alertPrice = currentPrice * (1 + pct / 100);
      const alert = {
        id: Date.now(),
        price: alertPrice,
        type: pct > 0 ? 'above' : 'below',
        note: `${pct > 0 ? '+' : ''}${pct}% from $${currentPrice.toFixed(4)}`,
        triggered: false,
        createdAt: new Date().toISOString()
      };
      toolsState.customAlerts.push(alert);
      saveCustomAlerts();
      renderCustomAlerts();
      
      addAlert(`Quick alert set: ${pct > 0 ? '' : ''} $${alertPrice.toFixed(4)} (${pct > 0 ? '+' : ''}${pct}%)`, 'info');
    }
    function deleteCustomAlert(id) {
      toolsState.customAlerts = toolsState.customAlerts.filter(a => a.id !== id);
      saveCustomAlerts();
      renderCustomAlerts();
    }
    function clearAllAlerts() {
      if (confirm('Are you sure you want to delete all alerts?')) {
        toolsState.customAlerts = [];
        saveCustomAlerts();
        renderCustomAlerts();
      }
    }
    function renderCustomAlerts() {
      const container = document.getElementById('customAlertsList');
      const activeAlerts = toolsState.customAlerts.filter(a => !a.triggered);
      
      document.getElementById('alertsCount').textContent = `(${activeAlerts.length})`;
      if (activeAlerts.length === 0) {
        container.innerHTML = '<div class="no-alerts">No alerts configured. Create your first alert!</div>';
        return;
      }
      container.innerHTML = activeAlerts
        .sort((a, b) => b.price - a.price)
        .map(alert => `
          <div class="custom-alert-item ${alert.type} ${alert.triggered ? 'triggered' : ''}"><div class="alert-info"><div class="alert-price">${alert.type === 'above' ? '' : ''} $${alert.price.toFixed(4)}</div><div class="alert-condition">${alert.type === 'above' ? 'When price goes above' : 'When price goes below'}${alert.note ? '  ' + alert.note : ''}</div></div><button class="alert-delete" onclick="deleteCustomAlert(${alert.id})"></button></div>
        `).join('');
    }
    function checkCustomAlerts(currentPrice) {
      if (!currentPrice || toolsState.customAlerts.length === 0) return;
      toolsState.customAlerts.forEach(alert => {
        if (alert.triggered) return;
        const triggered = (alert.type === 'above' && currentPrice >= alert.price) ||
                         (alert.type === 'below' && currentPrice <= alert.price);
        if (triggered) {
          alert.triggered = true;
          saveCustomAlerts();
          renderCustomAlerts();
          
          // Play sound and add alert
          const msg = ` PRICE ALERT: XRP ${alert.type === 'above' ? 'reached' : 'dropped to'} $${alert.price.toFixed(4)}${alert.note ? ' (' + alert.note + ')' : ''}`;
          addAlert(msg, alert.type === 'above' ? 'bullish' : 'bearish');
          
          // Browser notification
          if (Notification.permission === 'granted') {
            new Notification('XRP ORACULUM Alert', { body: msg, icon: '' });
          }
        }
      });
    }
    function saveCustomAlerts() {
      try {
        localStorage.setItem('xrp_oraculum_alerts', JSON.stringify(toolsState.customAlerts));
      } catch (e) {}
    }
    function loadCustomAlerts() {
      try {
        const saved = localStorage.getItem('xrp_oraculum_alerts');
        if (saved) {
          toolsState.customAlerts = JSON.parse(saved);
          renderCustomAlerts();
        }
      } catch (e) {}
      
      // Request notification permission
      if (Notification.permission === 'default') {
        Notification.requestPermission();
      }
    }
    // Hook into price updates to check alerts
    const originalUpdatePrice = window.updateUI || function(){};
    const checkAlertsInterval = setInterval(() => {
      if (state.price) {
        checkCustomAlerts(state.price);
        checkStrategies();
        checkSmartAlerts(); // NEW: Smart alerts check
      }
    }, 1000);
    // ============================================
    //  BACKTESTING ENGINE
    // ============================================
    
    const backtestState = {
      running: false,
      results: null,
      historicalData: []
    };
    
    // UI event listeners for backtest sliders
    document.addEventListener('DOMContentLoaded', () => {
      const qualitySlider = document.getElementById('btQualityThreshold');
      const probSlider = document.getElementById('btProbThreshold');
      
      if (qualitySlider) {
        qualitySlider.addEventListener('input', (e) => {
          document.getElementById('btQualityValue').textContent = e.target.value;
        });
      }
      if (probSlider) {
        probSlider.addEventListener('input', (e) => {
          document.getElementById('btProbValue').textContent = e.target.value + '%';
        });
      }
      
      // Signal alert sliders
      const sigQualSlider = document.getElementById('signalQualityMin');
      const sigProbSlider = document.getElementById('signalProbMin');
      
      if (sigQualSlider) {
        sigQualSlider.addEventListener('input', (e) => {
          document.getElementById('signalQualityDisplay').textContent = e.target.value;
        });
      }
      if (sigProbSlider) {
        sigProbSlider.addEventListener('input', (e) => {
          document.getElementById('signalProbDisplay').textContent = e.target.value + '%';
        });
      }
    });
    
    async function runBacktest() {
      if (backtestState.running) return;
      
      const period = parseInt(document.getElementById('btPeriod').value) || 7;
      const timeframe = document.getElementById('btTimeframe').value || '15m';
      const qualityThreshold = parseInt(document.getElementById('btQualityThreshold').value) || 60;
      const probThreshold = parseInt(document.getElementById('btProbThreshold').value) || 65;
      const takeProfit = parseFloat(document.getElementById('btTakeProfit').value) || 2;
      const stopLoss = parseFloat(document.getElementById('btStopLoss').value) || 1;
      
      backtestState.running = true;
      document.getElementById('btProgress').style.display = 'block';
      document.getElementById('btResults').style.display = 'none';
      document.getElementById('btNoResults').style.display = 'none';
      
      try {
        // Calculate limit based on period and timeframe
        const tfMinutes = { '5m': 5, '15m': 15, '1h': 60, '4h': 240 };
        const minutes = tfMinutes[timeframe] || 15;
        const limit = Math.min(1000, Math.floor((period * 24 * 60) / minutes));
        
        // Fetch historical data
        updateProgress(10);
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=${timeframe}&limit=${limit}`);
        const data = await response.json();
        
        if (!data || data.length < 50) {
          throw new Error('Insufficient data');
        }
        
        updateProgress(30);
        
        // Process candles
        const candles = data.map(k => ({
          time: k[0] / 1000,
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
        
        // Run backtest simulation
        const results = simulateBacktest(candles, qualityThreshold, probThreshold, takeProfit, stopLoss);
        
        updateProgress(90);
        
        // Display results
        displayBacktestResults(results);
        
        updateProgress(100);
        
      } catch (error) {
        console.error('Backtest error:', error);
        addAlert('Backtest failed: ' + error.message, 'warning');
        document.getElementById('btNoResults').style.display = 'block';
      } finally {
        backtestState.running = false;
        setTimeout(() => {
          document.getElementById('btProgress').style.display = 'none';
        }, 500);
      }
    }
    
    function updateProgress(pct) {
      const bar = document.getElementById('btProgressBar');
      if (bar) bar.style.width = pct + '%';
    }
    
    function simulateBacktest(candles, qualityThreshold, probThreshold, tpPct, slPct) {
      const trades = [];
      const equity = [100]; // Start with $100
      let currentEquity = 100;
      let maxEquity = 100;
      let maxDrawdown = 0;
      
      // Need at least 50 candles for indicators
      for (let i = 50; i < candles.length - 1; i++) {
        const slice = candles.slice(0, i + 1);
        const closes = slice.map(c => c.close);
        const currentPrice = slice[slice.length - 1].close;
        
        // Calculate indicators (simplified version of AI Engine)
        const rsi = calcRSI(closes, 14);
        const ema9 = calcEMA(closes, 9);
        const ema21 = calcEMA(closes, 21);
        const macd = calcMACD(closes);
        
        if (!rsi || !ema9 || !ema21) continue;
        
        // Calculate signal quality and probability (simplified)
        let bullPoints = 0, bearPoints = 0;
        
        // RSI signals
        if (rsi < 35) bullPoints += 2;
        else if (rsi > 65) bearPoints += 2;
        
        // EMA trend
        if (ema9 > ema21) bullPoints += 2;
        else bearPoints += 2;
        
        // MACD
        if (macd && macd.histogram > 0) bullPoints += 1;
        else if (macd && macd.histogram < 0) bearPoints += 1;
        
        // Price vs EMAs
        if (currentPrice > ema21) bullPoints += 1;
        else bearPoints += 1;
        
        const totalPoints = bullPoints + bearPoints;
        const probBull = totalPoints > 0 ? (bullPoints / totalPoints * 100) : 50;
        const signalQuality = Math.min(100, (totalPoints * 15) + (Math.abs(rsi - 50)));
        
        // Check if we should take a trade
        const shouldTrade = signalQuality >= qualityThreshold;
        const isBullish = probBull >= probThreshold;
        const isBearish = (100 - probBull) >= probThreshold;
        
        if (shouldTrade && (isBullish || isBearish)) {
          const direction = isBullish ? 'LONG' : 'SHORT';
          const entry = currentPrice;
          
          // Simulate trade outcome using future candles
          let result = simulateTrade(candles.slice(i + 1), entry, direction, tpPct, slPct);
          
          if (result) {
            trades.push({
              index: i,
              time: slice[slice.length - 1].time,
              direction,
              entry,
              exit: result.exit,
              pnl: result.pnl,
              result: result.result
            });
            
            currentEquity *= (1 + result.pnl / 100);
            equity.push(currentEquity);
            
            if (currentEquity > maxEquity) maxEquity = currentEquity;
            const dd = ((maxEquity - currentEquity) / maxEquity) * 100;
            if (dd > maxDrawdown) maxDrawdown = dd;
          }
        }
      }
      
      // Calculate statistics
      const wins = trades.filter(t => t.result === 'WIN').length;
      const losses = trades.filter(t => t.result === 'LOSS').length;
      const totalTrades = trades.length;
      const winRate = totalTrades > 0 ? (wins / totalTrades * 100) : 0;
      
      const grossProfit = trades.filter(t => t.pnl > 0).reduce((a, b) => a + b.pnl, 0);
      const grossLoss = Math.abs(trades.filter(t => t.pnl < 0).reduce((a, b) => a + b.pnl, 0));
      const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss) : grossProfit > 0 ? 999 : 0;
      
      const totalReturn = ((currentEquity - 100) / 100) * 100;
      
      return {
        trades,
        equity,
        totalTrades,
        wins,
        losses,
        winRate,
        profitFactor,
        totalReturn,
        maxDrawdown
      };
    }
    
    function simulateTrade(futureCandles, entry, direction, tpPct, slPct) {
      if (futureCandles.length === 0) return null;
      
      const tp = direction === 'LONG' ? entry * (1 + tpPct / 100) : entry * (1 - tpPct / 100);
      const sl = direction === 'LONG' ? entry * (1 - slPct / 100) : entry * (1 + slPct / 100);
      
      // Max hold 20 candles
      const maxCandles = Math.min(20, futureCandles.length);
      
      for (let i = 0; i < maxCandles; i++) {
        const candle = futureCandles[i];
        
        if (direction === 'LONG') {
          if (candle.high >= tp) return { exit: tp, pnl: tpPct, result: 'WIN' };
          if (candle.low <= sl) return { exit: sl, pnl: -slPct, result: 'LOSS' };
        } else {
          if (candle.low <= tp) return { exit: tp, pnl: tpPct, result: 'WIN' };
          if (candle.high >= sl) return { exit: sl, pnl: -slPct, result: 'LOSS' };
        }
      }
      
      // Exit at last candle if no TP/SL hit
      const lastClose = futureCandles[maxCandles - 1].close;
      const pnl = direction === 'LONG' 
        ? ((lastClose - entry) / entry) * 100 
        : ((entry - lastClose) / entry) * 100;
      
      return { exit: lastClose, pnl, result: pnl > 0 ? 'WIN' : 'LOSS' };
    }
    
    function displayBacktestResults(results) {
      document.getElementById('btResults').style.display = 'block';
      document.getElementById('btNoResults').style.display = 'none';
      
      // Main stats
      document.getElementById('btWinRate').textContent = results.winRate.toFixed(1) + '%';
      document.getElementById('btWinRate').style.color = results.winRate >= 50 ? 'var(--accent-green)' : 'var(--accent-red)';
      
      document.getElementById('btProfitFactor').textContent = results.profitFactor.toFixed(2);
      document.getElementById('btProfitFactor').style.color = results.profitFactor >= 1 ? 'var(--accent-cyan)' : 'var(--accent-red)';
      
      document.getElementById('btTotalTrades').textContent = results.totalTrades;
      document.getElementById('btWins').textContent = results.wins;
      document.getElementById('btLosses').textContent = results.losses;
      
      document.getElementById('btTotalReturn').textContent = (results.totalReturn >= 0 ? '+' : '') + results.totalReturn.toFixed(2) + '%';
      document.getElementById('btTotalReturn').style.color = results.totalReturn >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
      
      document.getElementById('btMaxDrawdown').textContent = '-' + results.maxDrawdown.toFixed(2) + '%';
      
      // Equity curve
      renderEquityCurve(results.equity);
      
      // Trade log
      renderTradeLog(results.trades);
    }
    
    function renderEquityCurve(equity) {
      const container = document.getElementById('btEquityChart');
      if (!equity || equity.length === 0) {
        container.innerHTML = '<div style="color:var(--text-dim);">No data</div>';
        return;
      }
      
      const max = Math.max(...equity);
      const min = Math.min(...equity);
      const range = max - min || 1;
      
      // Sample to max 50 bars
      const step = Math.max(1, Math.floor(equity.length / 50));
      const sampled = equity.filter((_, i) => i % step === 0);
      
      container.innerHTML = sampled.map((val, i) => {
        const height = ((val - min) / range) * 100;
        const color = val >= 100 ? 'var(--accent-green)' : 'var(--accent-red)';
        return `<div style="flex:1; min-width:3px; background:${color}; height:${Math.max(5, height)}%; border-radius:1px;"></div>`;
      }).join('');
    }
    
    function renderTradeLog(trades) {
      const container = document.getElementById('btTradeLog');
      const recent = trades.slice(-10).reverse();
      
      if (recent.length === 0) {
        container.innerHTML = '<div style="color:var(--text-dim); text-align:center;">No trades</div>';
        return;
      }
      
      container.innerHTML = recent.map(t => {
        const time = new Date(t.time * 1000).toLocaleString();
        const color = t.result === 'WIN' ? 'var(--accent-green)' : 'var(--accent-red)';
        return `
          <div style="display:flex; justify-content:space-between; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05);"><span>${t.direction === 'LONG' ? '' : ''} ${t.direction}</span><span>$${t.entry.toFixed(4)}</span><span style="color:${color};">${t.pnl >= 0 ? '+' : ''}${t.pnl.toFixed(2)}%</span></div>
        `;
      }).join('');
    }
    // ============================================
    //  SMART ALERTS SYSTEM
    // ============================================
    
    const smartAlertsState = {
      currentType: 'price', // price, rsi, whale, signal
      rsiType: 'oversold',
      alerts: JSON.parse(localStorage.getItem('smart_alerts') || '[]'),
      history: JSON.parse(localStorage.getItem('smart_alerts_history') || '[]'),
      lastChecked: {}
    };
    
    function setSmartAlertType(type) {
      smartAlertsState.currentType = type;
      
      // Update button styles
      ['price', 'rsi', 'whale', 'signal'].forEach(t => {
        const btn = document.getElementById('alertType' + t.charAt(0).toUpperCase() + t.slice(1));
        if (btn) {
          btn.style.background = t === type ? 'rgba(0,212,255,0.2)' : 'rgba(255,255,255,0.05)';
          btn.style.borderColor = t === type ? 'var(--accent-cyan)' : 'rgba(255,255,255,0.1)';
          btn.style.color = t === type ? 'var(--accent-cyan)' : 'var(--text-dim)';
        }
      });
      
      // Show/hide config sections
      document.getElementById('priceAlertConfig').style.display = type === 'price' ? 'block' : 'none';
      document.getElementById('rsiAlertConfig').style.display = type === 'rsi' ? 'block' : 'none';
      document.getElementById('whaleAlertConfig').style.display = type === 'whale' ? 'block' : 'none';
      document.getElementById('signalAlertConfig').style.display = type === 'signal' ? 'block' : 'none';
    }
    
    function setRSIAlertType(type) {
      smartAlertsState.rsiType = type;
      const oversoldBtn = document.getElementById('rsiOversoldBtn');
      const overboughtBtn = document.getElementById('rsiOverboughtBtn');
      
      if (type === 'oversold') {
        oversoldBtn.classList.add('active');
        oversoldBtn.style.background = 'rgba(0,255,136,0.2)';
        oversoldBtn.style.borderColor = 'var(--accent-green)';
        oversoldBtn.style.color = 'var(--accent-green)';
        overboughtBtn.classList.remove('active');
        overboughtBtn.style.background = 'transparent';
        overboughtBtn.style.borderColor = 'rgba(255,255,255,0.1)';
        overboughtBtn.style.color = 'var(--text-dim)';
      } else {
        overboughtBtn.classList.add('active');
        overboughtBtn.style.background = 'rgba(255,68,102,0.2)';
        overboughtBtn.style.borderColor = 'var(--accent-red)';
        overboughtBtn.style.color = 'var(--accent-red)';
        oversoldBtn.classList.remove('active');
        oversoldBtn.style.background = 'transparent';
        oversoldBtn.style.borderColor = 'rgba(255,255,255,0.1)';
        oversoldBtn.style.color = 'var(--text-dim)';
      }
    }
    
    function addSmartAlert() {
      const type = smartAlertsState.currentType;
      const note = document.getElementById('customAlertNote').value || '';
      const options = {
        sound: document.getElementById('alertSound')?.checked ?? true,
        voice: document.getElementById('alertVoice')?.checked ?? false,
        browser: document.getElementById('alertBrowser')?.checked ?? false,
        repeat: document.getElementById('alertRepeat')?.checked ?? false
      };
      
      let alertConfig = {
        id: Date.now(),
        type,
        note,
        options,
        triggered: false,
        triggerCount: 0,
        createdAt: new Date().toISOString()
      };
      
      // Type-specific config
      switch (type) {
        case 'price':
          const price = parseFloat(document.getElementById('customAlertPrice').value);
          if (!price) { addAlert(' Enter a valid price', 'warning'); return; }
          alertConfig.price = price;
          alertConfig.direction = toolsState.alertType;
          break;
          
        case 'rsi':
          const customRSI = document.getElementById('customRSILevel').value;
          alertConfig.rsiType = smartAlertsState.rsiType;
          alertConfig.rsiLevel = customRSI ? parseFloat(customRSI) : (smartAlertsState.rsiType === 'oversold' ? 30 : 70);
          break;
          
        case 'whale':
          alertConfig.minSize = parseFloat(document.getElementById('whaleMinSize').value) || 50000;
          alertConfig.buyAlert = document.getElementById('whaleBuyAlert')?.checked ?? true;
          alertConfig.sellAlert = document.getElementById('whaleSellAlert')?.checked ?? true;
          break;
          
        case 'signal':
          alertConfig.qualityMin = parseInt(document.getElementById('signalQualityMin').value) || 75;
          alertConfig.probMin = parseInt(document.getElementById('signalProbMin').value) || 70;
          alertConfig.bullAlert = document.getElementById('signalBullAlert')?.checked ?? true;
          alertConfig.bearAlert = document.getElementById('signalBearAlert')?.checked ?? true;
          break;
      }
      
      smartAlertsState.alerts.push(alertConfig);
      saveSmartAlerts();
      renderSmartAlerts();
      
      // Clear form
      if (document.getElementById('customAlertPrice')) document.getElementById('customAlertPrice').value = '';
      if (document.getElementById('customAlertNote')) document.getElementById('customAlertNote').value = '';
      
      addAlert(` Smart alert created: ${getAlertDescription(alertConfig)}`, 'info');
    }
    
    function getAlertDescription(alert) {
      switch (alert.type) {
        case 'price':
          return `${alert.direction === 'above' ? '' : ''} Price ${alert.direction} $${alert.price.toFixed(4)}`;
        case 'rsi':
          return ` RSI ${alert.rsiType} ${alert.rsiLevel}`;
        case 'whale':
          return ` Whale trade > $${(alert.minSize/1000).toFixed(0)}K`;
        case 'signal':
          return ` AI Signal Q>${alert.qualityMin} P>${alert.probMin}%`;
        default:
          return 'Unknown alert';
      }
    }
    
    function renderSmartAlerts() {
      const container = document.getElementById('customAlertsList');
      const activeAlerts = smartAlertsState.alerts.filter(a => !a.triggered || a.options?.repeat);
      
      // Also update for the original system
      const count = document.getElementById('alertsCount');
      if (count) count.textContent = `(${activeAlerts.length})`;
      
      if (activeAlerts.length === 0) {
        container.innerHTML = '<div class="no-alerts">No alerts configured. Create your first alert!</div>';
        return;
      }
      
      container.innerHTML = activeAlerts.map(alert => {
        const icon = { price: '', rsi: '', whale: '', signal: '' }[alert.type] || '';
        const desc = getAlertDescription(alert);
        
        return `
          <div class="custom-alert-item" style="display:flex; justify-content:space-between; align-items:center; padding:8px; margin-bottom:6px; background:rgba(255,255,255,0.03); border-radius:6px; border-left:3px solid var(--accent-cyan);"><div><div style="font-size:11px; font-weight:bold;">${icon} ${desc}</div><div style="font-size:9px; color:var(--text-dim);">${alert.note || 'No note'}  ${alert.options?.repeat ? '' : '1x'}</div></div><button onclick="deleteSmartAlert(${alert.id})" style="background:none; border:none; color:var(--accent-red); cursor:pointer; font-size:14px;"></button></div>
        `;
      }).join('');
    }
    
    function deleteSmartAlert(id) {
      smartAlertsState.alerts = smartAlertsState.alerts.filter(a => a.id !== id);
      saveSmartAlerts();
      renderSmartAlerts();
    }
    
    function saveSmartAlerts() {
      try {
        localStorage.setItem('smart_alerts', JSON.stringify(smartAlertsState.alerts));
        localStorage.setItem('smart_alerts_history', JSON.stringify(smartAlertsState.history.slice(-50)));
      } catch (e) {}
    }
    
    function checkSmartAlerts() {
      if (smartAlertsState.alerts.length === 0) return;
      
      const currentPrice = state.currentPrice || state.price;
      const currentRSI = state.rsiHistory?.length > 0 ? state.rsiHistory[state.rsiHistory.length - 1] : null;
      
      smartAlertsState.alerts.forEach(alert => {
        if (alert.triggered && !alert.options?.repeat) return;
        
        // Cooldown check (don't trigger same alert within 60s)
        const lastCheck = smartAlertsState.lastChecked[alert.id] || 0;
        if (Date.now() - lastCheck < 60000) return;
        
        let triggered = false;
        let message = '';
        
        switch (alert.type) {
          case 'price':
            if (currentPrice) {
              triggered = (alert.direction === 'above' && currentPrice >= alert.price) ||
                         (alert.direction === 'below' && currentPrice <= alert.price);
              message = `Price ${alert.direction === 'above' ? 'reached' : 'dropped to'} $${currentPrice.toFixed(4)}`;
            }
            break;
            
          case 'rsi':
            if (currentRSI !== null) {
              triggered = (alert.rsiType === 'oversold' && currentRSI <= alert.rsiLevel) ||
                         (alert.rsiType === 'overbought' && currentRSI >= alert.rsiLevel);
              message = `RSI ${alert.rsiType}: ${currentRSI.toFixed(1)}`;
            }
            break;
            
          case 'signal':
            const quality = aiState.signalQuality || 0;
            const prob = Math.max(aiState.probabilityBull || 50, aiState.probabilityBear || 50);
            const isBull = (aiState.probabilityBull || 50) > 50;
            
            if (quality >= alert.qualityMin && prob >= alert.probMin) {
              if ((isBull && alert.bullAlert) || (!isBull && alert.bearAlert)) {
                triggered = true;
                message = `AI Signal: ${isBull ? 'BULL' : 'BEAR'} Q:${quality} P:${prob.toFixed(0)}%`;
              }
            }
            break;
        }
        
        if (triggered) {
          smartAlertsState.lastChecked[alert.id] = Date.now();
          alert.triggered = true;
          alert.triggerCount++;
          
          // Fire the alert
          fireSmartAlert(alert, message);
          
          // Add to history
          smartAlertsState.history.unshift({
            ...alert,
            message,
            triggeredAt: new Date().toISOString()
          });
          
          saveSmartAlerts();
          renderSmartAlerts();
          renderAlertHistory();
        }
      });
    }
    
    function fireSmartAlert(alert, message) {
      const fullMessage = ` ${getAlertDescription(alert)}: ${message}`;
      
      // Add to alerts panel
      addAlert(fullMessage, 'info');
      
      // Sound
      if (alert.options?.sound) {
        playSound('alert');
      }
      
      // Voice
      if (alert.options?.voice && voiceState.enabled) {
        speakAlert(fullMessage, 'high');
      }
      
      // Browser notification
      if (alert.options?.browser && Notification.permission === 'granted') {
        new Notification('ORACULUM Alert', { body: message, icon: '' });
      }
    }
    
    function renderAlertHistory() {
      const container = document.getElementById('alertHistory');
      if (!container) return;
      
      const recent = smartAlertsState.history.slice(0, 10);
      
      if (recent.length === 0) {
        container.innerHTML = '<div style="color:var(--text-dim); text-align:center; padding:10px;">No alerts triggered yet</div>';
        return;
      }
      
      container.innerHTML = recent.map(h => {
        const time = new Date(h.triggeredAt).toLocaleTimeString();
        const icon = { price: '', rsi: '', whale: '', signal: '' }[h.type] || '';
        return `
          <div style="display:flex; justify-content:space-between; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05);"><span>${icon} ${h.message || getAlertDescription(h)}</span><span style="color:var(--text-dim);">${time}</span></div>
        `;
      }).join('');
    }
    
    // Whale alert hook (called from whale tracking system)
    function checkWhaleAlerts(side, amount, price) {
      smartAlertsState.alerts.forEach(alert => {
        if (alert.type !== 'whale') return;
        if (alert.triggered && !alert.options?.repeat) return;
        
        const value = amount * price;
        if (value < alert.minSize) return;
        
        if ((side === 'BUY' && !alert.buyAlert) || (side === 'SELL' && !alert.sellAlert)) return;
        
        const lastCheck = smartAlertsState.lastChecked[alert.id] || 0;
        if (Date.now() - lastCheck < 30000) return; // 30s cooldown for whales
        
        smartAlertsState.lastChecked[alert.id] = Date.now();
        alert.triggered = true;
        alert.triggerCount++;
        
        const message = ` Whale ${side}: $${(value/1000).toFixed(0)}K @ $${price.toFixed(4)}`;
        fireSmartAlert(alert, message);
        
        smartAlertsState.history.unshift({
          ...alert,
          message,
          triggeredAt: new Date().toISOString()
        });
        
        saveSmartAlerts();
        renderSmartAlerts();
        renderAlertHistory();
      });
    }
    
    // Initialize smart alerts on load
    setTimeout(() => {
      renderSmartAlerts();
      renderAlertHistory();
    }, 1000);
    // ============================================
    // 4. FIBONACCI AUTO-LEVELS
    // ============================================
    async function updateFibonacci() {
      try {
        // Fetch 24h klines for swing detection
        const response = await fetch('https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=1h&limit=24');
        const data = await response.json();
        
        if (!data || data.length === 0) return;
        // Find swing high and low
        let high = 0, low = Infinity;
        data.forEach(k => {
          const h = parseFloat(k[2]);
          const l = parseFloat(k[3]);
          if (h > high) high = h;
          if (l < low) low = l;
        });
        const range = high - low;
        const currentPrice = state.price || parseFloat(data[data.length - 1][4]);
        // Calculate Fibonacci levels
        const levels = {
          '0': high,
          '236': high - (range * 0.236),
          '382': high - (range * 0.382),
          '50': high - (range * 0.5),
          '618': high - (range * 0.618),
          '786': high - (range * 0.786),
          '100': low
        };
        // Update UI
        document.getElementById('fibo-0').textContent = '$' + levels['0'].toFixed(4);
        document.getElementById('fibo-236').textContent = '$' + levels['236'].toFixed(4);
        document.getElementById('fibo-382').textContent = '$' + levels['382'].toFixed(4);
        document.getElementById('fibo-50').textContent = '$' + levels['50'].toFixed(4);
        document.getElementById('fibo-618').textContent = '$' + levels['618'].toFixed(4);
        document.getElementById('fibo-786').textContent = '$' + levels['786'].toFixed(4);
        document.getElementById('fibo-100').textContent = '$' + levels['100'].toFixed(4);
        
        document.getElementById('swing-high').textContent = '$' + high.toFixed(4);
        document.getElementById('swing-low').textContent = '$' + low.toFixed(4);
        document.getElementById('fibo-range').textContent = '$' + range.toFixed(4) + ' (' + ((range/low)*100).toFixed(2) + '%)';
        document.getElementById('fibo-current').textContent = '$' + currentPrice.toFixed(4);
        // Determine zone
        let zone = '';
        if (currentPrice > levels['236']) zone = 'Above 23.6% - Strong bullish zone';
        else if (currentPrice > levels['382']) zone = 'Between 23.6% - 38.2%';
        else if (currentPrice > levels['50']) zone = 'Between 38.2% - 50% - Key support zone';
        else if (currentPrice > levels['618']) zone = 'Between 50% - 61.8% - Critical zone';
        else if (currentPrice > levels['786']) zone = 'Between 61.8% - 78.6% - Danger zone';
        else zone = 'Below 78.6% - Potential reversal';
        
        document.getElementById('fibo-zone').textContent = zone;
      } catch (e) {
        console.error('Fibonacci error:', e);
      }
    }
    // ============================================
    // 5. SESSION STATS
    // ============================================
    const sessionStats = {
      startTime: Date.now(),
      startPrice: null,
      high: 0,
      low: Infinity,
      bullishSignals: 0,
      bearishSignals: 0,
      patternsDetected: 0,
      whaleTrades: 0,
      predictions: 0,
      correct: 0,
      incorrect: 0
    };
    function updateSessionStats() {
      // Usar batch update para reducir reflows
      Performance.batchUpdate('sessionStats', () => {
        const now = Date.now();
        const elapsed = now - sessionStats.startTime;
        const hours = Math.floor(elapsed / 3600000);
        const mins = Math.floor((elapsed % 3600000) / 60000);
        const secs = Math.floor((elapsed % 60000) / 1000);
        
        const durationEl = document.getElementById('session-duration');
        if (durationEl) durationEl.textContent = 
          String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
        if (state.price) {
          if (sessionStats.startPrice === null) sessionStats.startPrice = state.price;
          if (state.price > sessionStats.high) sessionStats.high = state.price;
          if (state.price < sessionStats.low) sessionStats.low = state.price;
          const highEl = document.getElementById('session-high');
          const lowEl = document.getElementById('session-low');
          const rangeEl = document.getElementById('session-range');
          const openEl = document.getElementById('session-open');
          const currentEl = document.getElementById('session-current');
          const changeEl = document.getElementById('session-change');
          
          if (highEl) {
            highEl.textContent = '$' + sessionStats.high.toFixed(4);
            highEl.style.color = 'var(--accent-green)';
          }
          if (lowEl) {
            lowEl.textContent = '$' + sessionStats.low.toFixed(4);
            lowEl.style.color = 'var(--accent-red)';
          }
          
          const range = ((sessionStats.high - sessionStats.low) / sessionStats.low * 100);
          if (rangeEl) {
            rangeEl.textContent = range.toFixed(2) + '%';
            rangeEl.style.color = range > 2 ? 'var(--accent-orange)' : 'var(--text-main)';
          }
          
          if (openEl) openEl.textContent = '$' + sessionStats.startPrice.toFixed(4);
          if (currentEl) currentEl.textContent = '$' + state.price.toFixed(4);
          
          const change = ((state.price - sessionStats.startPrice) / sessionStats.startPrice * 100);
          if (changeEl) {
            changeEl.textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
            changeEl.style.color = change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
          }
        }
        const bullEl = document.getElementById('session-signals-bull');
        const bearEl = document.getElementById('session-signals-bear');
        const patternsEl = document.getElementById('session-patterns');
        const whalesEl = document.getElementById('session-whales');
        const predsEl = document.getElementById('session-predictions');
        const correctEl = document.getElementById('session-correct');
        const incorrectEl = document.getElementById('session-incorrect');
        const accuracyEl = document.getElementById('session-accuracy');
        
        if (bullEl) bullEl.textContent = sessionStats.bullishSignals;
        if (bearEl) bearEl.textContent = sessionStats.bearishSignals;
        if (patternsEl) patternsEl.textContent = sessionStats.patternsDetected;
        if (whalesEl) whalesEl.textContent = sessionStats.whaleTrades;
        if (predsEl) predsEl.textContent = sessionStats.predictions;
        if (correctEl) correctEl.textContent = sessionStats.correct;
        if (incorrectEl) incorrectEl.textContent = sessionStats.incorrect;
        
        const accuracy = sessionStats.predictions > 0 ? (sessionStats.correct / sessionStats.predictions * 100) : 0;
        if (accuracyEl) accuracyEl.textContent = accuracy.toFixed(1) + '%';
      });
    }
    function resetSessionStats() {
      if (confirm('Reset all session statistics?')) {
        sessionStats.startTime = Date.now();
        sessionStats.startPrice = state.price;
        sessionStats.high = state.price || 0;
        sessionStats.low = state.price || Infinity;
        sessionStats.bullishSignals = 0;
        sessionStats.bearishSignals = 0;
        sessionStats.patternsDetected = 0;
        sessionStats.whaleTrades = 0;
        sessionStats.predictions = 0;
        sessionStats.correct = 0;
        sessionStats.incorrect = 0;
        updateSessionStats();
        addAlert('Session stats reset', 'info');
      }
    }
    // Track signals for session
    const originalAddAlert = window.addAlert;
    window.addAlert = function(msg, type) {
      if (type === 'bullish') sessionStats.bullishSignals++;
      if (type === 'bearish') sessionStats.bearishSignals++;
      if (msg.includes('pattern') || msg.includes('Pattern')) sessionStats.patternsDetected++;
      if (msg.includes('Whale') || msg.includes('whale')) sessionStats.whaleTrades++;
      originalAddAlert(msg, type);
    };
    // Update session stats every second
    setInterval(updateSessionStats, 5000); // Optimizado: 1s -> 5s
    // ============================================
    // 6. STRATEGY BUILDER
    // ============================================
    let customStrategies = [];
    function createStrategy() {
      const name = document.getElementById('strategyName').value.trim();
      if (!name) {
        alert('Please enter a strategy name');
        return;
      }
      const ind1 = document.getElementById('strategy-ind-1').value;
      const op1 = document.getElementById('strategy-op-1').value;
      const val1 = document.getElementById('strategy-val-1').value;
      const logic = document.getElementById('strategy-logic').value;
      const ind2 = document.getElementById('strategy-ind-2').value;
      const op2 = document.getElementById('strategy-op-2').value;
      const val2 = document.getElementById('strategy-val-2').value;
      const alertType = document.getElementById('strategy-alert-type').value;
      if (!val1) {
        alert('Please enter a value for condition 1');
        return;
      }
      const strategy = {
        id: Date.now(),
        name: name,
        condition1: { indicator: ind1, operator: op1, value: parseFloat(val1) },
        logic: logic,
        condition2: ind2 ? { indicator: ind2, operator: op2, value: parseFloat(val2) } : null,
        alertType: alertType,
        active: true,
        triggered: false,
        lastTriggered: null
      };
      customStrategies.push(strategy);
      saveStrategies();
      renderStrategies();
      
      // Clear form
      document.getElementById('strategyName').value = '';
      document.getElementById('strategy-val-1').value = '';
      document.getElementById('strategy-val-2').value = '';
      document.getElementById('strategy-ind-2').value = '';
      
      addAlert(`Strategy created: ${name}`, 'info');
    }
    function getIndicatorValue(indicator) {
      switch(indicator) {
        case 'rsi': return state.indicators?.rsi || 50;
        case 'stochRsi': return state.indicators?.stochRsi || 50;
        case 'macd': return state.indicators?.macd || 0;
        case 'price': return state.price || 0;
        case 'volume': return state.volume24h || 0;
        case 'funding': return state.fundingRate || 0;
        default: return 0;
      }
    }
    function evaluateCondition(condition, prevValue) {
      const currentValue = getIndicatorValue(condition.indicator);
      switch(condition.operator) {
        case '<': return currentValue < condition.value;
        case '>': return currentValue > condition.value;
        case 'cross_up': return prevValue < condition.value && currentValue >= condition.value;
        case 'cross_down': return prevValue > condition.value && currentValue <= condition.value;
        default: return false;
      }
    }
    const prevIndicatorValues = {};
    function checkStrategies() {
      customStrategies.forEach(strategy => {
        if (!strategy.active) return;
        
        // Cooldown: don't trigger same strategy within 60 seconds
        if (strategy.lastTriggered && Date.now() - strategy.lastTriggered < 60000) return;
        const cond1Met = evaluateCondition(strategy.condition1, prevIndicatorValues[strategy.condition1.indicator]);
        let result = cond1Met;
        if (strategy.condition2) {
          const cond2Met = evaluateCondition(strategy.condition2, prevIndicatorValues[strategy.condition2.indicator]);
          result = strategy.logic === 'AND' ? (cond1Met && cond2Met) : (cond1Met || cond2Met);
        }
        if (result) {
          strategy.lastTriggered = Date.now();
          const msg = ` Strategy "${strategy.name}" triggered!`;
          addAlert(msg, strategy.alertType);
          
          if (Notification.permission === 'granted') {
            new Notification('XRP ORACULUM Strategy', { body: msg });
          }
        }
      });
      // Store previous values for cross detection
      prevIndicatorValues.rsi = state.indicators?.rsi || 50;
      prevIndicatorValues.stochRsi = state.indicators?.stochRsi || 50;
      prevIndicatorValues.macd = state.indicators?.macd || 0;
      prevIndicatorValues.price = state.price || 0;
    }
    function toggleStrategy(id) {
      const strategy = customStrategies.find(s => s.id === id);
      if (strategy) {
        strategy.active = !strategy.active;
        saveStrategies();
        renderStrategies();
      }
    }
    function deleteStrategy(id) {
      customStrategies = customStrategies.filter(s => s.id !== id);
      saveStrategies();
      renderStrategies();
    }
    function renderStrategies() {
      const container = document.getElementById('strategiesList');
      document.getElementById('strategiesCount').textContent = `(${customStrategies.length})`;
      if (customStrategies.length === 0) {
        container.innerHTML = '<div class="no-alerts">No strategies created yet. Build your first strategy!</div>';
        return;
      }
      container.innerHTML = customStrategies.map(s => {
        const cond1Text = `${s.condition1.indicator.toUpperCase()} ${s.condition1.operator} ${s.condition1.value}`;
        const cond2Text = s.condition2 ? ` ${s.logic} ${s.condition2.indicator.toUpperCase()} ${s.condition2.operator} ${s.condition2.value}` : '';
        
        return `
          <div class="strategy-item ${s.active ? 'active' : ''}"><div class="strategy-item-header"><span class="strategy-item-name">${s.name}</span><div style="display:flex; align-items:center; gap:10px;"><div class="strategy-item-toggle ${s.active ? 'active' : ''}" onclick="toggleStrategy(${s.id})"></div><button class="alert-delete" onclick="deleteStrategy(${s.id})"></button></div></div><div class="strategy-conditions">
              IF ${cond1Text}${cond2Text}  ${s.alertType.toUpperCase()} alert
            </div></div>
        `;
      }).join('');
    }
    function saveStrategies() {
      try {
        localStorage.setItem('xrp_oraculum_strategies', JSON.stringify(customStrategies));
      } catch(e) {}
    }
    function loadStrategies() {
      try {
        const saved = localStorage.getItem('xrp_oraculum_strategies');
        if (saved) {
          customStrategies = JSON.parse(saved);
          renderStrategies();
        }
      } catch(e) {}
    }
    // ============================================
    // 7. CORRELATION TRACKER
    // ============================================
    async function updateCorrelations() {
      const pairs = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      const xrpData = await fetchPriceHistory('XRPUSDT');
      
      for (const pair of pairs) {
        const pairData = await fetchPriceHistory(pair);
        if (xrpData && pairData) {
          const corr = calculateCorrelation(xrpData.returns, pairData.returns);
          const symbol = pair.replace('USDT', '').toLowerCase();
          
          const corrEl = document.getElementById(`corr-${symbol}`);
          corrEl.textContent = corr.toFixed(2);
          corrEl.className = 'corr-value ' + (corr > 0.3 ? 'positive' : corr < -0.3 ? 'negative' : 'neutral');
          
          const barEl = document.getElementById(`corr-${symbol}-bar`);
          barEl.style.width = (Math.abs(corr) * 100) + '%';
          barEl.style.background = corr > 0 ? 'var(--accent-green)' : 'var(--accent-red)';
          
          document.getElementById(`corr-${symbol}-price`).textContent = '$' + pairData.price.toFixed(symbol === 'btc' ? 0 : 2);
          const changeEl = document.getElementById(`corr-${symbol}-change`);
          changeEl.textContent = (pairData.change >= 0 ? '+' : '') + pairData.change.toFixed(2) + '%';
          changeEl.style.color = pairData.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        }
      }
    }
    async function fetchPriceHistory(symbol) {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=24`);
        const data = await response.json();
        
        const closes = data.map(k => parseFloat(k[4]));
        const returns = [];
        for (let i = 1; i < closes.length; i++) {
          returns.push((closes[i] - closes[i-1]) / closes[i-1]);
        }
        
        const price = closes[closes.length - 1];
        const change = ((closes[closes.length - 1] - closes[0]) / closes[0]) * 100;
        
        return { returns, price, change };
      } catch(e) {
        return null;
      }
    }
    function calculateCorrelation(arr1, arr2) {
      const n = Math.min(arr1.length, arr2.length);
      if (n === 0) return 0;
      
      const mean1 = arr1.reduce((a, b) => a + b, 0) / n;
      const mean2 = arr2.reduce((a, b) => a + b, 0) / n;
      
      let num = 0, den1 = 0, den2 = 0;
      for (let i = 0; i < n; i++) {
        const d1 = arr1[i] - mean1;
        const d2 = arr2[i] - mean2;
        num += d1 * d2;
        den1 += d1 * d1;
        den2 += d2 * d2;
      }
      
      return den1 && den2 ? num / Math.sqrt(den1 * den2) : 0;
    }
    // ============================================
    // 8. WATCHLIST
    // ============================================
    const watchlistSymbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'DOGEUSDT'];
    async function updateWatchlist() {
      for (const symbol of watchlistSymbols) {
        try {
          const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
          const data = await response.json();
          
          const shortSymbol = symbol.replace('USDT', '').toLowerCase();
          const price = parseFloat(data.lastPrice);
          const change = parseFloat(data.priceChangePercent);
          
          const priceEl = document.getElementById(`watch-${shortSymbol}-price`);
          const changeEl = document.getElementById(`watch-${shortSymbol}-change`);
          
          if (priceEl) {
            priceEl.textContent = '$' + (price > 100 ? price.toFixed(0) : price.toFixed(price > 1 ? 2 : 4));
          }
          
          if (changeEl) {
            changeEl.textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
            changeEl.className = 'watchlist-change ' + (change >= 0 ? 'up' : 'down');
          }
          
          // Mini chart
          updateMiniChart(shortSymbol, symbol);
          
        } catch(e) {}
      }
    }
    async function updateMiniChart(shortSymbol, symbol) {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=8`);
        const data = await response.json();
        
        const container = document.getElementById(`chart-${shortSymbol}`);
        if (!container) return;
        
        const closes = data.map(k => parseFloat(k[4]));
        const min = Math.min(...closes);
        const max = Math.max(...closes);
        const range = max - min || 1;
        
        container.innerHTML = closes.map((c, i) => {
          const height = ((c - min) / range * 100);
          const color = i > 0 && closes[i] >= closes[i-1] ? 'var(--accent-green)' : 'var(--accent-red)';
          return `<div class="mini-bar" style="height:${Math.max(10, height)}%; background:${color};"></div>`;
        }).join('');
      } catch(e) {}
    }
    // ============================================
    // INITIALIZATION FOR NEW TOOLS
    // ============================================
    // Load saved data and start updates
    loadStrategies();
    
    // Update watchlist every 10 seconds
    setInterval(updateWatchlist, 30000); // Optimizado: 10s -> 30s
    updateWatchlist();
    
    // Update correlations every 2 minutes
    setInterval(updateCorrelations, 120000);
    
    // Update Fibonacci when tools panel opens
    const origToggleToolsPanel = toggleToolsPanel;
    toggleToolsPanel = function() {
      origToggleToolsPanel();
      if (document.getElementById('toolsOverlay').classList.contains('active')) {
        updateFibonacci();
        updateCorrelations();
        updateWatchlist();
      }
    };
  </script><!-- ============================================
       MULTI-CHART MODE OVERLAY
       ============================================ --><div class="multichart-overlay" id="multiChartOverlay"><div class="multichart-container"><div class="multichart-header"><h2>ðŸ“Š MULTI-CHART MODE</h2><span style="color:var(--text-dim); font-size:12px;">Real-time 4-Asset View</span><button class="multichart-close" onclick="toggleMultiChart()"></button></div><div class="multichart-grid"><!-- XRP Chart --><div class="mini-chart-card" id="miniChart-XRP"><div class="mini-chart-header"><span class="mini-chart-symbol">XRP/USDT</span><span class="mini-chart-price" id="mc-price-XRP">--</span><span class="mini-chart-change" id="mc-change-XRP">--%</span></div><div class="mini-chart-container" id="mc-chart-XRP"></div><div class="mini-chart-footer"><span>RSI: <span id="mc-rsi-XRP">--</span></span><span>Vol: <span id="mc-vol-XRP">--</span></span><span class="mini-chart-signal" id="mc-signal-XRP">--</span></div></div><!-- XLM Chart --><div class="mini-chart-card" id="miniChart-XLM"><div class="mini-chart-header"><span class="mini-chart-symbol">XLM/USDT</span><span class="mini-chart-price" id="mc-price-XLM">--</span><span class="mini-chart-change" id="mc-change-XLM">--%</span></div><div class="mini-chart-container" id="mc-chart-XLM"></div><div class="mini-chart-footer"><span>RSI: <span id="mc-rsi-XLM">--</span></span><span>Vol: <span id="mc-vol-XLM">--</span></span><span class="mini-chart-signal" id="mc-signal-XLM">--</span></div></div><!-- JASMY Chart --><div class="mini-chart-card" id="miniChart-JASMY"><div class="mini-chart-header"><span class="mini-chart-symbol">JASMY/USDT</span><span class="mini-chart-price" id="mc-price-JASMY">--</span><span class="mini-chart-change" id="mc-change-JASMY">--%</span></div><div class="mini-chart-container" id="mc-chart-JASMY"></div><div class="mini-chart-footer"><span>RSI: <span id="mc-rsi-JASMY">--</span></span><span>Vol: <span id="mc-vol-JASMY">--</span></span><span class="mini-chart-signal" id="mc-signal-JASMY">--</span></div></div><!-- HBAR Chart --><div class="mini-chart-card" id="miniChart-HBAR"><div class="mini-chart-header"><span class="mini-chart-symbol">HBAR/USDT</span><span class="mini-chart-price" id="mc-price-HBAR">--</span><span class="mini-chart-change" id="mc-change-HBAR">--%</span></div><div class="mini-chart-container" id="mc-chart-HBAR"></div><div class="mini-chart-footer"><span>RSI: <span id="mc-rsi-HBAR">--</span></span><span>Vol: <span id="mc-vol-HBAR">--</span></span><span class="mini-chart-signal" id="mc-signal-HBAR">--</span></div></div></div><!-- Summary Bar --><div class="multichart-summary"><div class="summary-item"><span class="summary-label">STRONGEST</span><span class="summary-value" id="mc-strongest" style="color:var(--accent-green)">--</span></div><div class="summary-item"><span class="summary-label">WEAKEST</span><span class="summary-value" id="mc-weakest" style="color:var(--accent-red)">--</span></div><div class="summary-item"><span class="summary-label">MARKET MOOD</span><span class="summary-value" id="mc-mood">--</span></div><div class="summary-item"><span class="summary-label">CORRELATION</span><span class="summary-value" id="mc-correlation">--</span></div></div></div></div><style>
    /* Multi-Chart Mode Styles */
    .multichart-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(2, 6, 12, 0.95);
      z-index: 9999;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
    }
    
    .multichart-overlay.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    .multichart-container {
      max-width: 1600px;
      margin: 0 auto;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .multichart-header {
      display: flex;
      align-items: center;
      gap: 15px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 15px;
    }
    
    .multichart-header h2 {
      margin: 0;
      color: var(--accent-cyan);
      font-size: 20px;
    }
    
    .multichart-close {
      margin-left: auto;
      background: rgba(255, 68, 102, 0.2);
      border: 1px solid var(--accent-red);
      color: var(--accent-red);
      width: 36px;
      height: 36px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.3s;
    }
    
    .multichart-close:hover {
      background: var(--accent-red);
      color: #fff;
    }
    
    .multichart-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      flex: 1;
      min-height: 0;
    }
    
    .mini-chart-card {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: all 0.3s;
    }
    
    .mini-chart-card:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.1);
    }
    
    .mini-chart-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .mini-chart-symbol {
      font-weight: bold;
      font-size: 14px;
      color: var(--accent-cyan);
    }
    
    .mini-chart-price {
      font-family: var(--font-data);
      font-size: 16px;
      font-weight: bold;
    }
    
    .mini-chart-change {
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0, 255, 136, 0.1);
    }
    
    .mini-chart-change.positive { color: var(--accent-green); background: rgba(0, 255, 136, 0.1); }
    .mini-chart-change.negative { color: var(--accent-red); background: rgba(255, 68, 102, 0.1); }
    
    .mini-chart-container {
      flex: 1;
      min-height: 200px;
      background: rgba(0,0,0,0.2);
    }
    
    .mini-chart-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 15px;
      font-size: 11px;
      color: var(--text-dim);
      background: rgba(0,0,0,0.3);
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    
    .mini-chart-signal {
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 10px;
    }
    
    .mini-chart-signal.bullish { background: rgba(0, 255, 136, 0.2); color: var(--accent-green); }
    .mini-chart-signal.bearish { background: rgba(255, 68, 102, 0.2); color: var(--accent-red); }
    .mini-chart-signal.neutral { background: rgba(255, 255, 255, 0.1); color: var(--text-dim); }
    
    .multichart-summary {
      display: flex;
      justify-content: space-around;
      padding: 15px;
      background: rgba(0, 212, 255, 0.05);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 10px;
      margin-top: 15px;
    }
    
    .summary-item {
      text-align: center;
    }
    
    .summary-label {
      display: block;
      font-size: 9px;
      color: var(--text-dim);
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .summary-value {
      font-size: 14px;
      font-weight: bold;
      color: var(--accent-cyan);
    }
    
    @media (max-width: 900px) {
      .multichart-grid {
        grid-template-columns: 1fr;
      }
      .mini-chart-container {
        min-height: 150px;
      }
    }
  </style><script nonce="okrt-oraculum-nonce-2026">
    // ============================================
    // MULTI-CHART MODE FUNCTIONALITY
    // ============================================
    
    const multiChartAssets = {
      XRP: { symbol: 'XRPUSDT', name: 'XRP', decimals: 4 },
      XLM: { symbol: 'XLMUSDT', name: 'XLM', decimals: 5 },
      JASMY: { symbol: 'JASMYUSDT', name: 'JASMY', decimals: 6 },
      HBAR: { symbol: 'HBARUSDT', name: 'HBAR', decimals: 5 }
    };
    
    const multiChartState = {
      active: false,
      charts: {},
      data: {},
      ws: null
    };
    
    function toggleMultiChart() {
      const overlay = document.getElementById('multiChartOverlay');
      multiChartState.active = !multiChartState.active;
      
      if (multiChartState.active) {
        overlay.classList.add('active');
        initMultiCharts();
        connectMultiChartWS();
      } else {
        overlay.classList.remove('active');
        if (multiChartState.ws) {
          multiChartState.ws.close();
          multiChartState.ws = null;
        }
      }
    }
    
    function initMultiCharts() {
      Object.keys(multiChartAssets).forEach(asset => {
        const container = document.getElementById(`mc-chart-${asset}`);
        if (!container || multiChartState.charts[asset]) return;
        
        const chart = LightweightCharts.createChart(container, {
          width: container.clientWidth,
          height: container.clientHeight,
          layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#94a3b8' },
          grid: { vertLines: { color: 'rgba(255,255,255,0.02)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
          rightPriceScale: { borderColor: 'rgba(255,255,255,0.05)', scaleMargins: { top: 0.1, bottom: 0.1 } },
          timeScale: { borderColor: 'rgba(255,255,255,0.05)', timeVisible: true, visible: false },
          crosshair: { mode: 0 },
          localization: {
            timeFormatter: (timestamp) => {
              const date = new Date(timestamp * 1000);
              return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
          }
        });
        
        const candleSeries = chart.addCandlestickSeries({
          upColor: '#00ff88', downColor: '#ff4466',
          borderUpColor: '#00ff88', borderDownColor: '#ff4466',
          wickUpColor: '#00ff88', wickDownColor: '#ff4466'
        });
        
        multiChartState.charts[asset] = { chart, candleSeries };
        multiChartState.data[asset] = { candles: [], price: 0, change: 0 };
        
        // Fetch historical data
        fetchMultiChartData(asset);
        
        // Debounced resize observer
        let mcResizeTimeout = null;
        new ResizeObserver(() => {
          if (mcResizeTimeout) clearTimeout(mcResizeTimeout);
          mcResizeTimeout = setTimeout(() => {
            try {
              chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
            } catch(e) {}
          }, 150);
        }).observe(container);
      });
    }
    
    async function fetchMultiChartData(asset) {
      try {
        const symbol = multiChartAssets[asset].symbol;
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=5m&limit=50`);
        const data = await response.json();
        
        const candles = data.map(d => ({
          time: d[0] / 1000,
          open: parseFloat(d[1]),
          high: parseFloat(d[2]),
          low: parseFloat(d[3]),
          close: parseFloat(d[4]),
          volume: parseFloat(d[5])
        }));
        
        multiChartState.data[asset].candles = candles;
        
        if (multiChartState.charts[asset]) {
          multiChartState.charts[asset].candleSeries.setData(candles);
        }
        
        // Calculate RSI
        const closes = candles.map(c => c.close);
        const rsi = calcRSI(closes, 14);
        document.getElementById(`mc-rsi-${asset}`).innerText = rsi ? rsi.toFixed(0) : '--';
        
        // Update signal
        updateMiniChartSignal(asset, rsi, closes);
        
      } catch (e) {
        console.error(`Error fetching ${asset} data:`, e);
      }
    }
    
    function connectMultiChartWS() {
      const streams = Object.values(multiChartAssets)
        .map(a => `${a.symbol.toLowerCase()}@ticker`)
        .join('/');
      
      const wsUrl = `wss://stream.binance.com:9443/stream?streams=${streams}`;
      
      multiChartState.ws = new WebSocket(wsUrl);
      
      multiChartState.ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (!msg.data) return;
        
        const ticker = msg.data;
        const symbol = ticker.s;
        const asset = Object.keys(multiChartAssets).find(a => multiChartAssets[a].symbol === symbol);
        
        if (!asset) return;
        
        const price = parseFloat(ticker.c);
        const change = parseFloat(ticker.P);
        const volume = parseFloat(ticker.v);
        const decimals = multiChartAssets[asset].decimals;
        
        multiChartState.data[asset].price = price;
        multiChartState.data[asset].change = change;
        
        // Update UI
        document.getElementById(`mc-price-${asset}`).innerText = price.toFixed(decimals);
        
        const changeEl = document.getElementById(`mc-change-${asset}`);
        changeEl.innerText = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
        changeEl.className = 'mini-chart-change ' + (change >= 0 ? 'positive' : 'negative');
        
        document.getElementById(`mc-vol-${asset}`).innerText = (volume / 1000000).toFixed(1) + 'M';
      };
      
      multiChartState.ws.onerror = (e) => console.error('MultiChart WS error:', e);
    }
    
    function updateMiniChartSignal(asset, rsi, closes) {
      const signalEl = document.getElementById(`mc-signal-${asset}`);
      if (!signalEl) return;
      
      // Simple signal based on RSI and trend
      const sma = closes.slice(-10).reduce((a,b) => a+b, 0) / 10;
      const currentPrice = closes[closes.length - 1];
      const trend = currentPrice > sma ? 'up' : 'down';
      
      let signal = 'NEUTRAL';
      let signalClass = 'neutral';
      
      if (rsi < 30 && trend === 'down') {
        signal = 'OVERSOLD';
        signalClass = 'bullish';
      } else if (rsi > 70 && trend === 'up') {
        signal = 'OVERBOUGHT';
        signalClass = 'bearish';
      } else if (rsi > 50 && trend === 'up') {
        signal = 'BULLISH';
        signalClass = 'bullish';
      } else if (rsi < 50 && trend === 'down') {
        signal = 'BEARISH';
        signalClass = 'bearish';
      }
      
      signalEl.innerText = signal;
      signalEl.className = 'mini-chart-signal ' + signalClass;
    }
    
    function updateMultiChartSummary() {
      const assets = Object.keys(multiChartAssets);
      let strongest = { asset: '--', change: -Infinity };
      let weakest = { asset: '--', change: Infinity };
      let bullCount = 0;
      
      assets.forEach(asset => {
        const data = multiChartState.data[asset];
        if (!data) return;
        
        if (data.change > strongest.change) {
          strongest = { asset, change: data.change };
        }
        if (data.change < weakest.change) {
          weakest = { asset, change: data.change };
        }
        if (data.change > 0) bullCount++;
      });
      
      document.getElementById('mc-strongest').innerText = `${strongest.asset} (${strongest.change >= 0 ? '+' : ''}${strongest.change.toFixed(2)}%)`;
      document.getElementById('mc-weakest').innerText = `${weakest.asset} (${weakest.change.toFixed(2)}%)`;
      
      const mood = bullCount >= 3 ? 'BULLISH' : bullCount >= 2 ? 'MIXED' : 'BEARISH';
      const moodEl = document.getElementById('mc-mood');
      moodEl.innerText = mood;
      moodEl.style.color = mood === 'BULLISH' ? 'var(--accent-green)' : mood === 'BEARISH' ? 'var(--accent-red)' : 'var(--accent-orange)';
      
      // Simple correlation (all moving same direction)
      const sameDirection = assets.filter(a => multiChartState.data[a]?.change > 0).length;
      const corr = sameDirection === 4 || sameDirection === 0 ? 'HIGH' : sameDirection === 3 || sameDirection === 1 ? 'MEDIUM' : 'LOW';
      document.getElementById('mc-correlation').innerText = corr;
    }
    
    // Update summary every 5 seconds when active
    setInterval(() => {
      if (multiChartState.active) {
        updateMultiChartSummary();
      }
    }, 5000);
    
    // Keyboard shortcut: M for Multi-Chart
    document.addEventListener('keydown', (e) => {
      if (e.key === 'm' || e.key === 'M') {
        if (!e.target.matches('input, textarea, select')) {
          toggleMultiChart();
        }
      }
    });
  </script><!-- PWA INSTALL BANNER --><div class="pwa-install-banner" id="pwaInstallBanner"><div class="pwa-install-content"><div class="pwa-install-icon"><span>X</span></div><div class="pwa-install-text"><h4>Install XRP ORACULUM</h4><p>Add to home screen for the best experience</p></div></div><button class="pwa-install-btn" id="pwaInstallBtn">
       INSTALL APP
    </button><button class="pwa-install-close" id="pwaInstallClose"></button></div><!-- iOS INSTALL INSTRUCTIONS MODAL --><div class="ios-install-modal" id="iosInstallModal"><div class="ios-install-content"><h3>ðŸ“± Install on iPhone/iPad</h3><div class="ios-step"><div class="ios-step-num">1</div><div class="ios-step-text">Tap the <span class="ios-step-icon"></span> Share button in Safari</div></div><div class="ios-step"><div class="ios-step-num">2</div><div class="ios-step-text">Scroll down and tap <strong>"Add to Home Screen"</strong></div></div><div class="ios-step"><div class="ios-step-num">3</div><div class="ios-step-text">Tap <strong>"Add"</strong> to install the app</div></div><button class="add-alert-btn" onclick="closeIosModal()" style="margin-top:20px;">Got it!</button></div></div><script nonce="okrt-oraculum-nonce-2026">
    // ============================================
    // PWA INSTALLATION LOGIC
    // ============================================
    let deferredPrompt = null;
    const pwaInstallBanner = document.getElementById('pwaInstallBanner');
    const pwaInstallBtn = document.getElementById('pwaInstallBtn');
    const pwaInstallClose = document.getElementById('pwaInstallClose');
    const iosInstallModal = document.getElementById('iosInstallModal');
    // Detect if running as installed PWA
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                         window.navigator.standalone === true;
    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    // Detect if already dismissed
    const pwaDismissed = localStorage.getItem('pwa_install_dismissed');
    const pwaDismissedTime = pwaDismissed ? parseInt(pwaDismissed) : 0;
    const daysSinceDismiss = (Date.now() - pwaDismissedTime) / (1000 * 60 * 60 * 24);
    // Show banner after delay if not installed and not recently dismissed
    function checkShowInstallBanner() {
      if (isStandalone) return; // Already installed
      if (daysSinceDismiss < 7 && pwaDismissed) return; // Dismissed within 7 days
      
      setTimeout(() => {
        if (isIOS) {
          // Show iOS-specific banner
          pwaInstallBanner.classList.add('show');
          pwaInstallBtn.textContent = ' HOW TO INSTALL';
        } else if (deferredPrompt) {
          // Show Android/Desktop banner
          pwaInstallBanner.classList.add('show');
        }
      }, 5000); // Show after 5 seconds
    }
    // Listen for beforeinstallprompt (Android/Desktop)
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      checkShowInstallBanner();
    });
    // Handle install button click
    pwaInstallBtn.addEventListener('click', async () => {
      if (isIOS) {
        // Show iOS instructions
        iosInstallModal.classList.add('show');
        pwaInstallBanner.classList.remove('show');
      } else if (deferredPrompt) {
        // Trigger native install prompt
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        
        if (outcome === 'accepted') {
          console.log('PWA installed');
          addAlert(' App installed successfully!', 'bullish');
        }
        
        deferredPrompt = null;
        pwaInstallBanner.classList.remove('show');
      }
    });
    // Handle close button
    pwaInstallClose.addEventListener('click', () => {
      pwaInstallBanner.classList.remove('show');
      localStorage.setItem('pwa_install_dismissed', Date.now().toString());
    });
    // Close iOS modal
    function closeIosModal() {
      iosInstallModal.classList.add('show');
      iosInstallModal.classList.remove('show');
      localStorage.setItem('pwa_install_dismissed', Date.now().toString());
    }
    // Close iOS modal on outside click
    iosInstallModal.addEventListener('click', (e) => {
      if (e.target === iosInstallModal) {
        closeIosModal();
      }
    });
    // Listen for successful installation
    window.addEventListener('appinstalled', () => {
      console.log('XRP ORACULUM installed');
      pwaInstallBanner.classList.remove('show');
      deferredPrompt = null;
    });
    // Check on load
    if (!isStandalone) {
      checkShowInstallBanner();
    }
    // ============================================
    // SERVICE WORKER REGISTRATION
    // ============================================
    // Create and register Service Worker inline
    const swCode = `
      const CACHE_NAME = 'xrp-oraculum-v3-cache';
      const OFFLINE_URL = '/offline.html';
      
      // Assets to cache immediately
      const PRECACHE_ASSETS = [
        './',
        './index.html'
      ];
      
      // Install event
      self.addEventListener('install', (event) => {
        console.log('[SW] Installing...');
        self.skipWaiting();
      });
      
      // Activate event
      self.addEventListener('activate', (event) => {
        console.log('[SW] Activated');
        event.waitUntil(clients.claim());
      });
      
      // Fetch event - Network first, fallback to cache
      self.addEventListener('fetch', (event) => {
        // Skip non-GET requests
        if (event.request.method !== 'GET') return;
        
        // Skip API requests (always fetch from network)
        if (event.request.url.includes('api.binance.com') || 
            event.request.url.includes('api.alternative.me')) {
          return;
        }
        
        event.respondWith(
          fetch(event.request)
            .then((response) => {
              // Clone and cache successful responses
              if (response.ok) {
                const responseClone = response.clone();
                caches.open(CACHE_NAME).then((cache) => {
                  cache.put(event.request, responseClone);
                });
              }
              return response;
            })
            .catch(() => {
              // Fallback to cache
              return caches.match(event.request);
            })
        );
      });
    `;
    // Register Service Worker (disabled in single-file build)
    // NOTE: Registering a Service Worker from a Blob/Data URL triggers
    // `ServiceWorkerContainer.register: Script URL's scheme is not 'http' or 'https'`.
    // This project is deployed as a single HTML file on GitHub Pages, so we skip SW registration.
    if ('serviceWorker' in navigator && location.protocol === 'https:') {
      console.log('[PWA] Service Worker registration disabled (single-file build).');
    }
    // ============================================
    // ONLINE/OFFLINE STATUS
    // ============================================
    function updateOnlineStatus() {
      if (!navigator.onLine) {
        addAlert(' You are offline. Some features may be limited.', 'warning');
        document.getElementById('apiStatusText').textContent = 'OFFLINE';
        document.getElementById('statusPill').classList.remove('status-live');
        document.getElementById('statusPill').classList.add('status-err');
      }
    }
    window.addEventListener('online', () => {
      addAlert(' Back online! Reconnecting...', 'bullish');
      // Reconnect WebSocket
      if (typeof connectWebSocket === 'function') {
        connectWebSocket();
      }
    });
    window.addEventListener('offline', updateOnlineStatus);
    // Check initial status
    if (!navigator.onLine) {
      updateOnlineStatus();
    }
    // ============================================
    // MOBILE TOUCH OPTIMIZATIONS
    // ============================================
    // Prevent double-tap zoom on buttons
    document.addEventListener('touchend', (e) => {
      if (e.target.tagName === 'BUTTON' || e.target.classList.contains('control-btn')) {
        e.preventDefault();
        e.target.click();
      }
    }, { passive: false });
    // Improve scroll performance
    document.addEventListener('touchstart', () => {}, { passive: true });
    document.addEventListener('touchmove', () => {}, { passive: true });
    // Handle viewport height on mobile (fixes 100vh issue)
    function setVH() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    setVH();
    window.addEventListener('resize', setVH);
    // ============================================
    // KEYBOARD SHORTCUTS
    // ============================================
    document.addEventListener('keydown', (e) => {
      // T = Toggle Tools
      if (e.key === 't' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        toggleToolsPanel();
      }
      // Escape = Close modals
      if (e.key === 'Escape') {
        document.getElementById('toolsOverlay').classList.remove('active');
        iosInstallModal.classList.remove('show');
      }
      // S = Toggle sound
      if (e.key === 's' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        toggleSound();
      }
      // D = Toggle dark/light mode
      if (e.key === 'd' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        toggleTheme();
      }
      // L = Toggle Lite mode (performance)
      if (e.key === 'l' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        const isLite = Performance.toggleLiteMode();
        addAlert(isLite ? ' Lite Mode ON - Reduced updates for better performance' : ' Lite Mode OFF - Full updates restored', 'info');
      }
    });
    console.log('%c  XRP ORACULUM ', 'background: linear-gradient(135deg, #00d4ff, #a855f7); color: #000; font-size: 20px; font-weight: bold; padding: 10px 20px; border-radius: 5px;');
    console.log('%c OkrtSystem Labs ', 'color: #00d4ff; font-size: 14px; font-weight: bold;');
    console.log('%c Keyboard shortcuts: T=Tools, S=Sound, D=Dark mode, L=Lite mode, ESC=Close ', 'color: #94a3b8; font-size: 10px;');
  </script><script nonce="okrt-oraculum-nonce-2026">window.AILearning=AILearning;</script>
<script nonce="okrt-oraculum-nonce-2026">
(()=>{
  const __OKRT_FB_VER__='10.7.1';
  async function __okrtEnsureAnonAuth__(){
    try{
      const appMod = await import(`https://www.gstatic.com/firebasejs/${__OKRT_FB_VER__}/firebase-app.js`);
      const authMod = await import(`https://www.gstatic.com/firebasejs/${__OKRT_FB_VER__}/firebase-auth.js`);
      const { getApps, initializeApp } = appMod;
      const { getAuth, signInAnonymously } = authMod;

      let app = (getApps && getApps()[0]) || null;
      if(!app && typeof FIREBASE_CONFIG==='object') app = initializeApp(FIREBASE_CONFIG);
      if(!app) return;

      // App Check (reCAPTCHA v3) - protects Firestore quota on public deployments
      if(!window.__OKRT_APP_CHECK_INIT__){
        try{
          const acMod = await import(`https://www.gstatic.com/firebasejs/${__OKRT_FB_VER__}/firebase-app-check.js`);
          const { initializeAppCheck, ReCaptchaV3Provider } = acMod;
          window.__OKRT_APP_CHECK__ = initializeAppCheck(app, {
            provider: new ReCaptchaV3Provider('6LeXcEwsAAAAAPNEGSZy0Cizk0Hg6sfabN18E5ga'),
            isTokenAutoRefreshEnabled: true
          });
          window.__OKRT_APP_CHECK_INIT__ = true;
          console.log('[APP CHECK] Enabled');
        }catch(e){
          console.warn('[APP CHECK] init failed:', e && e.message ? e.message : e);
        }
      }

      const auth = getAuth(app);
      if(auth.currentUser){
        window.__OKRT_UID__ = auth.currentUser.uid;
        if(window.AILearning) window.AILearning.user = window.__OKRT_UID__ || window.AILearning.user;
        return;
      }

      await signInAnonymously(auth);
      window.__OKRT_UID__ = auth.currentUser ? auth.currentUser.uid : null;
      if(window.AILearning) window.AILearning.user = window.__OKRT_UID__ || window.AILearning.user;
      console.log('[AUTH] Anonymous session OK:', window.__OKRT_UID__ ? window.__OKRT_UID__.slice(0,8) : 'null');
    }catch(e){
      console.warn('[AUTH] Anonymous auth skipped:', e && e.message ? e.message : e);
    }
  }
  __okrtEnsureAnonAuth__();
  document.addEventListener('DOMContentLoaded', ()=>setTimeout(__okrtEnsureAnonAuth__, 200));
})();
</script>
<script src="ai-engine-pro.js?v=1.2.2"></script> 
<!-- ========================= -->
<!-- MARKET FEED MANAGER (Multi-feed + Failover) -->
<!-- ========================= -->
<script src="market-feed-manager.js"></script>

<script nonce="okrt-oraculum-nonce-2026">
(function(){
    if(typeof MarketFeedManager === 'undefined'){
        console.warn('[FEED] MarketFeedManager not loaded');
        return;
    }

    const SYMBOL = 'XRPUSDT';

    const onCandle = function(candle){
        // Enlaza con tu AI Engine PRO sin tocar su lÃ³gica
        if(window.AIEnginePro && typeof window.AIEnginePro.onMarketData === 'function'){
            window.AIEnginePro.onMarketData(candle);
        }
    };

    document.addEventListener('DOMContentLoaded', function(){
        try {
            window.__okrtFeedMgr__ = new MarketFeedManager(SYMBOL, onCandle);
            window.__okrtFeedMgr__.start();
            console.log('[FEED] MarketFeedManager started with failover (Binance â†’ Coinbase â†’ Kraken)');
        } catch(e) {
            console.warn('[FEED] init failed', e);
        }
    });
})();


// ============================================
// AI ENGINE PRO STATUS PANEL UPDATE - WIDE v2.0
// ============================================
(function() {
  try{ if(!window.__ORACULUM_AI_PANEL_OWNER) window.__ORACULUM_AI_PANEL_OWNER = 'WIDE_V2'; }catch(e){}
  function updateAIEnginePanel() {
    if (document.hidden) return;
    if (!window.AIEnginePro || !window.AIEnginePro.isReady) {
      var statusEl = document.getElementById('aiStatus');
      if (statusEl) {
        statusEl.textContent = 'LOADING';
        statusEl.style.background = 'rgba(244,185,66,0.2)';
        statusEl.style.color = '#f4b942';
      }
      return;
    }
    
    try {
      var stats = window.AIEnginePro.getStats();
      var currentPred = null;
      try { currentPred = window.AIEnginePro.getPrediction(); } catch(e) {}
      
      // Version
      var versionEl = document.getElementById('aiVersion');
      if (versionEl && window.AIEnginePro.version) versionEl.textContent = 'v' + window.AIEnginePro.version;
      
      // Status - more dynamic based on activity
      var statusEl = document.getElementById('aiStatus');
      if (statusEl) {
        var pending = stats.memory ? stats.memory.pending : 0;
        var sessionPreds = stats.session ? stats.session.predictions : 0;
        if (pending > 0) {
          statusEl.textContent = 'LEARNING (' + pending + ')';
          statusEl.style.background = 'rgba(0,212,255,0.2)';
          statusEl.style.color = '#00d4ff';
        } else if (sessionPreds > 0) {
          statusEl.textContent = 'ACTIVE';
          statusEl.style.background = 'rgba(0,255,136,0.2)';
          statusEl.style.color = '#00ff88';
        } else {
          statusEl.textContent = 'READY';
          statusEl.style.background = 'rgba(244,185,66,0.2)';
          statusEl.style.color = '#f4b942';
        }
      }
      
      // Prediction
      if (currentPred) {
        var predBox = document.getElementById('aiPredictionBox');
        var dirEl = document.getElementById('aiDirection');
        var confEl = document.getElementById('aiConfidence');
        var regimeEl = document.getElementById('aiRegime');
        var sessionEl = document.getElementById('aiSession');
        
        var dir = currentPred.direction || 'NEUTRAL';
        if (dirEl) {
          dirEl.textContent = dir === 'BULL' ? 'ðŸŸ¢ BULLISH' : dir === 'BEAR' ? 'ðŸ”´ BEARISH' : 'âšª NEUTRAL';
          dirEl.style.color = dir === 'BULL' ? '#00ff88' : dir === 'BEAR' ? '#ff4466' : '#94a3b8';
        }
        if (confEl) {
          var conf = (currentPred.confidence || 0) * 100;
          confEl.textContent = conf.toFixed(1) + '% confidence';
          confEl.style.color = conf >= 70 ? '#00ff88' : conf >= 55 ? '#00d4ff' : '#94a3b8';
        }
        if (regimeEl) {
          var regime = currentPred.regime || '--';
          var rd = {'trending_up':'ðŸ“ˆ Trend Up','trending_down':'ðŸ“‰ Trend Down','ranging':'â†”ï¸ Ranging','volatile':'âš¡ Volatile'};
          regimeEl.textContent = rd[regime] || regime;
        }
        if (sessionEl) {
          var sess = currentPred.session || '--';
          var sd = {'ASIA':'ðŸŒ Asia','EUROPE':'ðŸŒ Europe','US':'ðŸŒŽ US'};
          sessionEl.textContent = sd[sess] || sess;
        }
        if (predBox) {
          predBox.style.borderLeftColor = dir === 'BULL' ? '#00ff88' : dir === 'BEAR' ? '#ff4466' : '#94a3b8';
          predBox.style.background = dir === 'BULL' ? 'rgba(0,255,136,0.1)' : dir === 'BEAR' ? 'rgba(255,68,102,0.1)' : 'rgba(0,212,255,0.05)';
        }
      }
      
      // Accuracy
      var accEl = document.getElementById('aiAccuracy');
      var accBar = document.getElementById('aiAccuracyBar');
      if (accEl && stats.overall) {
        var acc = stats.overall.accuracy || 0;
        accEl.textContent = (acc * 100).toFixed(1) + '%';
        accEl.style.color = acc >= 0.55 ? '#00ff88' : acc >= 0.45 ? '#f4b942' : '#ff4466';
        if (accBar) accBar.style.width = Math.min(100, acc * 100) + '%';
      }
      
      // Session Stats (new dynamic elements)
      var sessCountEl = document.getElementById('aiSessionCount');
      if (sessCountEl && stats.session) {
        sessCountEl.textContent = stats.session.predictions || 0;
        sessCountEl.style.color = stats.session.predictions > 0 ? '#00d4ff' : '#64748b';
      }
      
      var completedEl = document.getElementById('aiCompleted');
      if (completedEl && stats.memory) {
        completedEl.textContent = stats.memory.completed || 0;
        completedEl.style.color = stats.memory.completed > 0 ? '#ff9500' : '#64748b';
      }
      
      var uptimeEl = document.getElementById('aiUptime');
      if (uptimeEl && stats.session) {
        var mins = stats.session.uptime || 0;
        if (mins >= 60) {
          uptimeEl.textContent = Math.floor(mins/60) + 'h ' + (mins%60) + 'm';
        } else {
          uptimeEl.textContent = mins + 'm';
        }
      }
      
      // Last Verification (very dynamic)
      var verifEl = document.getElementById('aiLastVerif');
      if (verifEl && stats.session && stats.session.lastVerification) {
        var v = stats.session.lastVerification;
        var icon = v.success ? 'âœ“' : 'âœ—';
        var col = v.success ? '#00ff88' : '#ff4466';
        var change = parseFloat(v.priceChange);
        var changeStr = change >= 0 ? '+' + change + '%' : change + '%';
        verifEl.innerHTML = '<span style="color:'+col+';">'+icon+'</span> '+v.horizon+'m â†’ <span style="color:'+(change>=0?'#00ff88':'#ff4466')+';">'+changeStr+'</span>';
      }
      
      // Patterns & Pending
      var patEl = document.getElementById('aiPatterns');
      if (patEl && stats.memory) patEl.textContent = stats.memory.patterns || 0;
      
      var pendEl = document.getElementById('aiPending');
      if (pendEl && stats.memory) pendEl.textContent = stats.memory.pending || 0;
      
      // Horizons
      var hGrid = document.getElementById('aiHorizonsGrid');
      if (hGrid && stats.horizons) {
        var sorted = Object.entries(stats.horizons).filter(function(e){return e[1].total>=1;}).sort(function(a,b){return b[1].accuracy-a[1].accuracy;});
        var html = '';
        if (sorted.length === 0) {
          html = '<span style="color:#64748b;font-size:9px;">Collecting...</span>';
        } else {
          sorted.slice(0,4).forEach(function(e){
            var h=e[0], d=e[1], a=(d.accuracy*100).toFixed(0);
            var col = d.accuracy>=0.55?'#00ff88':d.accuracy>=0.45?'#f4b942':'#ff4466';
            html += '<div style="background:rgba(255,255,255,0.05);padding:3px 6px;border-radius:3px;font-size:9px;"><span style="color:#94a3b8;">'+h+'m</span> <span style="color:'+col+';font-weight:bold;">'+a+'%</span></div>';
          });
        }
        hGrid.innerHTML = html;
      }
      
      // Models
      var mGrid = document.getElementById('aiModelsGrid');
      if (mGrid && stats.models) {
        var html = '';
        for (var n in stats.models) {
          var m = stats.models[n];
          var a = parseFloat(m.accuracy);
          var preds = m.predictions || 0;
          var col = preds === 0 ? '#64748b' : (a>=55?'#00ff88':a>=45?'#94a3b8':'#ff4466');
          var display = preds === 0 ? '--' : m.accuracy;
          html += '<div style="display:flex;justify-content:space-between;padding:1px 3px;"><span style="color:#64748b;">'+n+'</span><span style="color:'+col+';">'+display+'</span></div>';
        }
        mGrid.innerHTML = html;
      }
      
      // Timestamp
      var upEl = document.getElementById('aiLastUpdate');
      if (upEl) upEl.textContent = new Date().toLocaleTimeString('es-ES',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
      
    } catch (e) { console.warn('[UI] AI Panel error:', e); }
  }
  
  setInterval(updateAIEnginePanel, 3000);
  setTimeout(updateAIEnginePanel, 3000);
})();
</script>

</body></html>
