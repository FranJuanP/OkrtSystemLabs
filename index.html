<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!--
CSP MAINTENANCE ‚Äî ORACULUM (OkrtSystem Labs)

Regla de oro:
- Si la app muestra ERROR tras a√±adir una nueva fuente de datos, abre DevTools (F12) y revisa:
  Console ‚Üí buscar "violates Content Security Policy"
  Network ‚Üí filtrar por el dominio del proveedor

Qu√© tocar (solo esto):
1) Si fallan peticiones fetch/XHR o WebSocket: a√±adir dominio EXACTO en `connect-src`.
   - Ejemplo: wss://stream.binance.com:9443 requiere incluir el puerto 9443.
2) Si a√±ades un script externo (CDN): a√±adir dominio en `script-src`.
3) Si a√±ades CSS externo: a√±adir dominio en `style-src`.
4) Si a√±ades fuentes: a√±adir en `font-src`.
5) Si a√±ades im√°genes externas: a√±adir en `img-src`.

Qu√© NO hacer:
- No a√±adir '*' ni volver a default-src *.
- No a√±adir 'unsafe-eval'.
- Mantener: object-src 'none' y frame-ancestors 'none'.

Nota:
- Si un proveedor cambia endpoints, la CSP puede bloquearlo aunque el c√≥digo est√© bien.
  En ese caso, a√±ade SOLO el nuevo host.
-->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; base-uri 'self'; object-src 'none'; frame-ancestors 'none'; frame-src 'none'; form-action 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: blob: https:; connect-src 'self' https://api.binance.com https://fapi.binance.com https://api.alternative.me https://xrp-insights.com wss://stream.binance.com:9443 wss://ws.kraken.com wss://ws.bitstamp.net wss://stream.bybit.com wss://ws-feed.exchange.coinbase.com wss://stream.crypto.com; manifest-src 'self' data:; worker-src 'self' blob:; upgrade-insecure-requests; block-all-mixed-content;">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="ORACULUM">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ORACULUM">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#02060c">
  <meta name="msapplication-TileColor" content="#02060c">
  <meta name="msapplication-navbutton-color" content="#00d4ff">
  
  <!-- SEO & Social -->
  <meta name="description" content="ORACULUM OkrtSystem Labs - Advanced XRP Trading Dashboard with Probability-Based Predictions, Market Regime Detection, S/R Levels, Fibonacci, and Signal Quality Analysis">
  <meta name="keywords" content="XRP, trading, dashboard, crypto, AI, analysis, ORACULUM, fibonacci, support, resistance">
  <meta name="author" content="OkrtSystem Labs">
  
  <title>ORACULUM OkrtSystem Labs</title>
  
  <!-- PWA Icons -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4ff'/%3E%3Cstop offset='100%25' stop-color='%23a855f7'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='512' height='512' rx='100' fill='%2302060c'/%3E%3Crect x='128' y='128' width='256' height='256' rx='40' fill='url(%23g)' transform='rotate(45 256 256)'/%3E%3Ctext x='256' y='290' text-anchor='middle' font-family='Arial Black' font-size='180' font-weight='900' fill='%2302060c'%3EX%3C/text%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4ff'/%3E%3Cstop offset='100%25' stop-color='%23a855f7'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='512' height='512' rx='100' fill='%2302060c'/%3E%3Crect x='128' y='128' width='256' height='256' rx='40' fill='url(%23g)' transform='rotate(45 256 256)'/%3E%3Ctext x='256' y='290' text-anchor='middle' font-family='Arial Black' font-size='180' font-weight='900' fill='%2302060c'%3EX%3C/text%3E%3C/svg%3E">
  
  <!-- Splash Screens iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-startup-image" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1242 2688'%3E%3Crect fill='%2302060c' width='1242' height='2688'/%3E%3Ctext x='621' y='1344' text-anchor='middle' font-family='Arial' font-size='120' fill='%2300d4ff'%3EXRP ORACULUM%3C/text%3E%3C/svg%3E">
  
  <!-- Web App Manifest (inline) -->
  <link rel="manifest" href="data:application/json,%7B%22name%22%3A%22XRP%20ORACULUM%20%7C%20OkrtSystem%20Labs%22%2C%22short_name%22%3A%22XRP%20ORACULUM%22%2C%22description%22%3A%22Advanced%20XRP%20Trading%20Dashboard%20by%20OkrtSystem%20Labs%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22orientation%22%3A%22any%22%2C%22background_color%22%3A%22%2302060c%22%2C%22theme_color%22%3A%22%2300d4ff%22%2C%22categories%22%3A%5B%22finance%22%2C%22utilities%22%5D%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%2520viewBox%3D%270%25200%2520512%2520512%27%253E%253Cdefs%253E%253ClinearGradient%2520id%3D%27g%27%2520x1%3D%270%2525%27%2520y1%3D%270%2525%27%2520x2%3D%27100%2525%27%2520y2%3D%27100%2525%27%253E%253Cstop%2520offset%3D%270%2525%27%2520stop-color%3D%27%252300d4ff%27%2F%253E%253Cstop%2520offset%3D%27100%2525%27%2520stop-color%3D%27%2523a855f7%27%2F%253E%253C%2FlinearGradient%253E%253C%2Fdefs%253E%253Crect%2520width%3D%27512%27%2520height%3D%27512%27%2520rx%3D%27100%27%2520fill%3D%27%252302060c%27%2F%253E%253Crect%2520x%3D%27128%27%2520y%3D%27128%27%2520width%3D%27256%27%2520height%3D%27256%27%2520rx%3D%2740%27%2520fill%3D%27url%28%2523g%29%27%2520transform%3D%27rotate%2845%2520256%2520256%29%27%2F%253E%253Ctext%2520x%3D%27256%27%2520y%3D%27290%27%2520text-anchor%3D%27middle%27%2520font-family%3D%27Arial%2520Black%27%2520font-size%3D%27180%27%2520font-weight%3D%27900%27%2520fill%3D%27%252302060c%27%253EX%253C%2Ftext%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%2C%22purpose%22%3A%22any%20maskable%22%7D%5D%7D">
  
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-primary: #02060c;
      --bg-card: rgba(13, 24, 41, 0.85); 
      --bg-header: rgba(2, 6, 12, 0.95);
      
      --accent-cyan: #00d4ff;
      --accent-purple: #a855f7;
      --accent-green: #00ff88;
      --accent-red: #ff4466;
      --accent-orange: #ff9500;
      --accent-yellow: #f4b942;
      --text-main: #f0f4f8;
      --text-dim: #94a3b8;
      
      --border-glass: 1px solid rgba(255, 255, 255, 0.15);
      --font-tech: 'Orbitron', sans-serif;
      --font-data: 'JetBrains Mono', monospace;
    }

    /* Modo Claro */
    body.light-mode {
      --bg-primary: #f0f4f8;
      --bg-card: rgba(255, 255, 255, 0.9);
      --bg-header: rgba(240, 244, 248, 0.98);
      --text-main: #1a202c;
      --text-dim: #4a5568;
      --border-glass: 1px solid rgba(0, 0, 0, 0.1);
    }
    body.light-mode { background: radial-gradient(circle at 50% 0%, #e2e8f0 0%, #f0f4f8 80%); }
    body.light-mode .grid-bg {
      background-image: 
        linear-gradient(rgba(0, 100, 150, 0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 100, 150, 0.08) 1px, transparent 1px);
    }
    body.light-mode .panel { background: var(--bg-card); border: 1px solid rgba(0,0,0,0.1); }
    body.light-mode .kpi-card { background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(240,244,248,0.9)); border: 1px solid rgba(0,0,0,0.08); }
    body.light-mode .ob-bid { color: #059669; }
    body.light-mode .ob-ask { color: #dc2626; }

    /* üåü Modo NEON Futurista */
    body.neon-mode {
      --bg-primary: #000000;
      --bg-card: rgba(5, 5, 20, 0.95);
      --bg-header: rgba(0, 0, 10, 0.98);
      --accent-cyan: #00ffff;
      --accent-purple: #ff00ff;
      --accent-green: #00ff00;
      --accent-red: #ff0040;
      --accent-orange: #ff6600;
      --accent-yellow: #ffff00;
      --text-main: #ffffff;
      --text-dim: #8888aa;
      --border-glass: 1px solid rgba(0, 255, 255, 0.2);
    }
    body.neon-mode { 
      background: radial-gradient(ellipse at 50% 0%, #0a0015 0%, #000005 50%, #000000 100%);
    }
    body.neon-mode .grid-bg {
      background-image: 
        linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 0, 255, 0.03) 1px, transparent 1px);
      background-size: 30px 30px;
    }
    body.neon-mode .panel { 
      background: linear-gradient(180deg, rgba(5, 5, 25, 0.95), rgba(0, 0, 15, 0.98));
      border: 1px solid rgba(0, 255, 255, 0.15);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.05), inset 0 0 30px rgba(0, 0, 0, 0.5);
    }
    body.neon-mode .kpi-card { 
      background: linear-gradient(180deg, rgba(10, 0, 20, 0.9), rgba(5, 5, 15, 0.95));
      border: 1px solid rgba(255, 0, 255, 0.2);
      box-shadow: 0 0 10px rgba(255, 0, 255, 0.1);
    }
    body.neon-mode header {
      background: linear-gradient(180deg, rgba(0, 0, 20, 0.98), rgba(0, 0, 10, 0.95));
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 2px 20px rgba(0, 255, 255, 0.1);
    }
    body.neon-mode .control-btn {
      border-color: rgba(0, 255, 255, 0.3);
      text-shadow: 0 0 5px currentColor;
    }
    body.neon-mode .control-btn:hover {
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
      text-shadow: 0 0 10px var(--accent-cyan);
    }
    body.neon-mode .status-pill {
      border-color: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }
    body.neon-mode .panel-head {
      text-shadow: 0 0 8px currentColor;
    }
    body.neon-mode .c-green { text-shadow: 0 0 8px var(--accent-green); }
    body.neon-mode .c-red { text-shadow: 0 0 8px var(--accent-red); }
    body.neon-mode .c-cyan { text-shadow: 0 0 8px var(--accent-cyan); }
    body.neon-mode .c-purple { text-shadow: 0 0 8px var(--accent-purple); }
    body.neon-mode #priceDisplay { text-shadow: 0 0 15px var(--accent-cyan); }
    body.neon-mode .tab-btn.active {
      box-shadow: 0 0 10px var(--accent-cyan);
    }
    body.neon-mode .score-meter {
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }
    body.neon-mode .accuracy-bar {
      box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
    }

    /* Controles del header */
    .header-controls {
      display: flex; gap: 8px; align-items: center;
    }
    .control-btn {
      font-family: var(--font-data); font-size: 10px;
      padding: 5px 10px; border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px; background: rgba(0,0,0,0.3);
      color: var(--text-dim); cursor: pointer; transition: all 0.2s;
    }
    .control-btn:hover { background: rgba(0,212,255,0.2); border-color: var(--accent-cyan); color: var(--accent-cyan); }
    .control-btn.active { background: var(--accent-cyan); color: #000; border-color: var(--accent-cyan); }
    
    .timeframe-select {
      font-family: var(--font-data); font-size: 10px;
      padding: 5px 8px; border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px; background: rgba(0,0,0,0.5);
      color: var(--accent-cyan); cursor: pointer;
    }
    .timeframe-select option { background: #0d1829; color: #fff; }
    
    .lang-select {
      font-family: var(--font-data); font-size: 10px;
      padding: 5px 8px; border: 1px solid rgba(168,85,247,0.4);
      border-radius: 4px; background: rgba(168,85,247,0.1);
      color: var(--accent-purple); cursor: pointer;
      min-width: 60px;
    }
    .lang-select option { background: #0d1829; color: #fff; }
    .lang-select:hover { border-color: var(--accent-purple); background: rgba(168,85,247,0.2); }

    body.light-mode .control-btn { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.2); color: var(--text-dim); }
    body.light-mode .control-btn:hover { background: rgba(0,212,255,0.1); }
    body.light-mode .timeframe-select { background: rgba(255,255,255,0.8); color: #1a202c; border-color: rgba(0,0,0,0.2); }
    body.light-mode .lang-select { background: rgba(255,255,255,0.8); color: #6b21a8; border-color: rgba(168,85,247,0.4); }

    /* Mini gr√°fico de accuracy */
    .accuracy-chart {
      display: flex; align-items: flex-end; gap: 1px; height: 30px; padding: 5px;
      background: rgba(0,0,0,0.2); border-radius: 3px; margin: 5px 10px;
    }
    .accuracy-bar-mini {
      width: 4px; border-radius: 1px; transition: height 0.3s;
      min-height: 2px;
    }

    /* ============================================
       TOOLS PANEL - Multi-TF, Risk Calc, Alerts
       ============================================ */
    .tools-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(5px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .tools-overlay.active { display: flex; }

    .tools-panel {
      width: 900px;
      max-height: 85vh;
      background: linear-gradient(180deg, #0d1829 0%, #061018 100%);
      border: 1px solid rgba(0,212,255,0.3);
      border-radius: 16px;
      box-shadow: 0 0 60px rgba(0,212,255,0.2);
      overflow: hidden;
    }

    .tools-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .tools-header h2 {
      font-family: var(--font-tech);
      font-size: 16px;
      color: var(--accent-cyan);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .tools-close {
      background: none;
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--text-dim);
      width: 30px; height: 30px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }
    .tools-close:hover {
      background: var(--accent-red);
      border-color: var(--accent-red);
      color: #fff;
    }

    .tools-tabs {
      display: flex;
      gap: 5px;
      padding: 10px 20px;
      background: rgba(0,0,0,0.2);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .tools-tab {
      padding: 10px 20px;
      border: none;
      background: rgba(255,255,255,0.05);
      color: var(--text-dim);
      border-radius: 8px;
      cursor: pointer;
      font-family: var(--font-tech);
      font-size: 11px;
      transition: all 0.2s;
    }
    .tools-tab:hover { background: rgba(0,212,255,0.1); color: var(--accent-cyan); }
    .tools-tab.active { background: var(--accent-cyan); color: #000; }

    .tools-content {
      padding: 20px;
      max-height: 60vh;
      overflow-y: auto;
    }

    .tool-section { display: none; }
    .tool-section.active { display: block; }

    /* Multi-Timeframe Panel */
    .mtf-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
    }

    .mtf-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }

    .mtf-card.bullish { border-color: rgba(0,255,136,0.3); background: rgba(0,255,136,0.05); }
    .mtf-card.bearish { border-color: rgba(255,68,102,0.3); background: rgba(255,68,102,0.05); }

    .mtf-tf {
      font-family: var(--font-tech);
      font-size: 18px;
      color: var(--accent-cyan);
      margin-bottom: 10px;
    }

    .mtf-price {
      font-family: var(--font-data);
      font-size: 14px;
      color: var(--text-main);
      margin-bottom: 8px;
    }

    .mtf-signal {
      font-size: 11px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      margin-bottom: 8px;
    }
    .mtf-signal.bullish { background: rgba(0,255,136,0.2); color: var(--accent-green); }
    .mtf-signal.bearish { background: rgba(255,68,102,0.2); color: var(--accent-red); }
    .mtf-signal.neutral { background: rgba(255,255,255,0.1); color: var(--text-dim); }

    .mtf-indicators {
      font-size: 9px;
      color: var(--text-dim);
      line-height: 1.6;
    }

    .mtf-rsi { font-weight: 600; }
    .mtf-rsi.oversold { color: var(--accent-green); }
    .mtf-rsi.overbought { color: var(--accent-red); }
    .mtf-rsi.neutral { color: var(--text-dim); }

    /* Risk Calculator */
    .risk-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .risk-inputs, .risk-results {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }

    .risk-inputs h3, .risk-results h3 {
      font-family: var(--font-tech);
      font-size: 12px;
      color: var(--accent-cyan);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .input-group {
      margin-bottom: 15px;
    }

    .input-group label {
      display: block;
      font-size: 11px;
      color: var(--text-dim);
      margin-bottom: 5px;
    }

    .input-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: var(--text-main);
      font-family: var(--font-data);
      font-size: 13px;
    }

    .input-group input:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }

    .input-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .result-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .result-item:last-child { border: none; }

    .result-label {
      font-size: 11px;
      color: var(--text-dim);
    }

    .result-value {
      font-family: var(--font-data);
      font-size: 13px;
      font-weight: 600;
    }
    .result-value.green { color: var(--accent-green); }
    .result-value.red { color: var(--accent-red); }
    .result-value.cyan { color: var(--accent-cyan); }

    .risk-ratio {
      text-align: center;
      padding: 15px;
      background: rgba(0,212,255,0.1);
      border-radius: 8px;
      margin-top: 15px;
    }

    .risk-ratio-value {
      font-family: var(--font-tech);
      font-size: 28px;
      color: var(--accent-cyan);
    }

    .risk-ratio-label {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 5px;
    }

    /* Price Alerts */
    .alerts-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .alerts-form, .alerts-list-panel {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }

    .alerts-form h3, .alerts-list-panel h3 {
      font-family: var(--font-tech);
      font-size: 12px;
      color: var(--accent-cyan);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .alert-type-btns {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .alert-type-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(0,0,0,0.2);
      color: var(--text-dim);
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }
    .alert-type-btn:hover { border-color: var(--accent-cyan); }
    .alert-type-btn.active.above { background: rgba(0,255,136,0.2); border-color: var(--accent-green); color: var(--accent-green); }
    .alert-type-btn.active.below { background: rgba(255,68,102,0.2); border-color: var(--accent-red); color: var(--accent-red); }

    .add-alert-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border: none;
      border-radius: 8px;
      color: #000;
      font-family: var(--font-tech);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .add-alert-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,212,255,0.3); }

    .custom-alerts-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .custom-alert-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      margin-bottom: 8px;
      border-left: 3px solid;
    }
    .custom-alert-item.above { border-color: var(--accent-green); }
    .custom-alert-item.below { border-color: var(--accent-red); }
    .custom-alert-item.triggered { opacity: 0.5; }

    .alert-info {
      flex: 1;
    }

    .alert-price {
      font-family: var(--font-data);
      font-size: 14px;
      font-weight: 600;
      color: var(--text-main);
    }

    .alert-condition {
      font-size: 10px;
      color: var(--text-dim);
    }

    .alert-delete {
      background: none;
      border: none;
      color: var(--accent-red);
      cursor: pointer;
      font-size: 16px;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    .alert-delete:hover { opacity: 1; }

    .no-alerts {
      text-align: center;
      padding: 30px;
      color: var(--text-dim);
      font-size: 12px;
    }

    /* ============================================
       NEW TOOLS: Fibo, Session, Strategy, Correlation, Watchlist
       ============================================ */
    
    /* Session Stats */
    .session-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .session-stat {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }
    .session-stat-value {
      font-family: var(--font-tech);
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 5px;
    }
    .session-stat-label {
      font-size: 10px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .session-timeline {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 15px;
    }
    .timeline-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 11px;
    }
    .timeline-row:last-child { border: none; }

    /* Fibonacci */
    .fibo-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .fibo-levels, .fibo-info {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }
    .fibo-level-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .fibo-level-row:last-child { border: none; }
    .fibo-label {
      font-size: 12px;
      color: var(--text-dim);
    }
    .fibo-price {
      font-family: var(--font-data);
      font-size: 13px;
      font-weight: 600;
    }
    .fibo-bar {
      flex: 1;
      height: 4px;
      background: rgba(255,255,255,0.1);
      margin: 0 15px;
      border-radius: 2px;
      position: relative;
    }
    .fibo-bar-fill {
      position: absolute;
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s;
    }
    .fibo-current-marker {
      position: absolute;
      width: 8px;
      height: 8px;
      background: var(--accent-cyan);
      border-radius: 50%;
      top: -2px;
      transform: translateX(-50%);
      box-shadow: 0 0 10px var(--accent-cyan);
    }

    /* Correlation */
    .corr-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
    }
    .corr-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    .corr-pair {
      font-family: var(--font-tech);
      font-size: 14px;
      color: var(--accent-cyan);
      margin-bottom: 10px;
    }
    .corr-value {
      font-family: var(--font-data);
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 5px;
    }
    .corr-value.positive { color: var(--accent-green); }
    .corr-value.negative { color: var(--accent-red); }
    .corr-value.neutral { color: var(--text-dim); }
    .corr-label {
      font-size: 10px;
      color: var(--text-dim);
    }
    .corr-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      margin-top: 10px;
      overflow: hidden;
    }
    .corr-bar-fill {
      height: 100%;
      transition: width 0.5s;
    }

    /* Watchlist */
    .watchlist-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .watchlist-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .watchlist-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      background: rgba(255,255,255,0.05);
    }
    .watchlist-info { flex: 1; }
    .watchlist-symbol {
      font-family: var(--font-tech);
      font-size: 14px;
      color: var(--text-main);
    }
    .watchlist-name {
      font-size: 10px;
      color: var(--text-dim);
    }
    .watchlist-price {
      text-align: right;
    }
    .watchlist-price-value {
      font-family: var(--font-data);
      font-size: 16px;
      font-weight: 600;
    }
    .watchlist-change {
      font-size: 11px;
      font-family: var(--font-data);
    }
    .watchlist-change.up { color: var(--accent-green); }
    .watchlist-change.down { color: var(--accent-red); }
    .watchlist-mini-chart {
      width: 60px;
      height: 30px;
      display: flex;
      align-items: flex-end;
      gap: 2px;
    }
    .mini-bar {
      flex: 1;
      border-radius: 1px;
      transition: height 0.3s;
    }

    /* Strategy Builder */
    .strategy-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .strategy-builder, .strategy-list {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 20px;
    }
    .condition-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .condition-row select, .condition-row input {
      padding: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
      color: var(--text-main);
      font-family: var(--font-data);
      font-size: 11px;
    }
    .condition-row select { flex: 1; }
    .condition-row input { width: 80px; }
    .logic-connector {
      text-align: center;
      padding: 5px;
      font-size: 10px;
      color: var(--accent-purple);
      font-weight: 600;
    }
    .strategy-item {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      border-left: 3px solid var(--accent-purple);
    }
    .strategy-item.active { border-color: var(--accent-green); }
    .strategy-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .strategy-item-name {
      font-family: var(--font-tech);
      font-size: 12px;
      color: var(--accent-cyan);
    }
    .strategy-item-toggle {
      width: 40px;
      height: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      position: relative;
      cursor: pointer;
      transition: background 0.3s;
    }
    .strategy-item-toggle.active {
      background: var(--accent-green);
    }
    .strategy-item-toggle::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      top: 2px;
      left: 2px;
      transition: left 0.3s;
    }
    .strategy-item-toggle.active::after {
      left: 22px;
    }
    .strategy-conditions {
      font-size: 10px;
      color: var(--text-dim);
      line-height: 1.6;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: radial-gradient(circle at 50% 0%, #112240 0%, var(--bg-primary) 80%);
      color: var(--text-main);
      font-family: 'Rajdhani', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .grid-bg {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
      background-image: 
        linear-gradient(rgba(0, 212, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 212, 255, 0.05) 1px, transparent 1px);
      background-size: 50px 50px;
      mask-image: radial-gradient(circle at 50% 50%, black 40%, transparent 90%);
    }

    header {
      height: 55px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      background: var(--bg-header);
      border-bottom: var(--border-glass);
      z-index: 10;
    }

    .brand { display: flex; align-items: center; gap: 10px; }
    .brand h1 { font-family: var(--font-tech); font-size: 18px; letter-spacing: 2px; color: var(--accent-cyan); text-shadow: 0 0 10px rgba(0,212,255,0.4); }
    
    .header-center {
      display: flex; gap: 15px; align-items: center;
    }
    .header-stat {
      font-family: var(--font-data); font-size: 11px;
      padding: 4px 10px; border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px; background: rgba(0,0,0,0.3);
    }
    .header-stat span { color: var(--text-dim); }

    .status-pill {
      font-family: var(--font-data); font-size: 11px; padding: 4px 10px;
      border: 1px solid #333; border-radius: 4px;
      display: flex; align-items: center; gap: 6px;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
    .status-live .status-dot { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
    .status-err .status-dot { background: var(--accent-red); }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 340px 1fr 320px;
      grid-template-rows: 70px 1fr 180px;
      gap: 8px;
      padding: 8px;
      overflow: hidden;
    }

    .panel {
      background: var(--bg-card);
      border: var(--border-glass);
      border-radius: 4px;
      backdrop-filter: blur(5px);
      display: flex; flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    
    .panel-head {
      font-family: var(--font-tech); font-size: 9px; color: var(--text-dim);
      padding: 6px 10px; border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex; justify-content: space-between; letter-spacing: 1px;
      flex-shrink: 0; align-items: center;
    }

    .metrics-wrapper {
      grid-column: 1 / -1; grid-row: 1;
      display: flex; gap: 10px;
    }
    .kpi-card {
      flex: 1; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2));
      border: var(--border-glass); padding: 8px 12px;
      display: flex; flex-direction: column; justify-content: center;
    }
    .kpi-val { font-family: var(--font-data); font-size: 20px; font-weight: 700; color: var(--text-main); margin-top: 3px; }
    .kpi-lbl { font-size: 10px; color: var(--text-dim); text-transform: uppercase; }
    .kpi-sub { font-size: 9px; color: var(--text-dim); margin-top: 2px; }

    .chart-box {
      grid-column: 2; grid-row: 2;
      position: relative;
      overflow: hidden; 
    }
    #chartContainer { width: 100%; height: 100%; }

    .side-left { grid-column: 1; grid-row: 2 / 4; display: flex; flex-direction: column; gap: 10px; }
    .side-right { grid-column: 3; grid-row: 2 / 4; display: flex; flex-direction: column; gap: 10px; }
    .bottom-box { grid-column: 2; grid-row: 3; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }

    .ob-row {
      display: flex; justify-content: space-between; font-family: var(--font-data); font-size: 11px;
      padding: 2px 8px;
    }
    .ob-ask { color: var(--accent-red); }
    .ob-bid { color: var(--accent-green); }
    
    .whale-item {
      font-size: 10px; padding: 5px 10px; border-left: 3px solid var(--accent-purple);
      margin-bottom: 3px; background: rgba(255,255,255,0.02); font-family: var(--font-data);
      display: flex; justify-content: space-between; align-items: center;
    }
    .whale-item.buy { border-left-color: var(--accent-green); }
    .whale-item.sell { border-left-color: var(--accent-red); }

    .indicator-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 5px 10px; border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 11px;
    }
    .indicator-label { color: var(--text-dim); }
    .indicator-value { font-family: var(--font-data); font-weight: 600; font-size: 11px; }
    .indicator-signal {
      font-size: 8px; padding: 2px 5px; border-radius: 3px;
      text-transform: uppercase; font-weight: 700;
    }
    .signal-buy { background: rgba(0,255,136,0.2); color: var(--accent-green); }
    .signal-sell { background: rgba(255,68,102,0.2); color: var(--accent-red); }
    .signal-neutral { background: rgba(255,255,255,0.1); color: var(--text-dim); }
    .signal-warning { background: rgba(255,149,0,0.2); color: var(--accent-orange); }

    /* AI Engine Classes - Base styles */
    .ai-label { font-size: 8px; }
    .ai-regime { font-size: 14px; }
    .ai-quality { font-size: 14px; }
    .ai-prob { font-size: 22px; }
    .ai-target-price { font-size: 24px; }
    .ai-conf { font-size: 9px; }
    .smc-label { font-size: 8px; }
    .smc-value { font-size: 9px; }
    .mtf-label { font-size: 7px; }
    .mtf-value { font-size: 10px; }
    .conf-value { font-size: 16px; }

    .prediction-box {
      text-align: center; padding: 12px;
      border: 1px solid rgba(0, 212, 255, 0.3);
      background: rgba(0, 212, 255, 0.05);
      margin: 8px; border-radius: 4px;
    }

    .score-meter {
      height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px;
      margin: 8px 10px; overflow: hidden; position: relative;
    }
    .score-fill {
      height: 100%; border-radius: 3px; transition: all 0.5s ease;
      position: absolute; left: 50%;
    }

    .wall-indicator {
      font-size: 9px; padding: 3px 6px; margin: 2px 6px;
      background: rgba(168, 85, 247, 0.15); border-radius: 3px;
      border-left: 2px solid var(--accent-purple);
    }

    .alert-item {
      font-size: 10px; padding: 6px 10px; margin: 3px 8px;
      border-radius: 4px; font-family: var(--font-data);
      animation: alertPulse 0.5s ease;
    }
    .alert-bullish { background: rgba(0,255,136,0.15); border-left: 3px solid var(--accent-green); }
    .alert-bearish { background: rgba(255,68,102,0.15); border-left: 3px solid var(--accent-red); }
    .alert-warning { background: rgba(255,149,0,0.15); border-left: 3px solid var(--accent-orange); }
    .alert-info { background: rgba(0,212,255,0.15); border-left: 3px solid var(--accent-cyan); }

    @keyframes alertPulse {
      0% { opacity: 0; transform: translateX(-10px); }
      100% { opacity: 1; transform: translateX(0); }
    }

    .divergence-badge {
      position: absolute; top: 8px; right: 8px;
      font-size: 9px; padding: 3px 8px; border-radius: 3px;
      font-family: var(--font-data); font-weight: 700;
      animation: pulse 2s infinite;
    }
    .div-bullish { background: var(--accent-green); color: #000; }
    .div-bearish { background: var(--accent-red); color: #fff; }

    .pattern-tag {
      display: inline-block; font-size: 9px; padding: 2px 6px;
      margin: 2px; border-radius: 3px; background: rgba(168,85,247,0.2);
      color: var(--accent-purple); font-family: var(--font-data);
    }

    .accuracy-bar {
      height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px;
      overflow: hidden; margin-top: 5px;
    }
    .accuracy-fill { height: 100%; background: var(--accent-cyan); transition: width 0.5s; }

    .derivatives-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
      padding: 8px; font-size: 10px;
    }
    .deriv-item {
      background: rgba(0,0,0,0.2); padding: 6px 8px; border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .deriv-label { color: var(--text-dim); font-size: 9px; }
    .deriv-value { font-family: var(--font-data); font-size: 13px; font-weight: 600; margin-top: 2px; }

    .etf-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px;
      font-size: 10px;
    }
    .etf-item {
      background: rgba(0,0,0,0.2); padding: 5px 7px; border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .etf-label { color: var(--text-dim); font-size: 8px; text-transform: uppercase; }
    .etf-value { font-family: var(--font-data); font-size: 11px; font-weight: 600; margin-top: 2px; }

    .c-green { color: var(--accent-green); }
    .c-red { color: var(--accent-red); }
    .c-orange { color: var(--accent-orange); }
    .c-purple { color: var(--accent-purple); }
    .c-cyan { color: var(--accent-cyan); }

    .scrollable { overflow-y: auto; flex: 1; }
    .scrollable::-webkit-scrollbar { width: 4px; }
    .scrollable::-webkit-scrollbar-track { background: transparent; }
    .scrollable::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse { animation: pulse 2s infinite; }

    .tab-buttons {
      display: flex; gap: 5px; padding: 5px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .tab-btn {
      font-size: 9px; padding: 3px 8px; border: none;
      background: rgba(255,255,255,0.05); color: var(--text-dim);
      border-radius: 3px; cursor: pointer; font-family: var(--font-tech);
    }
    .tab-btn.active { background: var(--accent-cyan); color: #000; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* ============================================
       PWA INSTALL BANNER
       ============================================ */
    .pwa-install-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #0d1829 0%, #1a0a2e 100%);
      border-top: 1px solid rgba(0, 212, 255, 0.3);
      padding: 15px 20px;
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 15px;
      z-index: 10000;
      box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.5);
      animation: slideUp 0.3s ease;
    }
    .pwa-install-banner.show { display: flex; }
    
    @keyframes slideUp {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .pwa-install-content {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
    }
    
    .pwa-install-icon {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 900;
      color: #000;
      font-family: var(--font-tech);
      transform: rotate(45deg);
    }
    .pwa-install-icon span { transform: rotate(-45deg); }
    
    .pwa-install-text h4 {
      font-family: var(--font-tech);
      font-size: 14px;
      color: var(--accent-cyan);
      margin-bottom: 3px;
    }
    .pwa-install-text p {
      font-size: 12px;
      color: var(--text-dim);
    }
    
    .pwa-install-btn {
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      color: #000;
      font-family: var(--font-tech);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .pwa-install-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
    }
    
    .pwa-install-close {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 20px;
      cursor: pointer;
      padding: 5px;
    }
    .pwa-install-close:hover { color: var(--accent-red); }

    /* iOS Install Instructions Modal */
    .ios-install-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      padding: 20px;
    }
    .ios-install-modal.show { display: flex; }
    
    .ios-install-content {
      background: linear-gradient(180deg, #0d1829 0%, #061018 100%);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 20px;
      padding: 30px;
      max-width: 350px;
      text-align: center;
    }
    
    .ios-install-content h3 {
      font-family: var(--font-tech);
      color: var(--accent-cyan);
      margin-bottom: 20px;
    }
    
    .ios-step {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin-bottom: 10px;
      text-align: left;
    }
    
    .ios-step-num {
      width: 30px;
      height: 30px;
      background: var(--accent-cyan);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #000;
      flex-shrink: 0;
    }
    
    .ios-step-text {
      font-size: 13px;
      color: var(--text-main);
    }
    
    .ios-step-icon {
      font-size: 20px;
    }

    /* ============================================
       MOBILE RESPONSIVE STYLES
       ============================================ */
    @media screen and (max-width: 1200px) {
      main {
        grid-template-columns: 280px 1fr 280px;
      }
      .kpi-card { padding: 8px; }
      .kpi-val { font-size: 18px; }
    }

    @media screen and (max-width: 992px) {
      main {
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        padding: 10px;
        gap: 10px;
      }
      
      .metrics-wrapper {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        order: 1;
      }
      
      .kpi-card {
        padding: 10px;
      }
      
      .chart-box {
        order: 2;
        height: 300px;
        min-height: 300px;
        grid-column: auto;
        grid-row: auto;
      }
      
      .side-left, .side-right {
        order: 3;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      
      .bottom-box {
        order: 4;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
      
      .panel { min-height: auto; }
      
      header {
        flex-wrap: wrap;
        height: auto;
        padding: 10px;
        gap: 10px;
      }
      
      .header-center {
        order: 3;
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }
      
      .brand { order: 1; }
      .header-controls { order: 2; }
      .status-pill { order: 4; }
    }

    @media screen and (max-width: 768px) {
      .metrics-wrapper {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .chart-box {
        height: 280px;
        min-height: 280px;
      }
      
      .side-left, .side-right {
        grid-template-columns: 1fr;
      }
      
      .bottom-box {
        grid-template-columns: 1fr;
      }
      
      .brand h1 { font-size: 14px; }
      
      .header-controls {
        gap: 5px;
      }
      
      .control-btn {
        padding: 4px 8px;
        font-size: 9px;
      }
      
      .header-stat {
        padding: 3px 6px;
        font-size: 9px;
      }
      
      .tools-panel {
        width: 95vw;
        max-height: 90vh;
        margin: 10px;
      }
      
      .tools-tabs {
        flex-wrap: wrap;
        gap: 5px;
      }
      
      .tools-tab {
        padding: 8px 12px;
        font-size: 10px;
      }
      
      .mtf-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .risk-grid,
      .fibo-container,
      .alerts-container,
      .strategy-container,
      .corr-grid {
        grid-template-columns: 1fr;
      }
      
      .watchlist-grid {
        grid-template-columns: 1fr;
      }
      
      .session-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media screen and (max-width: 480px) {
      .metrics-wrapper {
        grid-template-columns: 1fr 1fr;
      }
      
      .kpi-card {
        padding: 8px;
      }
      
      .kpi-lbl { font-size: 8px; }
      .kpi-val { font-size: 16px; }
      .kpi-sub { font-size: 9px; }
      
      .chart-box {
        height: 220px;
        min-height: 220px;
      }
      
      .brand h1 {
        font-size: 12px;
        letter-spacing: 1px;
      }
      
      .header-center {
        display: none;
      }
      
      .panel-head {
        font-size: 10px;
        padding: 8px;
      }
      
      .mtf-grid {
        grid-template-columns: 1fr;
      }
      
      .ob-row {
        font-size: 9px;
      }
      
      .alert-item {
        font-size: 9px;
        padding: 5px 8px;
      }
    }

    /* PWA Standalone Mode Adjustments */
    @media all and (display-mode: standalone) {
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      
      header {
        padding-top: calc(10px + env(safe-area-inset-top));
      }
      
      .pwa-install-banner {
        display: none !important;
      }
    }

    /* Landscape mobile */
    @media screen and (max-height: 500px) and (orientation: landscape) {
      header { height: 45px; padding: 5px 10px; }
      .brand h1 { font-size: 12px; }
      .metrics-wrapper { display: none; }
      main { padding: 5px; }
      .chart-box { height: calc(100vh - 60px); }
    }

    /* ========================================= */
    /* üñ•Ô∏è LARGE SCREENS (1600px+) */
    /* ========================================= */
    @media screen and (min-width: 1600px) {
      /* Grid Layout - Sidebars m√°s grandes */
      main {
        grid-template-columns: 380px 1fr 360px;
        grid-template-rows: 75px 1fr 200px;
        gap: 10px;
        padding: 10px;
      }
      
      /* Header */
      header { padding: 10px 25px; }
      .brand h1 { font-size: 22px; }
      .brand span { font-size: 11px; }
      .control-btn { font-size: 12px; padding: 8px 14px; }
      .status-pill { font-size: 13px; padding: 8px 18px; }
      
      /* KPIs */
      .kpi-card { padding: 14px 18px; }
      .kpi-card .label { font-size: 11px; }
      .kpi-card .value { font-size: 26px; }
      .kpi-card .sub { font-size: 11px; }
      
      /* Panels */
      .panel { border-radius: 10px; }
      .panel-head { font-size: 13px; padding: 10px 14px; }
      
      /* AI Engine Panel */
      .prediction-box { padding: 10px; }
      .ai-regime { font-size: 15px !important; }
      .ai-quality { font-size: 15px !important; }
      .ai-prob { font-size: 26px !important; }
      .ai-target-price { font-size: 28px !important; }
      .ai-label { font-size: 9px !important; }
      .ai-conf { font-size: 11px !important; }
      .smc-label { font-size: 9px !important; }
      .smc-value { font-size: 10px !important; }
      .mtf-label { font-size: 8px !important; }
      .mtf-value { font-size: 12px !important; }
      .conf-value { font-size: 18px !important; }
      
      /* Indicators */
      .indicator-row { padding: 5px 10px !important; }
      .indicator-label { font-size: 11px !important; }
      .indicator-value { font-size: 11px !important; }
      .indicator-signal { font-size: 9px !important; padding: 3px 8px !important; }
      
      /* Tab buttons */
      .tab-btn { font-size: 10px !important; padding: 5px 10px !important; }
      
      /* Order Book */
      .ob-row { font-size: 12px; padding: 4px 10px; }
      #midPrice { font-size: 16px !important; }
      
      /* Whale list */
      .whale-item { font-size: 11px; padding: 6px 10px; }
      
      /* Bottom panels */
      .bottom-box .panel { padding: 12px; }
      .bottom-box .panel-head { font-size: 12px; }
      
      /* Patterns */
      .pattern-tag { font-size: 10px !important; padding: 4px 8px !important; }
      
      /* Alerts */
      .alert-item { font-size: 11px; padding: 8px 12px; }
    }

    /* ========================================= */
    /* üñ•Ô∏è EXTRA LARGE SCREENS (1920px+) */
    /* ========================================= */
    @media screen and (min-width: 1920px) {
      /* Grid Layout - Sidebars a√∫n m√°s grandes para Full HD */
      main {
        grid-template-columns: 420px 1fr 400px;
        grid-template-rows: 80px 1fr 220px;
        gap: 12px;
        padding: 12px;
      }
      
      /* Header */
      header { padding: 12px 30px; }
      .brand h1 { font-size: 26px; }
      .brand span { font-size: 13px; }
      .control-btn { font-size: 13px; padding: 10px 16px; }
      .status-pill { font-size: 14px; padding: 10px 22px; }
      
      /* KPIs */
      .kpi-card { padding: 18px 22px; }
      .kpi-card .label { font-size: 13px; }
      .kpi-card .value { font-size: 32px; }
      .kpi-card .sub { font-size: 13px; }
      
      /* Panels */
      .panel-head { font-size: 15px; padding: 12px 16px; }
      
      /* AI Engine */
      .ai-regime { font-size: 18px !important; }
      .ai-quality { font-size: 18px !important; }
      .ai-prob { font-size: 32px !important; }
      .ai-target-price { font-size: 34px !important; }
      .ai-label { font-size: 10px !important; }
      .ai-conf { font-size: 13px !important; }
      .smc-label { font-size: 10px !important; }
      .smc-value { font-size: 12px !important; }
      .mtf-label { font-size: 9px !important; }
      .mtf-value { font-size: 14px !important; }
      .conf-value { font-size: 22px !important; }
      
      /* Indicators */
      .indicator-row { padding: 6px 12px !important; }
      .indicator-label { font-size: 13px !important; }
      .indicator-value { font-size: 13px !important; }
      .indicator-signal { font-size: 10px !important; padding: 4px 10px !important; }
      
      /* Tab buttons */
      .tab-btn { font-size: 11px !important; padding: 6px 12px !important; }
      
      /* Order Book */
      .ob-row { font-size: 14px; padding: 5px 12px; }
      #midPrice { font-size: 20px !important; }
      
      /* Bottom */
      .bottom-box .panel-head { font-size: 14px; }
      
      /* Pattern tags */
      .pattern-tag { font-size: 11px !important; padding: 5px 10px !important; }
    }

    /* ========================================= */
    /* üñ•Ô∏è 4K SCREENS (2560px+) */
    /* ========================================= */
    @media screen and (min-width: 2560px) {
      /* Grid Layout - M√°ximo espacio para 4K */
      main {
        grid-template-columns: 500px 1fr 480px;
        grid-template-rows: 90px 1fr 260px;
        gap: 15px;
        padding: 15px;
      }
      
      header { padding: 15px 40px; }
      .brand h1 { font-size: 32px; }
      .brand span { font-size: 16px; }
      .control-btn { font-size: 15px; padding: 12px 20px; }
      
      .kpi-card .value { font-size: 40px; }
      .kpi-card .label { font-size: 15px; }
      
      .panel-head { font-size: 18px; }
      
      .ai-regime { font-size: 22px !important; }
      .ai-prob { font-size: 40px !important; }
      .ai-target-price { font-size: 42px !important; }
      
      .indicator-label { font-size: 15px !important; }
      .indicator-value { font-size: 15px !important; }
      .indicator-signal { font-size: 12px !important; }
      
      #midPrice { font-size: 24px !important; }
    }

  </style>
</head>
<body>

  <div class="grid-bg"></div>

  <header>
    <div class="brand">
      <div style="width:15px; height:15px; background:var(--accent-cyan); transform:rotate(45deg);"></div>
      <h1>‚óÜ ORACULUM <span style="opacity:0.5; font-weight:400; font-size:14px;">OkrtSystem Labs</span></h1>
    </div>
    <div class="header-center">
      <div class="header-stat">
        <span>BTC:</span> <span id="btcPrice" class="c-cyan">--</span>
      </div>
      <div class="header-stat" id="sessionDisplay" style="min-width:140px;">
        üåô <span style="color:var(--text-dim)">LOADING...</span>
      </div>
      <div class="header-stat">
        <span>Accuracy:</span> <span id="accuracyPct" class="c-green">--%</span>
      </div>
    </div>
    
    <!-- CONTROLES -->
    <div class="header-controls">
      <select id="timeframeSelect" class="timeframe-select" title="Timeframe">
        <option value="1m">1m</option>
        <option value="5m">5m</option>
        <option value="15m">15m</option>
        <option value="1h">1h</option>
        <option value="4h">4h</option>
      </select>
      <button id="soundBtn" class="control-btn" onclick="toggleSound()" title="Sound Alerts">
        üîá OFF
      </button>
      <button id="voiceBtn" class="control-btn" onclick="toggleVoice()" title="AI Voice Alerts" style="min-width:70px;">
        üéôÔ∏è <span style="color:var(--text-dim)">OFF</span>
      </button>
      <select id="voiceLangSelect" class="lang-select" onchange="changeVoiceLanguage(this.value)" title="Voice Language">
        <option value="en">üá¨üáß EN</option>
        <option value="es">üá™üá∏ ES</option>
      </select>
      <button id="themeBtn" class="control-btn" onclick="toggleTheme()" title="Change Theme">
        üé® NEON
      </button>
      <button class="control-btn" onclick="captureScreenshot()" title="Screenshot">
        üì∏
      </button>
      <button class="control-btn" onclick="toggleMultiChart()" title="Multi-Chart Mode (M)" style="background:linear-gradient(135deg, rgba(168,85,247,0.2), rgba(0,212,255,0.2)); border-color:var(--accent-purple);">
        üìä 4-VIEW
      </button>
      <button id="toolsBtn" class="control-btn" onclick="toggleToolsPanel()" title="Trading Tools" style="background:linear-gradient(135deg, rgba(0,212,255,0.2), rgba(168,85,247,0.2)); border-color:var(--accent-cyan);">
        üõ†Ô∏è TOOLS
      </button>
    </div>
    
    <div class="status-pill" id="statusPill">
      <div class="status-dot"></div>
      <span id="apiStatusText">INITIALIZING...</span>
      <span id="voiceIndicator" style="margin-left:8px; font-size:12px;" title="Voice Status">üéôÔ∏è</span>
      <span id="clock" style="margin-left:10px; color:#fff;">00:00:00</span>
    </div>
  </header>

  <main>
    <!-- KPIs TOP -->
    <div class="metrics-wrapper">
      <div class="kpi-card">
        <span class="kpi-lbl">XRP/USDT</span>
        <span id="priceDisplay" class="kpi-val">--.----</span>
        <span id="priceChange" class="kpi-sub">--</span>
      </div>
      <div class="kpi-card">
        <span class="kpi-lbl">24H VOL</span>
        <span id="volDisplay" class="kpi-val">--</span>
        <span class="kpi-sub">USDT</span>
      </div>
      <div class="kpi-card">
        <span class="kpi-lbl">FEAR & GREED</span>
        <span id="fgIndex" class="kpi-val" style="color:#f4b942">--</span>
        <span id="fgLabel" class="kpi-sub">Loading...</span>
      </div>
      <div class="kpi-card">
        <span class="kpi-lbl">FUNDING RATE</span>
        <span id="fundingRate" class="kpi-val c-cyan">--</span>
        <span id="fundingLabel" class="kpi-sub">8h</span>
      </div>
      <div class="kpi-card">
        <span class="kpi-lbl">OPEN INTEREST</span>
        <span id="openInterest" class="kpi-val c-purple">--</span>
        <span id="oiChange" class="kpi-sub">--</span>
      </div>
      <div class="kpi-card">
        <span class="kpi-lbl">MARKET SCORE</span>
        <span id="totalScore" class="kpi-val">--</span>
        <span id="scoreLabel" class="kpi-sub">Calculating...</span>
      </div>
    </div>

    <!-- SIDEBAR IZQUIERDA -->
    <div class="side-left">
      <div class="panel" style="flex:1; display:flex; flex-direction:column;">
        <div class="panel-head">
          üî± AI ENGINE <span style="background:linear-gradient(90deg, #ff00ff, #00ffff); -webkit-background-clip:text; -webkit-text-fill-color:transparent; font-weight:bold;" class="ai-label">by OkrtSystem Labs</span>
          <span class="pulse" style="color:var(--accent-green)">‚óè</span>
        </div>
        
        <div class="prediction-box" style="flex:1; display:flex; flex-direction:column; padding:8px;">
          <!-- Market Regime + Signal Quality -->
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; padding:6px 10px; background:rgba(0,212,255,0.08); border-radius:6px;">
            <div>
              <div class="ai-label" style="color:var(--text-dim);">REGIME</div>
              <div id="marketRegime" class="ai-regime" style="font-weight:bold; color:var(--accent-cyan);">ANALYZING...</div>
            </div>
            <div style="text-align:right;">
              <div class="ai-label" style="color:var(--text-dim);">QUALITY</div>
              <div id="signalQuality" class="ai-quality" style="font-weight:bold; color:var(--accent-green);">--%</div>
            </div>
          </div>
          
          <!-- Multi-TF Confluence -->
          <div style="margin-bottom:6px; padding:5px 8px; background:linear-gradient(135deg, rgba(255,0,255,0.05), rgba(0,255,255,0.05)); border-radius:5px; border:1px solid rgba(255,0,255,0.15);">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:4px;">
              <div class="mtf-label" style="color:var(--accent-purple);">MTF</div>
              <div id="mtf1m" class="mtf-box" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;">
                <span class="mtf-label" style="color:var(--text-dim);">1M</span>
                <span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span>
              </div>
              <div id="mtf5m" class="mtf-box" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;">
                <span class="mtf-label" style="color:var(--text-dim);">5M</span>
                <span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span>
              </div>
              <div id="mtf15m" class="mtf-box" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;">
                <span class="mtf-label" style="color:var(--text-dim);">15M</span>
                <span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span>
              </div>
              <div id="mtf1h" class="mtf-box" style="text-align:center; padding:3px 6px; background:rgba(0,0,0,0.3); border-radius:4px;">
                <span class="mtf-label" style="color:var(--text-dim);">1H</span>
                <span class="mtf-value" style="font-weight:bold; color:var(--text-dim); margin-left:3px;">--</span>
              </div>
              <div id="mtfScore" style="text-align:center; padding:3px 8px; background:rgba(168,85,247,0.2); border-radius:4px;">
                <span class="mtf-value" style="font-weight:bold; color:var(--accent-purple);">0/4</span>
              </div>
            </div>
          </div>
          
          <!-- Bull/Bear Probability -->
          <div style="display:flex; justify-content:space-between; margin-bottom:6px; gap:6px;">
            <div style="text-align:center; flex:1; background:rgba(0,255,136,0.05); padding:6px; border-radius:6px; border:1px solid rgba(0,255,136,0.2);">
              <div class="ai-label" style="color:var(--accent-green);">‚ñ≤ BULL</div>
              <div id="probBull" class="ai-prob" style="font-weight:bold; color:var(--accent-green);">50%</div>
            </div>
            <div style="text-align:center; flex:1; background:rgba(255,68,102,0.05); padding:6px; border-radius:6px; border:1px solid rgba(255,68,102,0.2);">
              <div class="ai-label" style="color:var(--accent-red);">‚ñº BEAR</div>
              <div id="probBear" class="ai-prob" style="font-weight:bold; color:var(--accent-red);">50%</div>
            </div>
          </div>
          
          <!-- Trading Signal Box (hidden by default) -->
          <div id="tradingSignalBox" style="margin-bottom:6px; padding:6px; background:linear-gradient(135deg, rgba(0,255,136,0.05), rgba(0,212,255,0.05)); border-radius:6px; border:1px solid rgba(0,255,136,0.2); display:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <span id="signalDirection" class="ai-label" style="font-weight:bold; color:var(--accent-green);">üéØ LONG</span>
              <span id="signalRR" class="ai-label" style="color:var(--accent-cyan);">R:R 1:2</span>
            </div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px;">
              <div class="smc-value" style="background:rgba(0,0,0,0.3); padding:3px 5px; border-radius:4px;">
                <span style="color:var(--text-dim);">E:</span>
                <span id="signalEntry" style="color:var(--accent-cyan); font-weight:bold;">$0.00</span>
              </div>
              <div class="smc-value" style="background:rgba(255,68,102,0.1); padding:3px 5px; border-radius:4px;">
                <span style="color:var(--text-dim);">SL:</span>
                <span id="signalSL" style="color:var(--accent-red); font-weight:bold;">$0.00</span>
              </div>
              <div class="smc-value" style="background:rgba(0,255,136,0.1); padding:3px 5px; border-radius:4px;">
                <span style="color:var(--text-dim);">TP1:</span>
                <span id="signalTP1" style="color:var(--accent-green); font-weight:bold;">$0.00</span>
              </div>
              <div class="smc-value" style="background:rgba(0,255,136,0.15); padding:3px 5px; border-radius:4px;">
                <span style="color:var(--text-dim);">TP2:</span>
                <span id="signalTP2" style="color:var(--accent-green); font-weight:bold;">$0.00</span>
              </div>
            </div>
            <div style="margin-top:4px; display:flex; justify-content:space-between; color:var(--text-dim);" class="ai-label">
              <span>Risk: <span id="signalRisk" style="color:var(--accent-red);">-0%</span></span>
              <span>Reward: <span id="signalReward" style="color:var(--accent-green);">+0%</span></span>
              <span>WR: <span id="signalWinRate" style="color:var(--accent-cyan);">--%</span></span>
            </div>
          </div>
          
          <!-- AI Target Price -->
          <div style="text-align:center; padding:6px; background:rgba(0,212,255,0.05); border-radius:6px; margin-bottom:6px; border:1px solid rgba(0,212,255,0.2);">
            <div class="ai-label" style="color:var(--text-dim);">AI TARGET</div>
            <div id="aiTarget" class="ai-target-price" style="font-weight:bold; color:var(--accent-cyan);">$0.0000</div>
            <div class="ai-conf" style="display:flex; justify-content:center; gap:12px;">
              <span>Conf: <span id="confLevel" style="color:var(--accent-green); font-weight:bold;">--%</span></span>
              <span>Acc: <span id="modelAccuracy" style="font-weight:bold;">--%</span></span>
            </div>
            <div class="accuracy-bar" style="margin-top:5px; height:4px;"><div id="accuracyBar" class="accuracy-fill" style="width:0%"></div></div>
          </div>
          
          <!-- Smart Money Concepts -->
          <div style="margin-bottom:6px; padding:5px 8px; background:rgba(255,149,0,0.05); border-radius:5px; border:1px solid rgba(255,149,0,0.15);">
            <div class="ai-label" style="color:var(--accent-orange); margin-bottom:4px;">üí∞ SMART MONEY</div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:3px;">
              <div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;">
                <span class="smc-label" style="color:var(--text-dim);">OB</span>
                <span id="smcOB" style="color:var(--text-dim);">--</span>
              </div>
              <div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;">
                <span class="smc-label" style="color:var(--text-dim);">FVG</span>
                <span id="smcFVG" style="color:var(--text-dim);">--</span>
              </div>
              <div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;">
                <span class="smc-label" style="color:var(--text-dim);">Liq</span>
                <span id="smcLiq" style="color:var(--text-dim);">--</span>
              </div>
              <div class="smc-value" style="display:flex; justify-content:space-between; padding:3px 6px; background:rgba(0,0,0,0.2); border-radius:3px;">
                <span class="smc-label" style="color:var(--text-dim);">Struct</span>
                <span id="smcStruct" style="color:var(--text-dim);">--</span>
              </div>
            </div>
          </div>
          
          <!-- Confluence & Noise & Whale -->
          <div style="display:flex; justify-content:space-around; margin-bottom:6px; padding:5px; background:rgba(168,85,247,0.08); border-radius:5px;">
            <div style="text-align:center;">
              <div class="ai-label" style="color:var(--text-dim);">CONF</div>
              <div id="confluenceCount" class="conf-value" style="font-weight:bold; color:var(--accent-purple);">0</div>
            </div>
            <div style="text-align:center;">
              <div class="ai-label" style="color:var(--text-dim);">NOISE</div>
              <div id="noiseLevel" class="conf-value" style="font-weight:bold; color:var(--accent-orange);">--%</div>
            </div>
            <div style="text-align:center;">
              <div class="ai-label" style="color:var(--text-dim);">WHALE</div>
              <div id="whaleImpact" class="conf-value" style="font-weight:bold; color:var(--accent-cyan);">0</div>
            </div>
          </div>
          
          <!-- Prediction History -->
          <div style="margin-bottom:5px;">
            <div id="accuracyHistoryChart" class="accuracy-chart" style="height:18px;"></div>
          </div>
        </div>

        <!-- Score Meter -->
        <div class="score-meter" style="height:8px;">
          <div id="scoreFill" class="score-fill" style="width:0; background:var(--accent-cyan);"></div>
        </div>
        <div class="ai-label" style="text-align:center; color:var(--text-dim); margin-bottom:5px;">
          <span style="float:left; margin-left:8px;">BEAR</span>
          <span style="float:right; margin-right:8px;">BULL</span>
          <span>NEUTRAL</span>
        </div>

        <!-- Tabs -->
        <div class="tab-buttons" style="padding:3px;">
          <button class="tab-btn active" onclick="switchTab('momentum')" style="font-size:7px; padding:2px 5px;">MOM</button>
          <button class="tab-btn" onclick="switchTab('trend')" style="font-size:7px; padding:2px 5px;">TREND</button>
          <button class="tab-btn" onclick="switchTab('volume')" style="font-size:7px; padding:2px 5px;">VOL</button>
          <button class="tab-btn" onclick="switchTab('advanced')" style="font-size:7px; padding:2px 5px; background:linear-gradient(135deg, rgba(255,0,255,0.1), rgba(0,255,255,0.1));">‚ö°ADV</button>
        </div>

        <div class="scrollable" style="flex:1; min-height:80px;">
          <!-- TAB: Momentum -->
          <div id="tab-momentum" class="tab-content active">
            <div class="indicator-row">
              <span class="indicator-label">RSI (14)</span>
              <span id="rsiValue" class="indicator-value">--</span>
              <span id="rsiSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Stoch RSI</span>
              <span id="stochValue" class="indicator-value">--</span>
              <span id="stochSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Williams %R</span>
              <span id="willrValue" class="indicator-value">--</span>
              <span id="willrSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Momentum</span>
              <span id="momValue" class="indicator-value">--</span>
              <span id="momSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">RSI Div</span>
              <span id="divValue" class="indicator-value">--</span>
              <span id="divSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Squeeze</span>
              <span id="squeezeValue" class="indicator-value">--</span>
              <span id="squeezeSignal" class="indicator-signal signal-neutral">--</span>
            </div>
          </div>

          <!-- TAB: Trend -->
          <div id="tab-trend" class="tab-content">
            <div class="indicator-row">
              <span class="indicator-label">MACD</span>
              <span id="macdValue" class="indicator-value">--</span>
              <span id="macdSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">EMA Cross</span>
              <span id="emaValue" class="indicator-value">--</span>
              <span id="emaSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">ADX</span>
              <span id="adxValue" class="indicator-value">--</span>
              <span id="adxSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Bollinger</span>
              <span id="bbValue" class="indicator-value">--</span>
              <span id="bbSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">VWAP</span>
              <span id="vwapValue" class="indicator-value">--</span>
              <span id="vwapSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Supertrend</span>
              <span id="strendValue" class="indicator-value">--</span>
              <span id="strendSignal" class="indicator-signal signal-neutral">--</span>
            </div>
          </div>

          <!-- TAB: Volume -->
          <div id="tab-volume" class="tab-content">
            <div class="indicator-row">
              <span class="indicator-label">OBV</span>
              <span id="obvValue" class="indicator-value">--</span>
              <span id="obvSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">OB Imbal</span>
              <span id="obValue" class="indicator-value">--</span>
              <span id="obSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">CVD</span>
              <span id="cvdValue" class="indicator-value">--</span>
              <span id="cvdSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Chaikin</span>
              <span id="cmfValue" class="indicator-value">--</span>
              <span id="cmfSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">Whale Flow</span>
              <span id="whaleFlowValue" class="indicator-value">--</span>
              <span id="whaleFlowSignal" class="indicator-signal signal-neutral">--</span>
            </div>
          </div>
          
          <!-- TAB: Advanced -->
          <div id="tab-advanced" class="tab-content">
            <div class="indicator-row">
              <span class="indicator-label">‚òÅÔ∏è Ichimoku</span>
              <span id="ichiValue" class="indicator-value">--</span>
              <span id="ichiSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">üìê Fibo</span>
              <span id="fiboValue" class="indicator-value">--</span>
              <span id="fiboSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">üìä Vol Prof</span>
              <span id="vpValue" class="indicator-value">--</span>
              <span id="vpSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">üîÑ OFI</span>
              <span id="ofiValue" class="indicator-value">--</span>
              <span id="ofiSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">üìà Struct</span>
              <span id="structValue" class="indicator-value">--</span>
              <span id="structSignal" class="indicator-signal signal-neutral">--</span>
            </div>
            <div class="indicator-row">
              <span class="indicator-label">üêã Whale OB</span>
              <span id="whaleOBValue" class="indicator-value">--</span>
              <span id="whaleOBSignal" class="indicator-signal signal-neutral">--</span>
            </div>
          </div>

          <!-- Patterns -->
          <div style="padding:6px 8px; border-top:1px solid rgba(255,255,255,0.05);">
            <div class="ai-label" style="color:var(--text-dim); margin-bottom:3px;">üîÆ PATTERNS</div>
            <div id="patternsContainer" style="display:flex; flex-wrap:wrap; gap:3px;">
              <span class="pattern-tag" style="color:var(--text-dim);">Analyzing...</span>
            </div>
          </div>
        </div>
      </div>

    </div>

    <!-- GR√ÅFICO CENTRAL -->
    <div class="panel chart-box">
      <div class="panel-head">
        <span id="chartLabel">XRP/USDT ‚Ä¢ 1m</span>
        <span style="color:var(--accent-cyan)">TradingView</span>
        <span style="float:right; font-size:9px; color:var(--text-dim);">
          <span style="color:rgba(0,255,136,0.6);">‚îÅ‚îÅ</span> Support
          <span style="color:rgba(255,68,102,0.6); margin-left:5px;">‚îÅ‚îÅ</span> Resistance
          <span style="color:var(--accent-yellow); margin-left:5px;">‚îà‚îà</span> Fibonacci
        </span>
      </div>
      <div id="divergenceBadge" class="divergence-badge" style="display:none;"></div>
      <div id="chartContainer"></div>
      <!-- Fibonacci Levels Display -->
      <div id="fiboLevels" style="padding:3px 10px; font-size:8px; background:rgba(0,0,0,0.3); border-top:1px solid rgba(255,255,255,0.05); overflow-x:auto; white-space:nowrap;">
        <span style="color:var(--accent-yellow)">‚óÜ FIBO:</span> <span style="color:var(--text-dim)">Calculating...</span>
      </div>
      <!-- ü§ñ AI NARRATOR -->
      <div style="padding:6px 10px; background:linear-gradient(135deg, rgba(168,85,247,0.08), rgba(0,212,255,0.08)); border-top:1px solid rgba(168,85,247,0.2);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
          <span style="font-size:9px; font-weight:bold; color:var(--accent-purple);">ü§ñ AI NARRATOR</span>
          <div style="display:flex; gap:6px; align-items:center;">
            <span id="narratorTimestamp" style="font-size:8px; color:var(--text-dim);">--:--</span>
            <button onclick="speakNarrative()" style="background:rgba(168,85,247,0.2); border:1px solid var(--accent-purple); color:var(--accent-purple); padding:2px 6px; border-radius:3px; cursor:pointer; font-size:8px;" title="Read aloud">üîä</button>
          </div>
        </div>
        <div id="aiNarratorText" style="font-size:10px; line-height:1.4; color:var(--text-primary); transition:opacity 0.2s;">
          Analyzing market conditions...
        </div>
      </div>
    </div>

    <!-- SIDEBAR DERECHA -->
    <div class="side-right">
      <!-- ALERTS + SIGNALS en Tabs -->
      <div class="panel" style="flex:1; display:flex; flex-direction:column;">
        <div class="panel-head" style="padding:4px 8px;">
          <div class="tab-buttons" style="padding:0; gap:2px;">
            <button class="tab-btn active" onclick="switchRightTab('alerts')" style="padding:2px 6px; font-size:8px;">üö® ALERTS <span id="alertCount" style="background:var(--accent-red); color:#fff; padding:0 3px; border-radius:6px; font-size:7px;">0</span></button>
            <button class="tab-btn" onclick="switchRightTab('signals')" style="padding:2px 6px; font-size:8px;">üìú SIGNALS</button>
          </div>
        </div>
        <div id="tab-alerts" class="tab-content active scrollable" style="flex:1;">
          <div id="alertsContainer"></div>
        </div>
        <div id="tab-signals" class="tab-content scrollable" style="flex:1;">
          <div id="signalHistoryList">
            <div style="text-align:center; color:var(--text-dim); padding:8px; font-size:9px;">Waiting for signals...</div>
          </div>
        </div>
      </div>

      <!-- ORDER BOOK -->
      <div class="panel" style="flex:1; display:flex; flex-direction:column;">
        <div class="panel-head" style="padding:4px 8px;">üìä ORDER BOOK <span id="spoofWarning" style="display:none; color:var(--accent-orange);">‚ö†</span></div>
        <div id="askSide" style="flex:1; overflow:hidden;"></div>
        <div style="padding:3px; text-align:center; background:rgba(0,212,255,0.1);">
          <span style="font-family:var(--font-data); font-size:13px; font-weight:bold;" id="midPrice">--</span>
        </div>
        <div id="bidSide" style="flex:1; overflow:hidden;"></div>
        <div id="wallDetection" style="padding:2px; font-size:7px;"></div>
      </div>

      <!-- WHALES / ETF -->
      <div class="panel" style="flex:1; display:flex; flex-direction:column;">
        <div class="panel-head" style="padding:4px 8px;">
          <div class="tab-buttons" style="padding:0; gap:2px;">
            <button class="tab-btn active" onclick="switchWhaleTab('whales')" style="padding:3px 10px; font-size:9px;">üêã WHALES <span id="whaleCount" style="background:var(--accent-purple); padding:0 4px; border-radius:6px; font-size:8px;">0</span></button>
            <button class="tab-btn" onclick="switchWhaleTab('etf')" style="padding:3px 10px; font-size:9px;">üìä ETF</button>
          </div>
        </div>
        <div id="tab-whales" class="tab-content active scrollable" style="flex:1; padding:8px;">
          <div id="whaleList"><div style="padding:10px; text-align:center; color:var(--text-dim); font-size:9px;">Monitoring >5K XRP...</div></div>
        </div>
        <div id="tab-etf" class="tab-content" style="flex:1; padding:15px; text-align:center;">
          <div style="margin-top:15px;">
            <div style="font-size:13px; color:var(--accent-cyan); margin-bottom:6px; font-weight:bold;">XRP ETF DATA</div>
            <div style="font-size:10px; color:var(--text-dim);">7 Spot ETFs ‚Ä¢ 774M+ XRP Locked</div>
          </div>
          <div style="margin-top:15px;">
            <a href="https://xrp-insights.com" target="_blank" style="background:var(--accent-green); color:#000; padding:8px 20px; border-radius:5px; font-size:11px; text-decoration:none; font-weight:bold; display:inline-block;">VIEW LIVE DATA ‚Üó</a>
          </div>
        </div>
      </div>
    </div>

    <!-- BOTTOM -->
    <div class="bottom-box">
      <div class="panel">
        <div class="panel-head">üìà SIGNAL CONSENSUS</div>
        <div style="padding:10px;">
          <div style="display:flex; justify-content:space-around; text-align:center;">
            <div>
              <div style="font-size:9px; color:var(--text-dim);">BULLISH</div>
              <div id="bullCount" style="font-size:22px; font-weight:bold; color:var(--accent-green);">0</div>
            </div>
            <div>
              <div style="font-size:9px; color:var(--text-dim);">NEUTRAL</div>
              <div id="neutCount" style="font-size:22px; font-weight:bold; color:var(--text-dim);">0</div>
            </div>
            <div>
              <div style="font-size:9px; color:var(--text-dim);">BEARISH</div>
              <div id="bearCount" style="font-size:22px; font-weight:bold; color:var(--accent-red);">0</div>
            </div>
          </div>
          <div style="margin-top:10px; text-align:center;">
            <span id="consensus" style="font-size:14px; font-weight:bold;">ANALYZING...</span>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-head">üéØ TRADE LEVELS (ATR)</div>
        <div style="padding:10px; font-family:var(--font-data); font-size:11px;">
          <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
            <span style="color:var(--text-dim);">R2:</span>
            <span id="r2" class="c-red">--</span>
          </div>
          <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
            <span style="color:var(--text-dim);">R1:</span>
            <span id="r1" class="c-red">--</span>
          </div>
          <div style="display:flex; justify-content:space-between; margin-bottom:5px; padding:4px; background:rgba(0,212,255,0.1); border-radius:3px;">
            <span class="c-cyan">Current:</span>
            <span id="currentLevel" class="c-cyan">--</span>
          </div>
          <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
            <span style="color:var(--text-dim);">S1:</span>
            <span id="s1" class="c-green">--</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:var(--text-dim);">S2:</span>
            <span id="s2" class="c-green">--</span>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-head">‚ö° LIQUIDITY FLOW</div>
        <div style="padding:10px;">
          <div style="display:flex; height:16px; border-radius:3px; overflow:hidden; margin-bottom:8px;">
            <div id="liqBarBid" style="background:var(--accent-green); height:100%; transition:width 0.3s;"></div>
            <div id="liqBarAsk" style="background:var(--accent-red); height:100%; transition:width 0.3s;"></div>
          </div>
          <div id="liqText" style="font-size:10px; color:var(--text-dim); line-height:1.5;"></div>
          <div id="cvdText" style="font-size:10px; color:var(--text-dim); margin-top:5px;"></div>
        </div>
      </div>
    </div>
  </main>

  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  
  <script>
    // ============================================
    // XRP ORACULUM - OkrtSystem Labs
    // ============================================

    const CONFIG = {
      WHALE_THRESHOLD: 5000,       // 5K XRP (~$9K USD) para ver m√°s actividad
      WALL_THRESHOLD: 50000,       // 50K para paredes
      SPOOF_THRESHOLD: 200000,     // 200K para spoof detection
      HISTORY_SIZE: 100,
      ATR_PERIOD: 14,
      RSI_PERIOD: 14,
      MACD_FAST: 12,
      MACD_SLOW: 26,
      MACD_SIGNAL: 9,
      EMA_FAST: 9,
      EMA_SLOW: 21,
      STOCH_PERIOD: 14,
      BB_PERIOD: 20,
      BB_STD: 2,
      ADX_PERIOD: 14,
      WILLR_PERIOD: 14
    };

    const state = {
      candles: [],
      currentPrice: 0,
      price: 0,  // Alias para compatibilidad
      btcPrice: 0,
      whaleCount: 0,
      cvd: 0,
      whaleBuyVol: 0,
      whaleSellVol: 0,
      predictions: [],
      alertCount: 0,
      lastOrderBook: { bids: [], asks: [] },
      obvHistory: [],
      priceHistory: [],
      rsiHistory: [],
      // Nuevas variables para funcionalidades
      soundEnabled: false,
      currentTimeframe: '1m',
      predictionHistory: [],  // Historial de aciertos/fallos
      exportData: []          // Datos para exportar
    };

    // --- AUDIO CONTEXT para alertas sonoras ---
    let audioCtx = null;
    
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    function playSound(type = 'alert') {
      if (!state.soundEnabled || !audioCtx) return;
      
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      if (type === 'bullish') {
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
        oscillator.frequency.setValueAtTime(1108, audioCtx.currentTime + 0.1); // C#6
      } else if (type === 'bearish') {
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4
        oscillator.frequency.setValueAtTime(330, audioCtx.currentTime + 0.1); // E4
      } else if (type === 'whale') {
        oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // A3 deep
        oscillator.type = 'sawtooth';
      } else {
        oscillator.frequency.setValueAtTime(660, audioCtx.currentTime); // E5
      }
      
      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.3);
    }

    // --- TOGGLE FUNCIONES ---
    function toggleSound() {
      initAudio();
      state.soundEnabled = !state.soundEnabled;
      const btn = document.getElementById('soundBtn');
      if (state.soundEnabled) {
        btn.innerHTML = 'üîä ON';
        btn.classList.add('active');
        playSound('alert'); // Sonido de confirmaci√≥n
      } else {
        btn.innerHTML = 'üîá OFF';
        btn.classList.remove('active');
      }
    }

    // ============================================
    // üéôÔ∏è AI VOICE ALERTS SYSTEM
    // ============================================
    
    const voiceState = {
      enabled: false,
      speaking: false,
      lastSpoke: 0,
      cooldown: 60000, // 60 segundos entre alertas de voz (aumentado de 30s)
      voice: null,
      lang: localStorage.getItem('oraculum_voice_lang') || 'en',
      rate: 1.0,
      pitch: 1.0
    };
    
    // Traducciones para alertas de voz
    const voiceTranslations = {
      en: {
        activated: 'Voice alerts activated. I will announce high quality trading signals.',
        deactivated: 'Voice alerts deactivated.',
        attention: 'Attention!',
        bullish: 'Bullish',
        bearish: 'Bearish',
        signalDetected: 'signal detected.',
        probability: 'Probability',
        percent: 'percent.',
        signalQuality: 'Signal quality',
        marketIs: 'Market is',
        regimes: {
          'trending_up': 'trending upward',
          'trending_down': 'trending downward',
          'ranging': 'consolidating',
          'volatile': 'highly volatile',
          'unknown': 'analyzing'
        },
        divergence: {
          bullish: 'Bullish divergence detected on RSI. Potential reversal signal.',
          bearish: 'Bearish divergence detected on RSI. Potential reversal signal.'
        },
        whale: {
          alert: 'Whale alert!',
          largeBuy: 'Large buy order detected.',
          largeSell: 'Large sell order detected.',
          units: 'K units.'
        },
        session: {
          starting: 'session starting.',
          volatility: 'Expected volatility:'
        },
        langName: 'English',
        narrator: {
          analyzing: 'Analyzing market...',
          bullishSetup: 'Bullish accumulation detected.',
          bearishSetup: 'Bearish distribution detected.',
          whalesAccumulating: 'Whales accumulating,',
          whalesDistributing: 'Whales distributing,',
          rsiOversold: 'RSI exiting oversold',
          rsiOverbought: 'RSI exiting overbought',
          rsiNeutral: 'RSI neutral',
          strongBuyPressure: 'strong buy pressure.',
          strongSellPressure: 'strong sell pressure.',
          mixedSignals: 'mixed signals.',
          nextResistance: 'Resistance:',
          nextSupport: 'Support:',
          regimeIs: 'Regime:',
          probabilityAt: 'prob',
          confluence: 'confluences',
          noiseWarning: 'High noise - wait for clearer signals.',
          trendingUp: 'TREND UP',
          trendingDown: 'TREND DOWN',
          ranging: 'RANGING',
          volatile: 'VOLATILE',
          recommendation: 'Action:',
          wait: 'Wait',
          lookForLongs: 'Look for longs',
          lookForShorts: 'Look for shorts',
          holdPosition: 'Hold position'
        }
      },
      es: {
        activated: 'Alertas de voz activadas. Anunciar√© se√±ales de trading de alta calidad.',
        deactivated: 'Alertas de voz desactivadas.',
        attention: '¬°Atenci√≥n!',
        bullish: 'Alcista',
        bearish: 'Bajista',
        signalDetected: 'se√±al detectada.',
        probability: 'Probabilidad',
        percent: 'por ciento.',
        signalQuality: 'Calidad de se√±al',
        marketIs: 'El mercado est√°',
        regimes: {
          'trending_up': 'en tendencia alcista',
          'trending_down': 'en tendencia bajista',
          'ranging': 'en consolidaci√≥n',
          'volatile': 'muy vol√°til',
          'unknown': 'analizando'
        },
        divergence: {
          bullish: 'Divergencia alcista detectada en RSI. Posible se√±al de reversi√≥n.',
          bearish: 'Divergencia bajista detectada en RSI. Posible se√±al de reversi√≥n.'
        },
        whale: {
          alert: '¬°Alerta de ballena!',
          largeBuy: 'Gran orden de compra detectada.',
          largeSell: 'Gran orden de venta detectada.',
          units: 'mil unidades.'
        },
        session: {
          starting: 'sesi√≥n iniciando.',
          volatility: 'Volatilidad esperada:'
        },
        langName: 'Espa√±ol',
        narrator: {
          analyzing: 'Analizando mercado...',
          bullishSetup: 'Acumulaci√≥n alcista detectada.',
          bearishSetup: 'Distribuci√≥n bajista detectada.',
          whalesAccumulating: 'Ballenas acumulando,',
          whalesDistributing: 'Ballenas distribuyendo,',
          rsiOversold: 'RSI saliendo de sobreventa',
          rsiOverbought: 'RSI saliendo de sobrecompra',
          rsiNeutral: 'RSI neutral',
          strongBuyPressure: 'fuerte presi√≥n compradora.',
          strongSellPressure: 'fuerte presi√≥n vendedora.',
          mixedSignals: 'se√±ales mixtas.',
          nextResistance: 'Resistencia:',
          nextSupport: 'Soporte:',
          regimeIs: 'R√©gimen:',
          probabilityAt: 'prob',
          confluence: 'confluencias',
          noiseWarning: 'Alto ruido - esperar se√±ales m√°s claras.',
          trendingUp: 'ALCISTA',
          trendingDown: 'BAJISTA',
          ranging: 'LATERAL',
          volatile: 'VOL√ÅTIL',
          recommendation: 'Acci√≥n:',
          wait: 'Esperar',
          lookForLongs: 'Buscar largos',
          lookForShorts: 'Buscar cortos',
          holdPosition: 'Mantener posici√≥n'
        }
      }
    };
    
    // Obtener traducci√≥n actual
    function t(key) {
      const keys = key.split('.');
      let value = voiceTranslations[voiceState.lang];
      for (const k of keys) {
        value = value?.[k];
      }
      return value || key;
    }
    
    // Inicializar voces disponibles
    function initVoices() {
      if ('speechSynthesis' in window) {
        const voices = speechSynthesis.getVoices();
        updateVoiceForLanguage(voices);
      }
    }
    
    function updateVoiceForLanguage(voices) {
      if (!voices || voices.length === 0) {
        voices = speechSynthesis.getVoices();
      }
      
      const langCode = voiceState.lang === 'es' ? 'es' : 'en';
      
      // Buscar mejor voz para el idioma
      voiceState.voice = voices.find(v => v.name.includes('Google') && v.lang.startsWith(langCode)) ||
                        voices.find(v => v.lang.startsWith(langCode)) ||
                        voices.find(v => v.lang.startsWith(langCode.toUpperCase())) ||
                        voices[0];
    }
    
    // Cargar voces cuando est√©n disponibles
    if ('speechSynthesis' in window) {
      speechSynthesis.onvoiceschanged = initVoices;
      initVoices();
    }
    
    // Cambiar idioma de voz
    function changeVoiceLanguage(lang) {
      voiceState.lang = lang;
      localStorage.setItem('oraculum_voice_lang', lang);
      
      // Actualizar voz para el nuevo idioma
      updateVoiceForLanguage();
      
      // Actualizar UI del selector
      const selector = document.getElementById('voiceLangSelect');
      if (selector) selector.value = lang;
      
      // Confirmar cambio con voz
      if (voiceState.enabled) {
        const confirmText = lang === 'es' ? 'Idioma cambiado a espa√±ol.' : 'Language changed to English.';
        speakAlert(confirmText, 'high');
      }
    }
    
    // Funci√≥n principal de voz
    function speakAlert(text, priority = 'normal') {
      if (!voiceState.enabled || !('speechSynthesis' in window)) return;
      if (voiceState.speaking) return;
      
      const now = Date.now();
      // Respetar cooldown excepto para alertas de alta prioridad
      if (priority !== 'high' && now - voiceState.lastSpoke < voiceState.cooldown) return;
      
      // Cancelar cualquier speech anterior
      speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.voice = voiceState.voice;
      utterance.lang = voiceState.lang === 'es' ? 'es-ES' : 'en-US';
      utterance.rate = voiceState.rate;
      utterance.pitch = voiceState.pitch;
      utterance.volume = 0.8;
      
      utterance.onstart = () => {
        voiceState.speaking = true;
        updateVoiceIndicator(true);
      };
      
      utterance.onend = () => {
        voiceState.speaking = false;
        voiceState.lastSpoke = Date.now();
        updateVoiceIndicator(false);
      };
      
      utterance.onerror = () => {
        voiceState.speaking = false;
        updateVoiceIndicator(false);
      };
      
      speechSynthesis.speak(utterance);
    }
    
    // Actualizar indicador visual de voz
    function updateVoiceIndicator(speaking) {
      const indicator = document.getElementById('voiceIndicator');
      if (indicator) {
        indicator.style.color = speaking ? 'var(--accent-cyan)' : 'var(--text-dim)';
        indicator.style.animation = speaking ? 'pulse 0.5s infinite' : 'none';
      }
    }
    
    // Toggle voz
    function toggleVoice() {
      voiceState.enabled = !voiceState.enabled;
      const btn = document.getElementById('voiceBtn');
      
      if (voiceState.enabled) {
        btn.innerHTML = 'üéôÔ∏è <span style="color:var(--accent-green)">ON</span>';
        btn.classList.add('active');
        speakAlert(t('activated'), 'high');
      } else {
        btn.innerHTML = 'üéôÔ∏è <span style="color:var(--text-dim)">OFF</span>';
        btn.classList.remove('active');
        speechSynthesis.cancel();
      }
    }
    
    // üé® Toggle Theme (Default / Neon)
    let currentTheme = localStorage.getItem('oraculum_theme') || 'default';
    
    function toggleTheme() {
      const btn = document.getElementById('themeBtn');
      
      if (currentTheme === 'default') {
        document.body.classList.add('neon-mode');
        document.body.classList.remove('light-mode');
        currentTheme = 'neon';
        btn.innerHTML = 'üé® DEFAULT';
        btn.style.background = 'linear-gradient(135deg, rgba(0,255,255,0.3), rgba(255,0,255,0.3))';
        btn.style.borderColor = 'var(--accent-cyan)';
        btn.style.boxShadow = '0 0 10px rgba(0,255,255,0.3)';
      } else {
        document.body.classList.remove('neon-mode');
        document.body.classList.remove('light-mode');
        currentTheme = 'default';
        btn.innerHTML = 'üé® NEON';
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.style.boxShadow = '';
      }
      
      localStorage.setItem('oraculum_theme', currentTheme);
    }
    
    // Aplicar tema guardado al cargar
    if (currentTheme === 'neon') {
      document.body.classList.add('neon-mode');
      setTimeout(() => {
        const btn = document.getElementById('themeBtn');
        if (btn) {
          btn.innerHTML = 'üé® DEFAULT';
          btn.style.background = 'linear-gradient(135deg, rgba(0,255,255,0.3), rgba(255,0,255,0.3))';
          btn.style.borderColor = 'var(--accent-cyan)';
          btn.style.boxShadow = '0 0 10px rgba(0,255,255,0.3)';
        }
      }, 100);
    }
    
    // Generar texto para se√±ales de trading
    function generateSignalVoiceText(direction, probability, quality, regime) {
      const dirText = direction === 'BULL' ? t('bullish') : t('bearish');
      const regimeText = t(`regimes.${regime}`) || regime;
      
      return `${t('attention')} ${dirText} ${t('signalDetected')} ` +
             `${t('probability')} ${Math.round(probability)} ${t('percent')} ` +
             `${t('signalQuality')} ${Math.round(quality)} ${t('percent')} ` +
             `${t('marketIs')} ${regimeText}.`;
    }
    
    // Generar comentario de mercado
    function generateMarketCommentary() {
      if (!voiceState.enabled || voiceState.speaking) return;
      
      const regime = aiState.marketRegime;
      const probBull = aiState.probabilityBull;
      const quality = aiState.signalQuality;
      const noise = aiState.noiseLevel;
      
      let commentary = '';
      
      if (noise > 60) {
        commentary = 'Market is noisy. Recommend waiting for clearer signals.';
      } else if (quality >= 70 && probBull >= 65) {
        commentary = `Bullish setup forming. ${Math.round(probBull)} percent probability with good signal quality.`;
      } else if (quality >= 70 && probBull <= 35) {
        commentary = `Bearish pressure detected. ${Math.round(100-probBull)} percent sell probability.`;
      } else if (regime === 'trending_up') {
        commentary = 'Uptrend in progress. Look for pullbacks to support.';
      } else if (regime === 'trending_down') {
        commentary = 'Downtrend active. Resistance levels are key.';
      } else if (regime === 'volatile') {
        commentary = 'High volatility detected. Trade with caution.';
      } else {
        commentary = 'Market consolidating. Waiting for breakout direction.';
      }
      
      return commentary;
    }
    
    // Alertas especiales por voz
    function voiceAlertWhale(side, amount, price) {
      if (!voiceState.enabled) return;
      const sideText = side === 'BUY' ? t('whale.largeBuy') : t('whale.largeSell');
      speakAlert(`${t('whale.alert')} ${sideText} ${Math.round(amount/1000)} ${t('whale.units')}`);
    }
    
    function voiceAlertDivergence(type) {
      if (!voiceState.enabled) return;
      const divergenceKey = type.toLowerCase();
      speakAlert(t(`divergence.${divergenceKey}`), 'high');
    }
    
    function voiceAlertSession(session) {
      if (!voiceState.enabled) return;
      speakAlert(`${session.name} ${t('session.starting')} ${t('session.volatility')} ${session.volatility}.`);
    }

    // ============================================
    // üí∞ PAPER TRADING SIMULATOR
    // ============================================
    
    const paperTrading = {
      enabled: true,
      balance: parseFloat(localStorage.getItem('pt_balance')) || 10000,
      startingBalance: 10000,
      position: JSON.parse(localStorage.getItem('pt_position')) || null,
      history: JSON.parse(localStorage.getItem('pt_history')) || [],
      stats: JSON.parse(localStorage.getItem('pt_stats')) || { wins: 0, losses: 0, totalPnL: 0 }
    };
    
    function savePaperTradingState() {
      localStorage.setItem('pt_balance', paperTrading.balance.toString());
      localStorage.setItem('pt_position', JSON.stringify(paperTrading.position));
      localStorage.setItem('pt_history', JSON.stringify(paperTrading.history.slice(-50)));
      localStorage.setItem('pt_stats', JSON.stringify(paperTrading.stats));
    }
    
    function openPaperTrade(type) {
      if (paperTrading.position) {
        addAlert('‚ö†Ô∏è Already have open position', 'warning');
        return;
      }
      const amount = parseFloat(document.getElementById('ptAmount')?.value) || 0;
      if (amount <= 0) { addAlert('‚ö†Ô∏è Enter amount', 'warning'); return; }
      const cost = amount * state.currentPrice;
      if (cost > paperTrading.balance) { addAlert('‚ö†Ô∏è Insufficient balance', 'warning'); return; }
      
      paperTrading.position = { type, amount, entryPrice: state.currentPrice, timestamp: Date.now() };
      paperTrading.balance -= cost;
      savePaperTradingState();
      updatePaperTradingUI();
      addAlert(`üí∞ ${type.toUpperCase()} ${amount} XRP @ $${state.currentPrice.toFixed(4)}`, type === 'long' ? 'bullish' : 'bearish');
    }
    
    function closePaperTrade() {
      if (!paperTrading.position) { addAlert('‚ö†Ô∏è No position', 'warning'); return; }
      const pos = paperTrading.position;
      const currentValue = pos.amount * state.currentPrice;
      const entryValue = pos.amount * pos.entryPrice;
      const pnl = pos.type === 'long' ? currentValue - entryValue : entryValue - currentValue;
      
      paperTrading.balance += entryValue + pnl;
      paperTrading.history.unshift({ ...pos, exitPrice: state.currentPrice, pnl, timestamp: Date.now() });
      if (pnl > 0) paperTrading.stats.wins++; else paperTrading.stats.losses++;
      paperTrading.stats.totalPnL += pnl;
      paperTrading.position = null;
      savePaperTradingState();
      updatePaperTradingUI();
      addAlert(`üí∞ Closed: ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`, pnl >= 0 ? 'bullish' : 'bearish');
    }
    
    function resetPaperTrading() {
      if (confirm('Reset Paper Trading?')) {
        paperTrading.balance = 10000;
        paperTrading.position = null;
        paperTrading.history = [];
        paperTrading.stats = { wins: 0, losses: 0, totalPnL: 0 };
        savePaperTradingState();
        updatePaperTradingUI();
      }
    }
    
    function updatePaperTradingUI() {
      const balanceEl = document.getElementById('ptBalance');
      if (balanceEl) balanceEl.innerText = paperTrading.balance >= 1000 ? '$' + (paperTrading.balance/1000).toFixed(1) + 'K' : '$' + paperTrading.balance.toFixed(0);
      
      const totalPnL = paperTrading.balance - paperTrading.startingBalance;
      const pnlEl = document.getElementById('ptPnL');
      if (pnlEl) {
        pnlEl.innerText = (totalPnL >= 0 ? '+$' : '-$') + Math.abs(totalPnL).toFixed(0);
        pnlEl.style.color = totalPnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
      }
      
      const winRateEl = document.getElementById('ptWinRate');
      if (winRateEl) {
        const total = paperTrading.stats.wins + paperTrading.stats.losses;
        const wr = total > 0 ? (paperTrading.stats.wins / total * 100).toFixed(0) : 0;
        winRateEl.innerText = wr + '%';
        winRateEl.style.color = wr >= 50 ? 'var(--accent-green)' : 'var(--accent-red)';
      }
      
      const tradesEl = document.getElementById('ptTrades');
      if (tradesEl) tradesEl.innerText = paperTrading.stats.wins + paperTrading.stats.losses;
      
      const positionEl = document.getElementById('ptPosition');
      if (positionEl) {
        if (paperTrading.position) {
          const pos = paperTrading.position;
          const pnl = pos.type === 'long' ? (state.currentPrice - pos.entryPrice) * pos.amount : (pos.entryPrice - state.currentPrice) * pos.amount;
          const pnlPct = ((pnl / (pos.amount * pos.entryPrice)) * 100).toFixed(1);
          positionEl.innerHTML = `<span>${pos.type === 'long' ? 'üü¢' : 'üî¥'} ${pos.amount} @ $${pos.entryPrice.toFixed(4)}</span> <span style="color:${pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}; float:right;">${pnl >= 0 ? '+' : ''}${pnlPct}%</span>`;
        } else {
          positionEl.innerHTML = '<span style="color:var(--text-dim);">No position</span>';
        }
      }
      
      const buyBtn = document.getElementById('ptBuyBtn'), sellBtn = document.getElementById('ptSellBtn'), closeBtn = document.getElementById('ptCloseBtn');
      if (buyBtn && sellBtn && closeBtn) {
        if (paperTrading.position) {
          buyBtn.style.display = 'none'; sellBtn.style.display = 'none'; closeBtn.style.display = 'block';
        } else {
          buyBtn.style.display = 'block'; sellBtn.style.display = 'block'; closeBtn.style.display = 'none';
        }
      }
    }

    // ============================================
    // ü§ñ AI MARKET NARRATOR
    // ============================================
    
    let lastNarrativeUpdate = 0;
    
    function generateNarrative() {
      const lang = voiceState.lang;
      const nt = (key) => voiceTranslations[lang]?.narrator?.[key] || key;
      const regime = aiState.marketRegime;
      const probBull = aiState.probabilityBull;
      const quality = aiState.signalQuality;
      const noise = aiState.noiseLevel;
      const rsi = state.rsiHistory?.[state.rsiHistory.length - 1] || 50;
      const whaleFlow = (state.whaleBuyVol || 0) - (state.whaleSellVol || 0);
      
      let parts = [];
      
      if (noise > 60) return nt('noiseWarning');
      
      // Regime
      const regimeText = { 'trending_up': nt('trendingUp'), 'trending_down': nt('trendingDown'), 'ranging': nt('ranging'), 'volatile': nt('volatile') };
      parts.push(`${nt('regimeIs')} ${regimeText[regime] || regime} (${Math.round(probBull > 50 ? probBull : 100-probBull)}% ${nt('probabilityAt')}).`);
      
      // RSI
      if (rsi < 35) parts.push(nt('rsiOversold'));
      else if (rsi > 65) parts.push(nt('rsiOverbought'));
      
      // Whales
      if (whaleFlow > 50000) parts.push(nt('whalesAccumulating') + ' ' + nt('strongBuyPressure'));
      else if (whaleFlow < -50000) parts.push(nt('whalesDistributing') + ' ' + nt('strongSellPressure'));
      
      // Recommendation
      parts.push(nt('recommendation'));
      if (quality < 50 || noise > 45) parts.push(nt('wait'));
      else if (probBull >= 65) parts.push(nt('lookForLongs'));
      else if (probBull <= 35) parts.push(nt('lookForShorts'));
      else parts.push(nt('wait'));
      
      return parts.join(' ');
    }
    
    function updateNarratorUI() {
      const now = Date.now();
      if (now - lastNarrativeUpdate < 15000) return;
      lastNarrativeUpdate = now;
      
      const el = document.getElementById('aiNarratorText');
      if (el) {
        el.style.opacity = '0.5';
        setTimeout(() => { el.innerText = generateNarrative(); el.style.opacity = '1'; }, 150);
      }
      const ts = document.getElementById('narratorTimestamp');
      if (ts) ts.innerText = new Date().toLocaleTimeString('en-US', {hour:'2-digit', minute:'2-digit'});
    }
    
    function speakNarrative() {
      if (!voiceState.enabled) { addAlert('‚ö†Ô∏è Enable voice first', 'warning'); return; }
      speakAlert(generateNarrative(), 'high');
    }

    // Tab switching for right sidebar
    function switchRightTab(tabName) {
      const container = event.target.closest('.panel');
      container.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      container.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      container.querySelector('#tab-' + tabName).classList.add('active');
    }
    
    function toggleTheme() {
      document.body.classList.toggle('light-mode');
      const btn = document.getElementById('themeBtn');
      if (document.body.classList.contains('light-mode')) {
        btn.innerHTML = 'üåô';
      } else {
        btn.innerHTML = '‚òÄÔ∏è';
      }
    }

    // --- TIMEFRAME CHANGE ---
    function changeTimeframe(tf) {
      state.currentTimeframe = tf;
      state.candles = [];
      state.priceHistory = [];
      state.rsiHistory = [];
      state.obvHistory = [];
      
      // Reconectar WebSocket con nuevo timeframe
      if (ws) ws.close();
      fetchHistoricalData();
      connectAPI();
      
      addAlert(`Timeframe changed to ${tf}`, 'info');
    }

    // --- EXPORT DATA TO CSV ---
    function exportData() {
      if (state.candles.length === 0) {
        alert('No data to export yet!');
        return;
      }
      
      // Preparar datos
      let csv = 'Timestamp,Open,High,Low,Close,Volume,RSI,Prediction,Actual,Correct\\n';
      
      state.predictions.forEach((pred, idx) => {
        const candle = state.candles[idx] || {};
        const correct = pred.correct !== undefined ? (pred.correct ? 'YES' : 'NO') : 'PENDING';
        csv += `${new Date(pred.timestamp).toISOString()},`;
        csv += `${candle.open || ''},${candle.high || ''},${candle.low || ''},${candle.close || ''},${candle.volume || ''},`;
        csv += `${pred.rsi || ''},${pred.target.toFixed(6)},${pred.actual.toFixed(6)},${correct}\\n`;
      });
      
      // Crear y descargar archivo
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `XRP_ORACULUM_${state.currentTimeframe}_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      addAlert('Data exported to CSV', 'info');
    }

    // --- UPDATE PREDICTION HISTORY CHART ---
    function updatePredictionHistoryChart() {
      const container = document.getElementById('accuracyHistoryChart');
      if (!container) return;
      
      container.innerHTML = '';
      
      // Mostrar √∫ltimas 20 predicciones
      const history = state.predictionHistory.slice(-20);
      
      if (history.length === 0) {
        // Mostrar cu√°ntas predicciones faltan para empezar
        const needed = Math.max(0, 10 - state.predictions.length);
        const current = state.predictions.length;
        
        if (current === 0) {
          container.innerHTML = '<span class="ai-label" style="color:var(--text-dim);">‚è≥ Waiting for data...</span>';
        } else if (needed > 0) {
          container.innerHTML = `<span class="ai-label" style="color:var(--text-dim);">üìä ${current}/10 samples (${needed} more needed)</span>`;
        } else {
          container.innerHTML = '<span class="ai-label" style="color:var(--text-dim);">üîÑ Processing predictions...</span>';
        }
        return;
      }
      
      // Calcular estad√≠sticas
      const correct = history.filter(r => r).length;
      const accuracy = ((correct / history.length) * 100).toFixed(0);
      
      // Crear contenedor flex para barras + stats
      const wrapper = document.createElement('div');
      wrapper.style.cssText = 'display:flex; align-items:center; gap:8px; width:100%;';
      
      // Contenedor de barras
      const barsContainer = document.createElement('div');
      barsContainer.style.cssText = 'display:flex; gap:2px; flex:1; height:100%;';
      
      history.forEach((result, idx) => {
        const bar = document.createElement('div');
        bar.className = 'accuracy-bar-mini';
        bar.style.cssText = `flex:1; height:100%; border-radius:2px; background:${result ? 'var(--accent-green)' : 'var(--accent-red)'}; opacity:${0.3 + (idx / history.length) * 0.7};`;
        bar.title = result ? '‚úì Correct' : '‚úó Incorrect';
        barsContainer.appendChild(bar);
      });
      
      wrapper.appendChild(barsContainer);
      
      // Mini stats
      const stats = document.createElement('span');
      stats.className = 'ai-label';
      stats.style.cssText = `color:${accuracy >= 55 ? 'var(--accent-green)' : accuracy >= 45 ? 'var(--accent-orange)' : 'var(--accent-red)'}; white-space:nowrap;`;
      stats.innerText = `${accuracy}%`;
      wrapper.appendChild(stats);
      
      container.appendChild(wrapper);
    }

    // --- UI REFS ---
    const ui = {
      statusPill: document.getElementById('statusPill'),
      statusText: document.getElementById('apiStatusText'),
      clock: document.getElementById('clock'),
      price: document.getElementById('priceDisplay'),
      priceChange: document.getElementById('priceChange'),
      volume: document.getElementById('volDisplay'),
      fg: document.getElementById('fgIndex'),
      fgLabel: document.getElementById('fgLabel'),
      fundingRate: document.getElementById('fundingRate'),
      fundingLabel: document.getElementById('fundingLabel'),
      openInterest: document.getElementById('openInterest'),
      oiChange: document.getElementById('oiChange'),
      totalScore: document.getElementById('totalScore'),
      scoreLabel: document.getElementById('scoreLabel'),
      aiTarget: document.getElementById('aiTarget'),
      conf: document.getElementById('confLevel'),
      modelAccuracy: document.getElementById('modelAccuracy'),
      accuracyBar: document.getElementById('accuracyBar'),
      accuracyPct: document.getElementById('accuracyPct'),
      scoreFill: document.getElementById('scoreFill'),
      bids: document.getElementById('bidSide'),
      asks: document.getElementById('askSide'),
      midPrice: document.getElementById('midPrice'),
      wallDetection: document.getElementById('wallDetection'),
      spoofWarning: document.getElementById('spoofWarning'),
      liqBarBid: document.getElementById('liqBarBid'),
      liqBarAsk: document.getElementById('liqBarAsk'),
      liqText: document.getElementById('liqText'),
      cvdText: document.getElementById('cvdText'),
      whaleList: document.getElementById('whaleList'),
      whaleCount: document.getElementById('whaleCount'),
      bullCount: document.getElementById('bullCount'),
      neutCount: document.getElementById('neutCount'),
      bearCount: document.getElementById('bearCount'),
      consensus: document.getElementById('consensus'),
      alertsContainer: document.getElementById('alertsContainer'),
      alertCount: document.getElementById('alertCount'),
      btcPrice: document.getElementById('btcPrice'),
      divergenceBadge: document.getElementById('divergenceBadge'),
      patternsContainer: document.getElementById('patternsContainer'),
      // AI Engine v2 elements
      marketRegime: document.getElementById('marketRegime'),
      signalQuality: document.getElementById('signalQuality'),
      probBull: document.getElementById('probBull'),
      probBear: document.getElementById('probBear'),
      confluenceCount: document.getElementById('confluenceCount'),
      noiseLevel: document.getElementById('noiseLevel')
    };

    // ============================================
    // PERFORMANCE CONTROL (CPU/RAM/DOM)
    // ============================================
    const PERF = {
      UI_MIN_MS: 200,               // Consolidar escrituras DOM (5 fps)
      ORDERBOOK_MIN_MS: 250,        // Reducir coste de profundidad (4 fps)
      CVD_UI_MIN_MS: 250,           // Consolidar CVD (4 fps)
      PREDICTION_MIN_MS: 600,       // Evitar correr predicci√≥n por cada tick
      SPOOF_CHECK_MIN_MS: 1200,     // No calcular spoofing continuamente
      SPOOF_ALERT_COOLDOWN_MS: 15000
    };

    const perf = {
      // Ticker coalescing
      latestTicker: null,
      tickerDirty: false,
      lastUIFlush: 0,

      // Order book coalescing
      latestDepth: null,
      depthDirty: false,
      lastOrderbookFlush: 0,

      // CVD coalescing
      cvdDirty: false,
      lastCvdFlush: 0,

      // Prediction throttle
      lastPredictionRun: 0,

      // Spoof throttle/cooldown
      lastSpoofCheck: 0,
      lastSpoofAlert: 0,
      spoofLastState: false,

      // RAF scheduler
      uiRaf: 0,
      obRaf: 0,

      // Visibility
      paused: false
    };

    function _now() { return (window.performance && performance.now) ? performance.now() : Date.now(); }

    function pushCapped(arr, item, maxLen) {
      arr.push(item);
      if (arr.length > maxLen) arr.splice(0, arr.length - maxLen);
    }

    // Pausar render intensivo cuando la pesta√±a est√° en segundo plano
    document.addEventListener('visibilitychange', () => {
      perf.paused = document.hidden;
      if (!perf.paused) {
        scheduleUIFlush(true);
        scheduleOrderBookFlush(true);
      }
    });

    function ensurePriceChangeSpan() {
      if (!ui._priceChangeSpan && ui.priceChange) {
        ui.priceChange.innerHTML = '';
        const sp = document.createElement('span');
        ui.priceChange.appendChild(sp);
        ui._priceChangeSpan = sp;
      }
    }

    function scheduleUIFlush(force = false) {
      if (perf.uiRaf) return;
      perf.uiRaf = requestAnimationFrame(() => {
        perf.uiRaf = 0;
        flushUI(force);
      });
    }

    function flushUI(force = false) {
      if (perf.paused) return;

      const now = _now();
      if (!force && (now - perf.lastUIFlush) < PERF.UI_MIN_MS) {
        scheduleUIFlush();
        return;
      }

      // Ticker UI
      if (perf.tickerDirty && perf.latestTicker) {
        const { price, change, volume } = perf.latestTicker;

        ui.price.innerText = price.toFixed(4);
        ui.midPrice.innerText = price.toFixed(4);

        ensurePriceChangeSpan();
        if (ui._priceChangeSpan) {
          ui._priceChangeSpan.className = (change >= 0) ? 'c-green' : 'c-red';
          ui._priceChangeSpan.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
        }

        ui.volume.innerText = (volume / 1000000).toFixed(2) + 'M';

        perf.tickerDirty = false;
      }

      // CVD UI (solo si cambi√≥)
      if (perf.cvdDirty && (force || (now - perf.lastCvdFlush) >= PERF.CVD_UI_MIN_MS)) {
        ui.cvdText.innerHTML = `CVD: <span class="${state.cvd >= 0 ? 'c-green' : 'c-red'}">${state.cvd >= 0 ? '+' : ''}${(state.cvd / 1000).toFixed(1)}K</span>`;
        perf.cvdDirty = false;
        perf.lastCvdFlush = now;
      }

      perf.lastUIFlush = now;
    }

    function scheduleOrderBookFlush(force = false) {
      if (perf.obRaf) return;
      perf.obRaf = requestAnimationFrame(() => {
        perf.obRaf = 0;
        flushOrderBook(force);
      });
    }

    function flushOrderBook(force = false) {
      if (perf.paused) return;

      const now = _now();
      if (!force && (now - perf.lastOrderbookFlush) < PERF.ORDERBOOK_MIN_MS) {
        scheduleOrderBookFlush();
        return;
      }


    

      if (perf.depthDirty && perf.latestDepth) {
        const { bids, asks } = perf.latestDepth;
        state.lastOrderBook = { bids, asks };
        updateOrderBook(bids, asks);
        perf.depthDirty = false;
      }

      perf.lastOrderbookFlush = now;
    }

// --- TAB SWITCH ---
    function switchTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      document.getElementById('tab-' + tabName).classList.add('active');
    }

    function switchWhaleTab(tabName) {
      const container = event.target.closest('.panel');
      container.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      container.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      container.querySelector('#tab-' + tabName).classList.add('active');
    }

    // --- CHART ---
    let chart, candleSeries, trendLineUp, trendLineDown, ema9Series, ema21Series;
    let supportLines = [], resistanceLines = [], fiboLines = [];

    function initChart() {
      const container = document.getElementById('chartContainer');
      chart = LightweightCharts.createChart(container, {
        width: container.clientWidth,
        height: container.clientHeight,
        layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#94a3b8' },
        grid: { vertLines: { color: 'rgba(255,255,255,0.03)' }, horzLines: { color: 'rgba(255,255,255,0.03)' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { 
          borderColor: 'rgba(255,255,255,0.1)', 
          scaleMargins: { top: 0.05, bottom: 0.05 },
          autoScale: true
        },
        timeScale: { 
          borderColor: 'rgba(255,255,255,0.1)', 
          timeVisible: true,
          rightOffset: 5,
          barSpacing: 10,
          minBarSpacing: 5
        },
        localization: {
          timeFormatter: (timestamp) => {
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          }
        }
      });

      candleSeries = chart.addCandlestickSeries({
        upColor: '#00ff88', downColor: '#ff4466',
        borderUpColor: '#00ff88', borderDownColor: '#ff4466',
        wickUpColor: '#00ff88', wickDownColor: '#ff4466'
      });

      // EMA 9 - R√°pida (Cyan)
      ema9Series = chart.addLineSeries({
        color: '#00d4ff',
        lineWidth: 1,
        crosshairMarkerVisible: false,
        lastValueVisible: true,
        priceLineVisible: false,
        title: 'EMA 9',
      });

      // EMA 21 - Lenta (P√∫rpura)
      ema21Series = chart.addLineSeries({
        color: '#a855f7',
        lineWidth: 1,
        crosshairMarkerVisible: false,
        lastValueVisible: true,
        priceLineVisible: false,
        title: 'EMA 21',
      });

      // L√≠nea de tendencia alcista (soporte)
      trendLineUp = chart.addLineSeries({
        color: '#00ff88',
        lineWidth: 2,
        lineStyle: 0, // Solid
        crosshairMarkerVisible: false,
        lastValueVisible: false,
        priceLineVisible: false,
        autoscaleInfoProvider: () => null,
      });

      // L√≠nea de tendencia bajista (resistencia)
      trendLineDown = chart.addLineSeries({
        color: '#ff4466',
        lineWidth: 2,
        lineStyle: 0, // Solid
        crosshairMarkerVisible: false,
        lastValueVisible: false,
        priceLineVisible: false,
        autoscaleInfoProvider: () => null,
      });

      // Crear series para S/R levels (3 soportes + 3 resistencias)
      // autoscaleInfoProvider: () => null evita que estas l√≠neas expandan el rango del gr√°fico
      for (let i = 0; i < 3; i++) {
        supportLines.push(chart.addLineSeries({
          color: 'rgba(0, 255, 136, 0.6)',
          lineWidth: 1,
          lineStyle: 2, // Dashed
          crosshairMarkerVisible: false,
          lastValueVisible: true,
          priceLineVisible: false,
          title: `S${i+1}`,
          autoscaleInfoProvider: () => null,
        }));
        resistanceLines.push(chart.addLineSeries({
          color: 'rgba(255, 68, 102, 0.6)',
          lineWidth: 1,
          lineStyle: 2, // Dashed
          crosshairMarkerVisible: false,
          lastValueVisible: true,
          priceLineVisible: false,
          title: `R${i+1}`,
          autoscaleInfoProvider: () => null,
        }));
      }

      // Crear series para Fibonacci (5 niveles: 0.236, 0.382, 0.5, 0.618, 0.786)
      const fiboColors = ['#f4b942', '#f4b942', '#00d4ff', '#f4b942', '#f4b942'];
      const fiboWidths = [1, 1, 2, 1, 1];
      for (let i = 0; i < 5; i++) {
        fiboLines.push(chart.addLineSeries({
          color: fiboColors[i],
          lineWidth: fiboWidths[i],
          lineStyle: 1, // Dotted
          crosshairMarkerVisible: false,
          lastValueVisible: true,
          priceLineVisible: false,
          autoscaleInfoProvider: () => null,
        }));
      }

      new ResizeObserver(() => {
        chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
      }).observe(container);
    }

    // ============================================
    // EMA CALCULATION FOR CHART
    // ============================================

    function calculateEMAData(candles, period) {
      if (candles.length < period) return [];
      
      const emaData = [];
      const k = 2 / (period + 1);
      
      // Calcular SMA inicial
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += candles[i].close;
      }
      let ema = sum / period;
      
      emaData.push({ time: candles[period - 1].time, value: ema });
      
      // Calcular EMA para el resto
      for (let i = period; i < candles.length; i++) {
        ema = candles[i].close * k + ema * (1 - k);
        emaData.push({ time: candles[i].time, value: ema });
      }
      
      return emaData;
    }

    function updateEMAs() {
      if (!state.candles || state.candles.length < 21) return;
      
      try {
        const ema9Data = calculateEMAData(state.candles, 9);
        const ema21Data = calculateEMAData(state.candles, 21);
        
        if (ema9Series && ema9Data.length > 0) {
          ema9Series.setData(ema9Data);
        }
        if (ema21Series && ema21Data.length > 0) {
          ema21Series.setData(ema21Data);
        }
      } catch (e) {
        console.error('EMA update error:', e);
      }
    }

    // ============================================
    // AUTO TREND LINES (Professional Algorithm)
    // ============================================

    // Encontrar pivotes/swings significativos
    function findPivotPoints(candles, strength = 2) {
      if (candles.length < strength * 2 + 1) return { pivotHighs: [], pivotLows: [] };
      
      const pivotHighs = [];
      const pivotLows = [];
      const recentCandles = candles.slice(-50); // Solo √∫ltimas 50 velas
      
      for (let i = strength; i < recentCandles.length - strength; i++) {
        let isPivotHigh = true;
        let isPivotLow = true;
        
        for (let j = 1; j <= strength; j++) {
          if (recentCandles[i].high < recentCandles[i - j].high || 
              recentCandles[i].high < recentCandles[i + j].high) {
            isPivotHigh = false;
          }
          if (recentCandles[i].low > recentCandles[i - j].low || 
              recentCandles[i].low > recentCandles[i + j].low) {
            isPivotLow = false;
          }
        }
        
        if (isPivotHigh) {
          pivotHighs.push({ 
            time: recentCandles[i].time, 
            value: recentCandles[i].high,
            index: candles.length - recentCandles.length + i
          });
        }
        if (isPivotLow) {
          pivotLows.push({ 
            time: recentCandles[i].time, 
            value: recentCandles[i].low,
            index: candles.length - recentCandles.length + i
          });
        }
      }
      
      return { pivotHighs, pivotLows };
    }

    // Encontrar la mejor l√≠nea de tendencia usando los 2 puntos m√°s significativos
    function findBestTrendLine(pivots, isSupport = true) {
      if (pivots.length < 2) return null;
      
      // Tomar los √∫ltimos 4-5 pivotes
      const recentPivots = pivots.slice(-5);
      if (recentPivots.length < 2) return null;
      
      let bestLine = null;
      let bestScore = -Infinity;
      
      // Probar combinaciones de 2 puntos
      for (let i = 0; i < recentPivots.length - 1; i++) {
        for (let j = i + 1; j < recentPivots.length; j++) {
          const p1 = recentPivots[i];
          const p2 = recentPivots[j];
          
          const timeDiff = p2.time - p1.time;
          if (timeDiff <= 0) continue;
          
          const slope = (p2.value - p1.value) / timeDiff;
          
          // Para soporte: preferir pendiente positiva o neutral
          // Para resistencia: preferir pendiente negativa o neutral
          let score = 0;
          
          if (isSupport) {
            // Soporte: contar cu√°ntos puntos est√°n por encima de la l√≠nea
            score = slope >= 0 ? 1 : 0;
            for (const p of recentPivots) {
              const expectedValue = p1.value + slope * (p.time - p1.time);
              if (p.value >= expectedValue * 0.998) score += 1;
            }
          } else {
            // Resistencia: contar cu√°ntos puntos est√°n por debajo de la l√≠nea
            score = slope <= 0 ? 1 : 0;
            for (const p of recentPivots) {
              const expectedValue = p1.value + slope * (p.time - p1.time);
              if (p.value <= expectedValue * 1.002) score += 1;
            }
          }
          
          // Preferir l√≠neas m√°s recientes
          score += (j - i) * 0.5;
          
          if (score > bestScore) {
            bestScore = score;
            bestLine = { p1, p2, slope };
          }
        }
      }
      
      return bestLine;
    }

    function updateTrendLines() {
      if (!state.candles || state.candles.length < 20) {
        if (trendLineUp) trendLineUp.setData([]);
        if (trendLineDown) trendLineDown.setData([]);
        return;
      }
      
      const { pivotHighs, pivotLows } = findPivotPoints(state.candles, 2);
      
      // L√≠nea de soporte (conectando m√≠nimos)
      if (pivotLows.length >= 2 && trendLineUp) {
        const supportTrend = findBestTrendLine(pivotLows, true);
        if (supportTrend) {
          const { p1, p2, slope } = supportTrend;
          
          // Extender ligeramente hacia el futuro (3 velas)
          const lastCandle = state.candles[state.candles.length - 1];
          const candleInterval = state.candles.length > 1 ? 
            (lastCandle.time - state.candles[state.candles.length - 2].time) : 60;
          const futureTime = lastCandle.time + candleInterval * 3;
          const futureValue = p1.value + slope * (futureTime - p1.time);
          
          try {
            trendLineUp.setData([
              { time: p1.time, value: p1.value },
              { time: p2.time, value: p2.value },
              { time: futureTime, value: futureValue }
            ]);
          } catch (e) {}
        }
      } else if (trendLineUp) {
        trendLineUp.setData([]);
      }
      
      // L√≠nea de resistencia (conectando m√°ximos)
      if (pivotHighs.length >= 2 && trendLineDown) {
        const resistanceTrend = findBestTrendLine(pivotHighs, false);
        if (resistanceTrend) {
          const { p1, p2, slope } = resistanceTrend;
          
          // Extender ligeramente hacia el futuro (3 velas)
          const lastCandle = state.candles[state.candles.length - 1];
          const candleInterval = state.candles.length > 1 ? 
            (lastCandle.time - state.candles[state.candles.length - 2].time) : 60;
          const futureTime = lastCandle.time + candleInterval * 3;
          const futureValue = p1.value + slope * (futureTime - p1.time);
          
          try {
            trendLineDown.setData([
              { time: p1.time, value: p1.value },
              { time: p2.time, value: p2.value },
              { time: futureTime, value: futureValue }
            ]);
          } catch (e) {}
        }
      } else if (trendLineDown) {
        trendLineDown.setData([]);
      }
    }

    // ============================================
    // S/R LEVELS ON CHART
    // ============================================
    
    function updateSROnChart() {
      if (!state.candles || state.candles.length < 30) return;
      if (!supportLines || supportLines.length === 0) return;
      
      const supports = aiState.supportLevels || [];
      const resistances = aiState.resistanceLevels || [];
      
      const startTime = state.candles[0].time;
      const endTime = state.candles[state.candles.length - 1].time;
      
      // Dibujar soportes
      supports.slice(0, 3).forEach((s, i) => {
        if (supportLines[i]) {
          try {
            supportLines[i].setData([
              { time: startTime, value: s.price },
              { time: endTime, value: s.price }
            ]);
          } catch (e) {}
        }
      });
      
      // Limpiar l√≠neas no usadas
      for (let i = supports.length; i < 3; i++) {
        if (supportLines[i]) supportLines[i].setData([]);
      }
      
      // Dibujar resistencias
      resistances.slice(0, 3).forEach((r, i) => {
        if (resistanceLines[i]) {
          try {
            resistanceLines[i].setData([
              { time: startTime, value: r.price },
              { time: endTime, value: r.price }
            ]);
          } catch (e) {}
        }
      });
      
      // Limpiar l√≠neas no usadas
      for (let i = resistances.length; i < 3; i++) {
        if (resistanceLines[i]) resistanceLines[i].setData([]);
      }
    }

    // ============================================
    // FIBONACCI RETRACEMENT
    // ============================================
    
    function updateFibonacciLevels() {
      if (!state.candles || state.candles.length < 30) return;
      if (!fiboLines || fiboLines.length === 0) return;
      
      // Encontrar swing high y swing low en los √∫ltimos 50 candles
      const recentCandles = state.candles.slice(-50);
      const swingHigh = Math.max(...recentCandles.map(c => c.high));
      const swingLow = Math.min(...recentCandles.map(c => c.low));
      const range = swingHigh - swingLow;
      
      // Determinar direcci√≥n de la tendencia
      const closes = recentCandles.map(c => c.close);
      const firstHalf = closes.slice(0, 25).reduce((a,b) => a+b, 0) / 25;
      const secondHalf = closes.slice(25).reduce((a,b) => a+b, 0) / 25;
      const isUptrend = secondHalf > firstHalf;
      
      // Niveles Fibonacci: 0.236, 0.382, 0.5, 0.618, 0.786
      const fiboLevels = [0.236, 0.382, 0.5, 0.618, 0.786];
      const startTime = state.candles[0].time;
      const endTime = state.candles[state.candles.length - 1].time;
      
      fiboLevels.forEach((level, i) => {
        if (fiboLines[i]) {
          let price;
          if (isUptrend) {
            // En tendencia alcista, retrocesos desde el m√°ximo
            price = swingHigh - (range * level);
          } else {
            // En tendencia bajista, retrocesos desde el m√≠nimo
            price = swingLow + (range * level);
          }
          
          try {
            fiboLines[i].setData([
              { time: startTime, value: price },
              { time: endTime, value: price }
            ]);
          } catch (e) {}
        }
      });
      
      // Actualizar display de Fibonacci
      const fiboDisplay = document.getElementById('fiboLevels');
      if (fiboDisplay) {
        const currentPrice = state.currentPrice;
        const levels = fiboLevels.map((l, i) => {
          const price = isUptrend ? swingHigh - (range * l) : swingLow + (range * l);
          const diff = ((currentPrice - price) / price * 100).toFixed(2);
          const color = Math.abs(parseFloat(diff)) < 0.5 ? 'var(--accent-cyan)' : 'var(--text-dim)';
          return `<span style="color:${color}">${(l*100).toFixed(1)}%: ${price.toFixed(4)}</span>`;
        }).join(' | ');
        fiboDisplay.innerHTML = `<span style="color:var(--accent-yellow)">‚óÜ FIBO:</span> ${levels}`;
      }
    }

    // ============================================
    // SESSION DETECTOR
    // ============================================
    
    const tradingSessions = {
      asia: { name: 'ASIA', start: 0, end: 9, emoji: 'üåè', volatility: 'Low-Medium' },
      europe: { name: 'EUROPE', start: 7, end: 16, emoji: 'üåç', volatility: 'High' },
      us: { name: 'US', start: 13, end: 22, emoji: 'üåé', volatility: 'Very High' },
      overlap_eu_us: { name: 'EU/US OVERLAP', start: 13, end: 16, emoji: 'üî•', volatility: 'Maximum' }
    };
    
    function detectTradingSession() {
      const now = new Date();
      const utcHour = now.getUTCHours();
      
      let activeSessions = [];
      let sessionInfo = { name: 'OFF-HOURS', emoji: 'üåô', volatility: 'Low', color: 'var(--text-dim)' };
      
      // Detectar sesiones activas
      if (utcHour >= 0 && utcHour < 9) {
        activeSessions.push('asia');
      }
      if (utcHour >= 7 && utcHour < 16) {
        activeSessions.push('europe');
      }
      if (utcHour >= 13 && utcHour < 22) {
        activeSessions.push('us');
      }
      
      // Determinar sesi√≥n principal
      if (utcHour >= 13 && utcHour < 16) {
        sessionInfo = { 
          name: 'EU/US OVERLAP', 
          emoji: 'üî•', 
          volatility: 'Maximum',
          color: 'var(--accent-red)'
        };
      } else if (activeSessions.includes('us')) {
        sessionInfo = { 
          name: 'US SESSION', 
          emoji: 'üåé', 
          volatility: 'Very High',
          color: 'var(--accent-green)'
        };
      } else if (activeSessions.includes('europe')) {
        sessionInfo = { 
          name: 'EUROPE SESSION', 
          emoji: 'üåç', 
          volatility: 'High',
          color: 'var(--accent-cyan)'
        };
      } else if (activeSessions.includes('asia')) {
        sessionInfo = { 
          name: 'ASIA SESSION', 
          emoji: 'üåè', 
          volatility: 'Low-Medium',
          color: 'var(--accent-purple)'
        };
      }
      
      return sessionInfo;
    }
    
    function updateSessionDisplay() {
      const session = detectTradingSession();
      const sessionEl = document.getElementById('sessionDisplay');
      if (sessionEl) {
        sessionEl.innerHTML = `${session.emoji} <span style="color:${session.color}">${session.name}</span> <span style="font-size:9px; color:var(--text-dim)">Vol: ${session.volatility}</span>`;
      }
    }

    // ============================================
    // SIGNAL HISTORY LOG
    // ============================================
    
    const signalHistory = [];
    const MAX_SIGNAL_HISTORY = 50;
    
    function logSignal(type, probability, quality, price, regime) {
      const now = new Date();
      const signal = {
        time: now.toLocaleTimeString(),
        timestamp: now.getTime(),
        type, // 'BULL' or 'BEAR'
        probability,
        quality,
        price,
        regime,
        result: null // Se llena despu√©s
      };
      
      signalHistory.unshift(signal);
      if (signalHistory.length > MAX_SIGNAL_HISTORY) {
        signalHistory.pop();
      }
      
      updateSignalHistoryDisplay();
      return signal;
    }
    
    function updateSignalHistoryDisplay() {
      const container = document.getElementById('signalHistoryList');
      if (!container) return;
      
      if (signalHistory.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:var(--text-dim); padding:10px;">No signals yet...</div>';
        return;
      }
      
      container.innerHTML = signalHistory.slice(0, 10).map(s => {
        const color = s.type === 'BULL' ? 'var(--accent-green)' : 'var(--accent-red)';
        const arrow = s.type === 'BULL' ? '‚ñ≤' : '‚ñº';
        const resultIcon = s.result === true ? '‚úÖ' : s.result === false ? '‚ùå' : '‚è≥';
        
        return `
          <div style="display:flex; justify-content:space-between; align-items:center; padding:4px 6px; border-bottom:1px solid rgba(255,255,255,0.05); font-size:10px;">
            <span style="color:var(--text-dim)">${s.time}</span>
            <span style="color:${color}">${arrow} ${s.type}</span>
            <span>${s.probability.toFixed(0)}%</span>
            <span style="color:var(--accent-purple)">Q:${s.quality.toFixed(0)}</span>
            <span>${resultIcon}</span>
          </div>
        `;
      }).join('');
    }
    
    function verifySignalResults() {
      const currentPrice = state.currentPrice;
      const now = Date.now();
      
      signalHistory.forEach(s => {
        if (s.result === null) {
          const elapsed = now - s.timestamp;
          const priceChange = (currentPrice - s.price) / s.price * 100;
          
          // Verificaci√≥n en 3 etapas: 2min, 5min, 10min
          if (elapsed > 120000 && elapsed <= 300000) {
            if (s.type === 'BULL' && priceChange > 0.15) s.result = true;
            else if (s.type === 'BEAR' && priceChange < -0.15) s.result = true;
          } else if (elapsed > 300000 && elapsed <= 600000) {
            if (s.type === 'BULL') s.result = priceChange > 0.08;
            else s.result = priceChange < -0.08;
          } else if (elapsed > 600000) {
            if (s.type === 'BULL') s.result = priceChange > 0;
            else s.result = priceChange < 0;
          }
        }
      });
      
      updateSignalHistoryDisplay();
    }

    // ============================================
    // SCREENSHOT FUNCTION
    // ============================================
    
    async function captureScreenshot() {
      try {
        // Usar html2canvas si est√° disponible
        if (typeof html2canvas === 'undefined') {
          // Cargar html2canvas din√°micamente
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
          script.onload = () => doCapture();
          document.head.appendChild(script);
        } else {
          doCapture();
        }
      } catch (e) {
        addAlert('Screenshot failed: ' + e.message, 'warning');
      }
    }
    
    function doCapture() {
      const mainEl = document.querySelector('main');
      if (!mainEl) return;
      
      addAlert('üì∏ Capturing screenshot...', 'info');
      
      html2canvas(mainEl, {
        backgroundColor: '#02060c',
        scale: 2,
        logging: false,
        useCORS: true
      }).then(canvas => {
        // Crear link de descarga
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        link.download = `ORACULUM_${timestamp}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        addAlert('‚úÖ Screenshot saved!', 'bullish');
      }).catch(e => {
        addAlert('Screenshot error: ' + e.message, 'warning');
      });
    }

    // ============================================
    // TECHNICAL INDICATORS
    // ============================================

    function calcEMA(data, period) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i] * k + ema * (1 - k);
      }
      return ema;
    }

    function calcSMA(data, period) {
      if (data.length < period) return null;
      return data.slice(-period).reduce((a, b) => a + b, 0) / period;
    }

    function calcRSI(closes, period = 14) {
      if (closes.length < period + 1) return null;
      let gains = 0, losses = 0;
      for (let i = closes.length - period; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      return 100 - (100 / (1 + avgGain / avgLoss));
    }

    function calcMACD(closes) {
      const emaFast = calcEMA(closes, CONFIG.MACD_FAST);
      const emaSlow = calcEMA(closes, CONFIG.MACD_SLOW);
      if (!emaFast || !emaSlow) return { macd: null, signal: null, histogram: null };
      const macdLine = emaFast - emaSlow;
      const macdHistory = [];
      for (let i = CONFIG.MACD_SLOW; i <= closes.length; i++) {
        const fast = calcEMA(closes.slice(0, i), CONFIG.MACD_FAST);
        const slow = calcEMA(closes.slice(0, i), CONFIG.MACD_SLOW);
        if (fast && slow) macdHistory.push(fast - slow);
      }
      const signalLine = calcEMA(macdHistory, CONFIG.MACD_SIGNAL) || 0;
      return { macd: macdLine, signal: signalLine, histogram: macdLine - signalLine };
    }

    function calcStochRSI(closes, period = 14) {
      if (closes.length < period * 2) return null;
      const rsiValues = [];
      for (let i = period + 1; i <= closes.length; i++) {
        const rsi = calcRSI(closes.slice(0, i), period);
        if (rsi !== null) rsiValues.push(rsi);
      }
      if (rsiValues.length < period) return null;
      const recentRSI = rsiValues.slice(-period);
      const minRSI = Math.min(...recentRSI);
      const maxRSI = Math.max(...recentRSI);
      if (maxRSI === minRSI) return 50;
      return ((rsiValues[rsiValues.length - 1] - minRSI) / (maxRSI - minRSI)) * 100;
    }

    function calcWilliamsR(candles, period = 14) {
      if (candles.length < period) return null;
      const recent = candles.slice(-period);
      const highestHigh = Math.max(...recent.map(c => c.high));
      const lowestLow = Math.min(...recent.map(c => c.low));
      const currentClose = candles[candles.length - 1].close;
      if (highestHigh === lowestLow) return -50;
      return ((highestHigh - currentClose) / (highestHigh - lowestLow)) * -100;
    }

    function calcBollingerBands(closes, period = 20, stdDev = 2) {
      if (closes.length < period) return null;
      const sma = calcSMA(closes, period);
      const slice = closes.slice(-period);
      const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period;
      const std = Math.sqrt(variance);
      return {
        upper: sma + (std * stdDev),
        middle: sma,
        lower: sma - (std * stdDev),
        bandwidth: ((sma + std * stdDev) - (sma - std * stdDev)) / sma * 100
      };
    }

    function calcATR(candles, period = 14) {
      if (candles.length < period + 1) return null;
      const trueRanges = [];
      for (let i = 1; i < candles.length; i++) {
        const tr = Math.max(
          candles[i].high - candles[i].low,
          Math.abs(candles[i].high - candles[i - 1].close),
          Math.abs(candles[i].low - candles[i - 1].close)
        );
        trueRanges.push(tr);
      }
      return calcSMA(trueRanges.slice(-period), period);
    }

    function calcADX(candles, period = 14) {
      if (candles.length < period * 2) return null;
      const plusDM = [], minusDM = [], tr = [];
      
      for (let i = 1; i < candles.length; i++) {
        const highDiff = candles[i].high - candles[i - 1].high;
        const lowDiff = candles[i - 1].low - candles[i].low;
        
        plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
        minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
        
        tr.push(Math.max(
          candles[i].high - candles[i].low,
          Math.abs(candles[i].high - candles[i - 1].close),
          Math.abs(candles[i].low - candles[i - 1].close)
        ));
      }
      
      const atr = calcSMA(tr.slice(-period), period);
      const plusDI = (calcSMA(plusDM.slice(-period), period) / atr) * 100;
      const minusDI = (calcSMA(minusDM.slice(-period), period) / atr) * 100;
      
      const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100;
      return { adx: dx, plusDI, minusDI };
    }

    function calcVWAP(candles) {
      if (candles.length < 1) return null;
      let cumVolPrice = 0, cumVol = 0;
      for (const c of candles) {
        const typical = (c.high + c.low + c.close) / 3;
        cumVolPrice += typical * (c.volume || 1);
        cumVol += (c.volume || 1);
      }
      return cumVolPrice / cumVol;
    }

    function calcOBV(candles) {
      if (candles.length < 2) return { obv: 0, trend: 'neutral' };
      let obv = 0;
      for (let i = 1; i < candles.length; i++) {
        if (candles[i].close > candles[i - 1].close) {
          obv += candles[i].volume || 1;
        } else if (candles[i].close < candles[i - 1].close) {
          obv -= candles[i].volume || 1;
        }
      }
      
      // Trend based on OBV EMA
      state.obvHistory.push(obv);
      if (state.obvHistory.length > 20) state.obvHistory.shift();
      
      const obvEma = calcEMA(state.obvHistory, 10);
      const trend = obv > obvEma ? 'bullish' : (obv < obvEma ? 'bearish' : 'neutral');
      
      return { obv, trend };
    }

    function calcMomentum(closes, period = 10) {
      if (closes.length < period + 1) return null;
      return ((closes[closes.length - 1] / closes[closes.length - period - 1]) - 1) * 100;
    }

    // ============================================
    // üî± GOD MODE - ADVANCED INDICATORS
    // ============================================
    
    // 1. ICHIMOKU CLOUD
    function calcIchimoku(candles) {
      if (candles.length < 52) return null;
      
      const highs = candles.map(c => c.high);
      const lows = candles.map(c => c.low);
      const closes = candles.map(c => c.close);
      
      // Tenkan-sen (Conversion Line): (9-period high + 9-period low) / 2
      const tenkan = (Math.max(...highs.slice(-9)) + Math.min(...lows.slice(-9))) / 2;
      
      // Kijun-sen (Base Line): (26-period high + 26-period low) / 2
      const kijun = (Math.max(...highs.slice(-26)) + Math.min(...lows.slice(-26))) / 2;
      
      // Senkou Span A (Leading Span A): (Tenkan + Kijun) / 2
      const senkouA = (tenkan + kijun) / 2;
      
      // Senkou Span B (Leading Span B): (52-period high + 52-period low) / 2
      const senkouB = (Math.max(...highs.slice(-52)) + Math.min(...lows.slice(-52))) / 2;
      
      // Chikou Span (Lagging Span): Current close plotted 26 periods back
      const chikou = closes[closes.length - 1];
      
      const currentPrice = closes[closes.length - 1];
      const cloudTop = Math.max(senkouA, senkouB);
      const cloudBottom = Math.min(senkouA, senkouB);
      
      // Signal determination
      let signal = 'neutral';
      let strength = 0;
      
      if (currentPrice > cloudTop && tenkan > kijun) {
        signal = 'bullish';
        strength = Math.min(100, ((currentPrice - cloudTop) / cloudTop) * 1000 + 50);
      } else if (currentPrice < cloudBottom && tenkan < kijun) {
        signal = 'bearish';
        strength = Math.min(100, ((cloudBottom - currentPrice) / cloudBottom) * 1000 + 50);
      } else if (currentPrice > cloudBottom && currentPrice < cloudTop) {
        signal = 'neutral'; // In the cloud
        strength = 30;
      }
      
      return { tenkan, kijun, senkouA, senkouB, chikou, cloudTop, cloudBottom, signal, strength };
    }
    
    // 2. SUPERTREND
    function calcSupertrend(candles, period = 10, multiplier = 3) {
      if (candles.length < period + 1) return null;
      
      const atr = calcATR(candles, period);
      if (!atr) return null;
      
      const currentCandle = candles[candles.length - 1];
      const hl2 = (currentCandle.high + currentCandle.low) / 2;
      
      const upperBand = hl2 + (multiplier * atr);
      const lowerBand = hl2 - (multiplier * atr);
      
      // Simplified trend detection
      const closes = candles.map(c => c.close);
      const recentCloses = closes.slice(-period);
      const trend = currentCandle.close > hl2 ? 'bullish' : 'bearish';
      
      return {
        upperBand,
        lowerBand,
        trend,
        value: trend === 'bullish' ? lowerBand : upperBand
      };
    }
    
    // 3. SQUEEZE MOMENTUM (Bollinger + Keltner)
    function calcSqueezeMomentum(candles) {
      if (candles.length < 20) return null;
      
      const closes = candles.map(c => c.close);
      const bb = calcBollingerBands(closes, 20, 2);
      const atr = calcATR(candles, 20);
      
      if (!bb || !atr) return null;
      
      const sma = bb.middle;
      const keltnerUpper = sma + (1.5 * atr);
      const keltnerLower = sma - (1.5 * atr);
      
      // Squeeze is on when BB is inside Keltner
      const squeezeOn = bb.lower > keltnerLower && bb.upper < keltnerUpper;
      
      // Momentum using linear regression
      const momLength = 12;
      if (closes.length < momLength) return { squeezeOn, momentum: 0, signal: 'neutral' };
      
      const recentCloses = closes.slice(-momLength);
      const midline = (Math.max(...recentCloses) + Math.min(...recentCloses)) / 2;
      const momentum = closes[closes.length - 1] - midline;
      
      let signal = 'neutral';
      if (momentum > 0) signal = squeezeOn ? 'buildup_bull' : 'bullish';
      else if (momentum < 0) signal = squeezeOn ? 'buildup_bear' : 'bearish';
      
      return { squeezeOn, momentum, signal };
    }
    
    // 4. CHAIKIN MONEY FLOW
    function calcCMF(candles, period = 20) {
      if (candles.length < period) return null;
      
      let mfvSum = 0;
      let volSum = 0;
      
      const recent = candles.slice(-period);
      
      for (const c of recent) {
        const range = c.high - c.low;
        if (range === 0) continue;
        
        const mfm = ((c.close - c.low) - (c.high - c.close)) / range;
        const mfv = mfm * c.volume;
        
        mfvSum += mfv;
        volSum += c.volume;
      }
      
      if (volSum === 0) return 0;
      return mfvSum / volSum;
    }
    
    // 5. VOLUME PROFILE (POC - Point of Control)
    function calcVolumeProfile(candles, bins = 20) {
      if (candles.length < 50) return null;
      
      const prices = candles.map(c => (c.high + c.low) / 2);
      const volumes = candles.map(c => c.volume);
      
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const binSize = (maxPrice - minPrice) / bins;
      
      const volumeByPrice = new Array(bins).fill(0);
      
      for (let i = 0; i < prices.length; i++) {
        const binIndex = Math.min(bins - 1, Math.floor((prices[i] - minPrice) / binSize));
        volumeByPrice[binIndex] += volumes[i];
      }
      
      // Find POC (Point of Control) - price level with most volume
      let maxVol = 0;
      let pocIndex = 0;
      for (let i = 0; i < volumeByPrice.length; i++) {
        if (volumeByPrice[i] > maxVol) {
          maxVol = volumeByPrice[i];
          pocIndex = i;
        }
      }
      
      const poc = minPrice + (pocIndex + 0.5) * binSize;
      const currentPrice = candles[candles.length - 1].close;
      
      // Value Area (70% of volume)
      const totalVol = volumeByPrice.reduce((a, b) => a + b, 0);
      let vaVol = volumeByPrice[pocIndex];
      let vaHigh = pocIndex;
      let vaLow = pocIndex;
      
      while (vaVol < totalVol * 0.7 && (vaHigh < bins - 1 || vaLow > 0)) {
        const upVol = vaHigh < bins - 1 ? volumeByPrice[vaHigh + 1] : 0;
        const downVol = vaLow > 0 ? volumeByPrice[vaLow - 1] : 0;
        
        if (upVol > downVol && vaHigh < bins - 1) {
          vaHigh++;
          vaVol += volumeByPrice[vaHigh];
        } else if (vaLow > 0) {
          vaLow--;
          vaVol += volumeByPrice[vaLow];
        }
      }
      
      return {
        poc,
        vah: minPrice + (vaHigh + 1) * binSize,
        val: minPrice + vaLow * binSize,
        currentVsProfile: currentPrice > poc ? 'above_poc' : 'below_poc'
      };
    }
    
    // 6. ORDER FLOW IMBALANCE
    function calcOrderFlowImbalance(candles) {
      if (candles.length < 10) return null;
      
      const recent = candles.slice(-10);
      let buyPressure = 0;
      let sellPressure = 0;
      
      for (const c of recent) {
        const range = c.high - c.low;
        if (range === 0) continue;
        
        // Estimate buy/sell pressure from candle structure
        const buyRatio = (c.close - c.low) / range;
        const sellRatio = (c.high - c.close) / range;
        
        buyPressure += buyRatio * c.volume;
        sellPressure += sellRatio * c.volume;
      }
      
      const total = buyPressure + sellPressure;
      if (total === 0) return { imbalance: 0, signal: 'neutral' };
      
      const imbalance = ((buyPressure - sellPressure) / total) * 100;
      
      let signal = 'neutral';
      if (imbalance > 20) signal = 'bullish';
      else if (imbalance < -20) signal = 'bearish';
      
      return { imbalance, buyPressure, sellPressure, signal };
    }
    
    // 7. MARKET STRUCTURE (Higher Highs, Lower Lows)
    function calcMarketStructure(candles) {
      if (candles.length < 30) return null;
      
      const swings = [];
      const lookback = 5;
      
      // Find swing highs and lows
      for (let i = lookback; i < candles.length - lookback; i++) {
        let isSwingHigh = true;
        let isSwingLow = true;
        
        for (let j = i - lookback; j <= i + lookback; j++) {
          if (j === i) continue;
          if (candles[j].high >= candles[i].high) isSwingHigh = false;
          if (candles[j].low <= candles[i].low) isSwingLow = false;
        }
        
        if (isSwingHigh) swings.push({ type: 'high', price: candles[i].high, index: i });
        if (isSwingLow) swings.push({ type: 'low', price: candles[i].low, index: i });
      }
      
      // Analyze structure
      const recentSwings = swings.slice(-6);
      const highs = recentSwings.filter(s => s.type === 'high');
      const lows = recentSwings.filter(s => s.type === 'low');
      
      let structure = 'ranging';
      
      if (highs.length >= 2 && lows.length >= 2) {
        const hh = highs[highs.length - 1]?.price > highs[highs.length - 2]?.price;
        const hl = lows[lows.length - 1]?.price > lows[lows.length - 2]?.price;
        const lh = highs[highs.length - 1]?.price < highs[highs.length - 2]?.price;
        const ll = lows[lows.length - 1]?.price < lows[lows.length - 2]?.price;
        
        if (hh && hl) structure = 'uptrend';
        else if (lh && ll) structure = 'downtrend';
        else if (hh && ll) structure = 'expanding';
        else if (lh && hl) structure = 'contracting';
      }
      
      return { structure, swings: recentSwings, highs, lows };
    }
    
    // 8. SMART MONEY CONCEPTS
    function calcSmartMoneyConcepts(candles) {
      if (candles.length < 30) return { orderBlocks: [], fvg: [], liquidity: [] };
      
      const orderBlocks = [];
      const fvg = []; // Fair Value Gaps
      const liquidity = [];
      
      // Detect Order Blocks (last opposing candle before strong move)
      for (let i = 3; i < candles.length - 1; i++) {
        const c = candles[i];
        const prev = candles[i - 1];
        const next = candles[i + 1];
        
        const cBody = Math.abs(c.close - c.open);
        const cRange = c.high - c.low;
        const prevBody = Math.abs(prev.close - prev.open);
        const nextBody = Math.abs(next.close - next.open);
        
        // Bullish Order Block: bearish candle followed by strong bullish move
        if (prev.close < prev.open && c.close > c.open && cBody > prevBody * 2) {
          orderBlocks.push({
            type: 'bullish',
            high: prev.high,
            low: prev.low,
            index: i - 1
          });
        }
        
        // Bearish Order Block: bullish candle followed by strong bearish move
        if (prev.close > prev.open && c.close < c.open && cBody > prevBody * 2) {
          orderBlocks.push({
            type: 'bearish',
            high: prev.high,
            low: prev.low,
            index: i - 1
          });
        }
        
        // Fair Value Gap (FVG)
        if (i >= 2) {
          const c1 = candles[i - 2];
          const c2 = candles[i - 1];
          const c3 = candles[i];
          
          // Bullish FVG: gap between c1 high and c3 low
          if (c3.low > c1.high) {
            fvg.push({
              type: 'bullish',
              top: c3.low,
              bottom: c1.high,
              index: i
            });
          }
          
          // Bearish FVG: gap between c1 low and c3 high
          if (c3.high < c1.low) {
            fvg.push({
              type: 'bearish',
              top: c1.low,
              bottom: c3.high,
              index: i
            });
          }
        }
      }
      
      // Detect Liquidity zones (equal highs/lows)
      const tolerance = 0.001; // 0.1%
      const highs = candles.slice(-20).map((c, i) => ({ price: c.high, index: i }));
      const lows = candles.slice(-20).map((c, i) => ({ price: c.low, index: i }));
      
      // Find equal highs (potential sell-side liquidity)
      for (let i = 0; i < highs.length - 1; i++) {
        for (let j = i + 1; j < highs.length; j++) {
          if (Math.abs(highs[i].price - highs[j].price) / highs[i].price < tolerance) {
            liquidity.push({
              type: 'sell_side',
              price: (highs[i].price + highs[j].price) / 2
            });
          }
        }
      }
      
      // Find equal lows (potential buy-side liquidity)
      for (let i = 0; i < lows.length - 1; i++) {
        for (let j = i + 1; j < lows.length; j++) {
          if (Math.abs(lows[i].price - lows[j].price) / lows[i].price < tolerance) {
            liquidity.push({
              type: 'buy_side',
              price: (lows[i].price + lows[j].price) / 2
            });
          }
        }
      }
      
      return { 
        orderBlocks: orderBlocks.slice(-3), 
        fvg: fvg.slice(-3), 
        liquidity: liquidity.slice(-5),
        nearestOB: orderBlocks[orderBlocks.length - 1] || null,
        nearestFVG: fvg[fvg.length - 1] || null
      };
    }
    
    // 9. FIBONACCI LEVELS (Automatic)
    function calcAutoFibonacci(candles, lookback = 50) {
      if (candles.length < lookback) return null;
      
      const recent = candles.slice(-lookback);
      const high = Math.max(...recent.map(c => c.high));
      const low = Math.min(...recent.map(c => c.low));
      const diff = high - low;
      
      const currentPrice = candles[candles.length - 1].close;
      
      // Determine trend direction for Fib
      const firstHalf = recent.slice(0, lookback / 2);
      const secondHalf = recent.slice(lookback / 2);
      const firstAvg = firstHalf.reduce((a, c) => a + c.close, 0) / firstHalf.length;
      const secondAvg = secondHalf.reduce((a, c) => a + c.close, 0) / secondHalf.length;
      const isUptrend = secondAvg > firstAvg;
      
      const levels = isUptrend ? {
        // Retracement from low to high (uptrend)
        fib0: low,
        fib236: low + diff * 0.236,
        fib382: low + diff * 0.382,
        fib5: low + diff * 0.5,
        fib618: low + diff * 0.618,
        fib786: low + diff * 0.786,
        fib1: high
      } : {
        // Retracement from high to low (downtrend)
        fib0: high,
        fib236: high - diff * 0.236,
        fib382: high - diff * 0.382,
        fib5: high - diff * 0.5,
        fib618: high - diff * 0.618,
        fib786: high - diff * 0.786,
        fib1: low
      };
      
      // Find nearest Fib level
      const fibLevels = [
        { name: '0%', price: levels.fib0 },
        { name: '23.6%', price: levels.fib236 },
        { name: '38.2%', price: levels.fib382 },
        { name: '50%', price: levels.fib5 },
        { name: '61.8%', price: levels.fib618 },
        { name: '78.6%', price: levels.fib786 },
        { name: '100%', price: levels.fib1 }
      ];
      
      let nearest = fibLevels[0];
      let minDist = Math.abs(currentPrice - fibLevels[0].price);
      
      for (const level of fibLevels) {
        const dist = Math.abs(currentPrice - level.price);
        if (dist < minDist) {
          minDist = dist;
          nearest = level;
        }
      }
      
      return { levels, nearest, isUptrend, high, low };
    }
    
    // 10. MULTI-TIMEFRAME STATE
    const mtfState = {
      tf1m: { signal: 'neutral', strength: 0 },
      tf5m: { signal: 'neutral', strength: 0 },
      tf15m: { signal: 'neutral', strength: 0 },
      tf1h: { signal: 'neutral', strength: 0 },
      confluence: 0,
      lastUpdate: 0
    };
    
    // Simulate higher timeframe analysis from 1m data
    function analyzeMultiTimeframe(candles1m) {
      if (candles1m.length < 60) return mtfState;
      
      // Aggregate to higher timeframes
      const aggregate = (srcCandles, factor) => {
        const result = [];
        for (let i = 0; i < srcCandles.length; i += factor) {
          const chunk = srcCandles.slice(i, i + factor);
          if (chunk.length < factor) break;
          result.push({
            open: chunk[0].open,
            high: Math.max(...chunk.map(c => c.high)),
            low: Math.min(...chunk.map(c => c.low)),
            close: chunk[chunk.length - 1].close,
            volume: chunk.reduce((a, c) => a + c.volume, 0)
          });
        }
        return result;
      };
      
      const candles5m = aggregate(candles1m, 5);
      const candles15m = aggregate(candles1m, 15);
      const candles1h = aggregate(candles1m, 60);
      
      // Analyze each timeframe
      const analyzeTF = (candles) => {
        if (candles.length < 20) return { signal: 'neutral', strength: 0 };
        
        const closes = candles.map(c => c.close);
        const ema9 = calcEMA(closes, Math.min(9, closes.length));
        const ema21 = calcEMA(closes, Math.min(21, closes.length));
        const rsi = calcRSI(closes, 14);
        const currentPrice = closes[closes.length - 1];
        
        let bullPoints = 0;
        let bearPoints = 0;
        
        if (ema9 && ema21) {
          if (ema9 > ema21) bullPoints += 2;
          else bearPoints += 2;
        }
        
        if (currentPrice > ema9) bullPoints += 1;
        else bearPoints += 1;
        
        if (rsi !== null) {
          if (rsi > 50) bullPoints += 1;
          else bearPoints += 1;
          if (rsi > 70) bearPoints += 1; // Overbought
          if (rsi < 30) bullPoints += 1; // Oversold
        }
        
        const totalPoints = bullPoints + bearPoints;
        if (bullPoints > bearPoints) {
          return { signal: 'bullish', strength: Math.round((bullPoints / totalPoints) * 100) };
        } else if (bearPoints > bullPoints) {
          return { signal: 'bearish', strength: Math.round((bearPoints / totalPoints) * 100) };
        }
        return { signal: 'neutral', strength: 50 };
      };
      
      mtfState.tf1m = analyzeTF(candles1m.slice(-50));
      mtfState.tf5m = analyzeTF(candles5m);
      mtfState.tf15m = analyzeTF(candles15m);
      mtfState.tf1h = analyzeTF(candles1h);
      
      // Calculate confluence
      let confluence = 0;
      const signals = [mtfState.tf1m, mtfState.tf5m, mtfState.tf15m, mtfState.tf1h];
      const bullishCount = signals.filter(s => s.signal === 'bullish').length;
      const bearishCount = signals.filter(s => s.signal === 'bearish').length;
      
      mtfState.confluence = Math.max(bullishCount, bearishCount);
      mtfState.dominantSignal = bullishCount > bearishCount ? 'bullish' : (bearishCount > bullishCount ? 'bearish' : 'neutral');
      mtfState.lastUpdate = Date.now();
      
      return mtfState;
    }
    
    // 11. TRADING SIGNAL GENERATOR (Entry/SL/TP)
    function generateTradingSignal(currentPrice, atr, probability, regime, indicators) {
      const minProbability = 62;
      const minConfluence = 4;
      
      if (!atr || probability < minProbability) {
        return null;
      }
      
      const isBullish = probability >= 50 && (regime === 'trending_up' || regime === 'ranging');
      const direction = isBullish ? 'LONG' : 'SHORT';
      
      // ATR-based stops and targets (din√°micos seg√∫n r√©gimen)
      let atrMultiplierSL, atrMultiplierTP1, atrMultiplierTP2;
      
      if (regime === 'volatile') {
        atrMultiplierSL = 2.0;
        atrMultiplierTP1 = 1.8;
        atrMultiplierTP2 = 3.0;
      } else if (regime === 'trending_up' || regime === 'trending_down') {
        atrMultiplierSL = 1.3;
        atrMultiplierTP1 = 2.2;
        atrMultiplierTP2 = 4.0;
      } else {
        atrMultiplierSL = 1.5;
        atrMultiplierTP1 = 1.8;
        atrMultiplierTP2 = 2.8;
      }
      
      let entry, stopLoss, tp1, tp2;
      
      if (direction === 'LONG') {
        entry = currentPrice;
        stopLoss = currentPrice - (atr * atrMultiplierSL);
        tp1 = currentPrice + (atr * atrMultiplierTP1);
        tp2 = currentPrice + (atr * atrMultiplierTP2);
      } else {
        entry = currentPrice;
        stopLoss = currentPrice + (atr * atrMultiplierSL);
        tp1 = currentPrice - (atr * atrMultiplierTP1);
        tp2 = currentPrice - (atr * atrMultiplierTP2);
      }
      
      const risk = Math.abs(entry - stopLoss) / entry * 100;
      const reward = Math.abs(tp1 - entry) / entry * 100;
      const riskReward = reward / risk;
      
      const baseWinRate = probability * 0.55;
      const confluenceBonus = indicators.confluence * 2.5;
      const regimeBonus = (regime === 'trending_up' || regime === 'trending_down') ? 5 : 0;
      const estimatedWinRate = Math.min(78, baseWinRate + confluenceBonus + regimeBonus);
      
      return {
        direction,
        entry,
        stopLoss,
        tp1,
        tp2,
        risk,
        reward,
        riskReward,
        estimatedWinRate,
        probability,
        regime,
        timestamp: Date.now()
      };
    }
    
    // 12. WHALE IMPACT CALCULATOR
    function calculateWhaleImpact() {
      if (!state.whaleTransactions || state.whaleTransactions.length === 0) return 0;
      
      const recentWhales = state.whaleTransactions.filter(w => 
        Date.now() - new Date(w.time).getTime() < 300000 // Last 5 minutes
      );
      
      let buyVolume = 0;
      let sellVolume = 0;
      
      for (const whale of recentWhales) {
        const amount = parseFloat(whale.amount) || 0;
        if (whale.type === 'BUY') buyVolume += amount;
        else sellVolume += amount;
      }
      
      const totalVolume = buyVolume + sellVolume;
      if (totalVolume === 0) return 0;
      
      // Impact score: -100 (all sell) to +100 (all buy)
      return Math.round(((buyVolume - sellVolume) / totalVolume) * 100);
    }
    
    // 13. ADAPTIVE INDICATOR WEIGHTS
    const indicatorWeights = {
      rsi: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      macd: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      ema: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      bb: { weight: 1.0, accuracy: 0.5, hits: 0, misses: 0 },
      ichimoku: { weight: 1.2, accuracy: 0.5, hits: 0, misses: 0 },
      structure: { weight: 1.3, accuracy: 0.5, hits: 0, misses: 0 },
      mtf: { weight: 1.5, accuracy: 0.5, hits: 0, misses: 0 },
      whale: { weight: 1.1, accuracy: 0.5, hits: 0, misses: 0 }
    };
    
    function updateIndicatorWeight(indicator, wasCorrect) {
      if (!indicatorWeights[indicator]) return;
      
      if (wasCorrect) {
        indicatorWeights[indicator].hits++;
      } else {
        indicatorWeights[indicator].misses++;
      }
      
      const total = indicatorWeights[indicator].hits + indicatorWeights[indicator].misses;
      if (total > 0) {
        indicatorWeights[indicator].accuracy = indicatorWeights[indicator].hits / total;
        // Adjust weight based on accuracy (0.5 to 2.0 range)
        indicatorWeights[indicator].weight = 0.5 + (indicatorWeights[indicator].accuracy * 1.5);
      }
    }

    function detectRSIDivergence(prices, rsiValues) {
      if (prices.length < 20 || rsiValues.length < 20) return null;
      
      const recentPrices = prices.slice(-20);
      const recentRSI = rsiValues.slice(-20);
      
      // Find local highs and lows in last 20 periods
      let priceHigh1 = -Infinity, priceHigh2 = -Infinity;
      let priceLow1 = Infinity, priceLow2 = Infinity;
      let rsiHigh1 = -Infinity, rsiHigh2 = -Infinity;
      let rsiLow1 = Infinity, rsiLow2 = Infinity;
      
      const mid = Math.floor(recentPrices.length / 2);
      
      for (let i = 0; i < mid; i++) {
        if (recentPrices[i] > priceHigh1) priceHigh1 = recentPrices[i];
        if (recentPrices[i] < priceLow1) priceLow1 = recentPrices[i];
        if (recentRSI[i] > rsiHigh1) rsiHigh1 = recentRSI[i];
        if (recentRSI[i] < rsiLow1) rsiLow1 = recentRSI[i];
      }
      
      for (let i = mid; i < recentPrices.length; i++) {
        if (recentPrices[i] > priceHigh2) priceHigh2 = recentPrices[i];
        if (recentPrices[i] < priceLow2) priceLow2 = recentPrices[i];
        if (recentRSI[i] > rsiHigh2) rsiHigh2 = recentRSI[i];
        if (recentRSI[i] < rsiLow2) rsiLow2 = recentRSI[i];
      }
      
      // Bullish divergence: price makes lower low, RSI makes higher low
      if (priceLow2 < priceLow1 && rsiLow2 > rsiLow1) {
        return 'bullish';
      }
      
      // Bearish divergence: price makes higher high, RSI makes lower high
      if (priceHigh2 > priceHigh1 && rsiHigh2 < rsiHigh1) {
        return 'bearish';
      }
      
      return null;
    }

    // ============================================
    // CANDLE PATTERN DETECTION
    // ============================================

    function detectCandlePatterns(candles) {
      if (candles.length < 5) return [];
      const patterns = [];
      
      const c = candles[candles.length - 1];      // Current
      const prev = candles[candles.length - 2];   // Previous
      const prev2 = candles[candles.length - 3];  // 2 candles ago
      const prev3 = candles[candles.length - 4];  // 3 candles ago
      
      const body = Math.abs(c.close - c.open);
      const upperWick = c.high - Math.max(c.open, c.close);
      const lowerWick = Math.min(c.open, c.close) - c.low;
      const range = c.high - c.low;
      const isBullish = c.close > c.open;
      const isBearish = c.close < c.open;
      
      const prevBody = Math.abs(prev.close - prev.open);
      const prevRange = prev.high - prev.low;
      
      // Evitar divisi√≥n por cero
      if (range === 0 || body === 0) return patterns;
      
      // --- SINGLE CANDLE PATTERNS ---
      
      // Doji (cuerpo muy peque√±o)
      if (body < range * 0.15 && range > 0) {
        if (upperWick > body * 1.5 && lowerWick > body * 1.5) {
          patterns.push({ name: 'DOJI', type: 'neutral' });
        } else if (upperWick > lowerWick * 2) {
          patterns.push({ name: 'GRAVESTONE', type: 'bearish' });
        } else if (lowerWick > upperWick * 2) {
          patterns.push({ name: 'DRAGONFLY', type: 'bullish' });
        }
      }
      
      // Hammer (bullish reversal) - mecha inferior larga
      if (lowerWick > body * 1.5 && upperWick < body * 0.8 && isBullish) {
        patterns.push({ name: 'HAMMER', type: 'bullish' });
      }
      
      // Inverted Hammer
      if (upperWick > body * 1.5 && lowerWick < body * 0.8 && isBullish) {
        patterns.push({ name: 'INV HAMMER', type: 'bullish' });
      }
      
      // Shooting Star (bearish reversal) - mecha superior larga
      if (upperWick > body * 1.5 && lowerWick < body * 0.8 && isBearish) {
        patterns.push({ name: 'SHOOTING STAR', type: 'bearish' });
      }
      
      // Hanging Man
      if (lowerWick > body * 1.5 && upperWick < body * 0.8 && isBearish) {
        patterns.push({ name: 'HANGING MAN', type: 'bearish' });
      }
      
      // Marubozu (vela de cuerpo completo sin mechas)
      if (body > range * 0.85) {
        if (isBullish) {
          patterns.push({ name: 'BULL MARUBOZU', type: 'bullish' });
        } else {
          patterns.push({ name: 'BEAR MARUBOZU', type: 'bearish' });
        }
      }
      
      // Spinning Top (cuerpo peque√±o, mechas similares)
      if (body < range * 0.3 && Math.abs(upperWick - lowerWick) < range * 0.2) {
        patterns.push({ name: 'SPINNING TOP', type: 'neutral' });
      }
      
      // --- TWO CANDLE PATTERNS ---
      
      // Bullish Engulfing
      if (prev.close < prev.open && isBullish && 
          c.open <= prev.close && c.close >= prev.open &&
          body > prevBody) {
        patterns.push({ name: 'BULL ENGULF', type: 'bullish' });
      }
      
      // Bearish Engulfing
      if (prev.close > prev.open && isBearish && 
          c.open >= prev.close && c.close <= prev.open &&
          body > prevBody) {
        patterns.push({ name: 'BEAR ENGULF', type: 'bearish' });
      }
      
      // Piercing Line (bullish)
      if (prev.close < prev.open && isBullish &&
          c.open < prev.low && c.close > (prev.open + prev.close) / 2) {
        patterns.push({ name: 'PIERCING', type: 'bullish' });
      }
      
      // Dark Cloud Cover (bearish)
      if (prev.close > prev.open && isBearish &&
          c.open > prev.high && c.close < (prev.open + prev.close) / 2) {
        patterns.push({ name: 'DARK CLOUD', type: 'bearish' });
      }
      
      // Tweezer Bottom (bullish)
      if (Math.abs(c.low - prev.low) < range * 0.1 && isBullish && prev.close < prev.open) {
        patterns.push({ name: 'TWEEZER BTM', type: 'bullish' });
      }
      
      // Tweezer Top (bearish)
      if (Math.abs(c.high - prev.high) < range * 0.1 && isBearish && prev.close > prev.open) {
        patterns.push({ name: 'TWEEZER TOP', type: 'bearish' });
      }
      
      // --- THREE CANDLE PATTERNS ---
      
      // Morning Star (bullish reversal)
      if (prev2.close < prev2.open &&  // First: bearish
          Math.abs(prev.close - prev.open) < prevRange * 0.4 && // Second: small body
          isBullish && c.close > (prev2.open + prev2.close) / 2) { // Third: bullish
        patterns.push({ name: 'MORNING STAR', type: 'bullish' });
      }
      
      // Evening Star (bearish reversal)
      if (prev2.close > prev2.open && 
          Math.abs(prev.close - prev.open) < prevRange * 0.4 &&
          isBearish && c.close < (prev2.open + prev2.close) / 2) {
        patterns.push({ name: 'EVENING STAR', type: 'bearish' });
      }
      
      // Three White Soldiers (bullish)
      if (prev2.close > prev2.open && prev.close > prev.open && isBullish &&
          prev.close > prev2.close && c.close > prev.close) {
        patterns.push({ name: '3 WHITE SOLD', type: 'bullish' });
      }
      
      // Three Black Crows (bearish)
      if (prev2.close < prev2.open && prev.close < prev.open && isBearish &&
          prev.close < prev2.close && c.close < prev.close) {
        patterns.push({ name: '3 BLACK CROW', type: 'bearish' });
      }
      
      // --- TREND PATTERNS ---
      
      // Strong momentum up (3+ consecutive green candles)
      const lastFive = candles.slice(-5);
      const greenCount = lastFive.filter(c => c.close > c.open).length;
      const redCount = lastFive.filter(c => c.close < c.open).length;
      
      if (greenCount >= 4) {
        patterns.push({ name: 'STRONG UP', type: 'bullish' });
      } else if (redCount >= 4) {
        patterns.push({ name: 'STRONG DOWN', type: 'bearish' });
      }
      
      // Higher highs and higher lows (uptrend)
      if (c.high > prev.high && c.low > prev.low && prev.high > prev2.high) {
        patterns.push({ name: 'UPTREND', type: 'bullish' });
      }
      
      // Lower highs and lower lows (downtrend)
      if (c.high < prev.high && c.low < prev.low && prev.high < prev2.high) {
        patterns.push({ name: 'DOWNTREND', type: 'bearish' });
      }
      
      // --- üî± GOD MODE ADVANCED PATTERNS ---
      
      // Double Bottom Detection (bullish reversal)
      if (candles.length >= 20) {
        const recent20 = candles.slice(-20);
        const lows = recent20.map(c => c.low);
        const minLow = Math.min(...lows);
        const lowIndices = lows.map((l, i) => ({ low: l, index: i }))
                               .filter(x => Math.abs(x.low - minLow) / minLow < 0.005);
        if (lowIndices.length >= 2 && lowIndices[lowIndices.length - 1].index - lowIndices[0].index >= 5) {
          patterns.push({ name: 'DOUBLE BTM', type: 'bullish' });
        }
        
        // Double Top Detection (bearish reversal)
        const highs = recent20.map(c => c.high);
        const maxHigh = Math.max(...highs);
        const highIndices = highs.map((h, i) => ({ high: h, index: i }))
                                 .filter(x => Math.abs(x.high - maxHigh) / maxHigh < 0.005);
        if (highIndices.length >= 2 && highIndices[highIndices.length - 1].index - highIndices[0].index >= 5) {
          patterns.push({ name: 'DOUBLE TOP', type: 'bearish' });
        }
      }
      
      // Bull Flag (consolidation after strong move up)
      if (candles.length >= 15) {
        const recent15 = candles.slice(-15);
        const first5 = recent15.slice(0, 5);
        const last5 = recent15.slice(-5);
        
        const strongMove = first5.every(c => c.close > c.open);
        const consolidation = last5.every(c => Math.abs(c.close - c.open) < (c.high - c.low) * 0.5);
        const lowerHighs = last5[4].high < last5[0].high;
        
        if (strongMove && consolidation && lowerHighs) {
          patterns.push({ name: 'BULL FLAG', type: 'bullish' });
        }
        
        // Bear Flag
        const strongDown = first5.every(c => c.close < c.open);
        const higherLows = last5[4].low > last5[0].low;
        
        if (strongDown && consolidation && higherLows) {
          patterns.push({ name: 'BEAR FLAG', type: 'bearish' });
        }
      }
      
      // Ascending Triangle (bullish)
      if (candles.length >= 12) {
        const recent12 = candles.slice(-12);
        const highs12 = recent12.map(c => c.high);
        const lows12 = recent12.map(c => c.low);
        
        const flatTop = Math.max(...highs12) - Math.min(...highs12.slice(-6)) < range * 0.5;
        const risingBottom = lows12[11] > lows12[0] && lows12[8] > lows12[3];
        
        if (flatTop && risingBottom) {
          patterns.push({ name: 'ASC TRIANGLE', type: 'bullish' });
        }
        
        // Descending Triangle (bearish)
        const flatBottom = Math.max(...lows12.slice(-6)) - Math.min(...lows12) < range * 0.5;
        const fallingTop = highs12[11] < highs12[0] && highs12[8] < highs12[3];
        
        if (flatBottom && fallingTop) {
          patterns.push({ name: 'DESC TRIANGLE', type: 'bearish' });
        }
      }
      
      // Cup and Handle (bullish)
      if (candles.length >= 30) {
        const recent30 = candles.slice(-30);
        const midPoint = Math.floor(recent30.length / 2);
        const leftSide = recent30.slice(0, midPoint);
        const rightSide = recent30.slice(midPoint);
        
        const leftHighStart = leftSide[0].high;
        const cupBottom = Math.min(...recent30.map(c => c.low));
        const rightHighEnd = rightSide[rightSide.length - 1].high;
        
        const cupDepth = (leftHighStart - cupBottom) / leftHighStart;
        const rightRecovery = rightHighEnd > leftHighStart * 0.95;
        
        if (cupDepth > 0.03 && cupDepth < 0.15 && rightRecovery) {
          patterns.push({ name: 'CUP&HANDLE', type: 'bullish' });
        }
      }
      
      // Inside Bar (consolidation/breakout setup)
      if (c.high < prev.high && c.low > prev.low) {
        patterns.push({ name: 'INSIDE BAR', type: 'neutral' });
      }
      
      // Outside Bar / Engulfing Range
      if (c.high > prev.high && c.low < prev.low && body > prevBody * 1.5) {
        patterns.push({ name: 'OUTSIDE BAR', type: isBullish ? 'bullish' : 'bearish' });
      }
      
      return patterns.slice(0, 5); // Increased to 5 patterns for GOD MODE
    }

    // ============================================
    // SPOOF DETECTION
    // ============================================

    function detectSpoofing(currentBids, currentAsks) {
      const lastBids = state.lastOrderBook.bids;
      const lastAsks = state.lastOrderBook.asks;
      
      if (lastBids.length === 0) return false;
      
      // Check for large orders that disappeared
      for (const lastBid of lastBids) {
        const vol = parseFloat(lastBid[1]);
        if (vol > CONFIG.SPOOF_THRESHOLD) {
          const stillExists = currentBids.some(b => 
            parseFloat(b[0]) === parseFloat(lastBid[0]) && 
            parseFloat(b[1]) > vol * 0.5
          );
          if (!stillExists) return true;
        }
      }
      
      for (const lastAsk of lastAsks) {
        const vol = parseFloat(lastAsk[1]);
        if (vol > CONFIG.SPOOF_THRESHOLD) {
          const stillExists = currentAsks.some(a => 
            parseFloat(a[0]) === parseFloat(lastAsk[0]) && 
            parseFloat(a[1]) > vol * 0.5
          );
          if (!stillExists) return true;
        }
      }
      
      return false;
    }

    // ============================================
    // ALERTS SYSTEM
    // ============================================

    function addAlert(message, type = 'info') {
      state.alertCount++;
      ui.alertCount.innerText = state.alertCount;
      
      const div = document.createElement('div');
      div.className = `alert-item alert-${type}`;
      const time = new Date().toLocaleTimeString();
      div.innerHTML = `<span style="color:var(--text-dim)">[${time}]</span> ${message}`;
      
      ui.alertsContainer.prepend(div);
      
      // Reproducir sonido seg√∫n tipo de alerta
      if (state.soundEnabled) {
        if (type === 'bullish') playSound('bullish');
        else if (type === 'bearish') playSound('bearish');
        else if (type === 'warning') playSound('alert');
      }
      
      while (ui.alertsContainer.children.length > 20) {
        ui.alertsContainer.lastChild.remove();
      }
    }

    // ============================================
    // PREDICTION TRACKING
    // ============================================

    function trackPrediction(targetPrice, currentPrice) {
      const rsi = state.rsiHistory.length > 0 ? state.rsiHistory[state.rsiHistory.length - 1] : null;
      
      state.predictions.push({
        timestamp: Date.now(),
        target: targetPrice,
        actual: currentPrice,
        direction: targetPrice > currentPrice ? 'up' : 'down',
        rsi: rsi
      });
      
      // Keep last 50 predictions
      if (state.predictions.length > 50) state.predictions.shift();
      
      // Calculate accuracy after we have some results
      if (state.predictions.length >= 10) {
        let correct = 0;
        for (let i = 0; i < state.predictions.length - 5; i++) {
          const pred = state.predictions[i];
          const futurePrice = state.predictions[Math.min(i + 5, state.predictions.length - 1)].actual;
          
          const actualDirection = futurePrice > pred.actual ? 'up' : 'down';
          const isCorrect = actualDirection === pred.direction;
          if (isCorrect) correct++;
          
          // Guardar en historial si no est√° ya
          if (state.predictionHistory.length < i + 1) {
            state.predictionHistory.push(isCorrect);
          }
        }
        
        // Limitar historial a 100
        if (state.predictionHistory.length > 100) {
          state.predictionHistory = state.predictionHistory.slice(-100);
        }
        
        const accuracy = (correct / (state.predictions.length - 5)) * 100;
        ui.modelAccuracy.innerText = accuracy.toFixed(0) + '%';
        ui.accuracyBar.style.width = accuracy + '%';
        ui.accuracyPct.innerText = accuracy.toFixed(0) + '%';
        
        ui.accuracyBar.style.background = accuracy > 60 ? 'var(--accent-green)' : 
          (accuracy > 50 ? 'var(--accent-orange)' : 'var(--accent-red)');
      }
      
      // Actualizar gr√°fico de historial SIEMPRE (muestra progreso)
      updatePredictionHistoryChart();
    }

    // ============================================
    // AI ENGINE v2.0 - ADVANCED PREDICTIVE SYSTEM
    // ============================================
    
    // Estado del motor AI
    const aiState = {
      marketRegime: 'unknown',        // trending_up, trending_down, ranging, volatile
      regimeStrength: 0,              // 0-100
      supportLevels: [],              // Niveles de soporte din√°micos
      resistanceLevels: [],           // Niveles de resistencia din√°micos
      signalQuality: 0,               // 0-100 calidad de la se√±al actual
      confluenceScore: 0,             // N√∫mero de indicadores en confluencia
      probabilityBull: 50,            // Probabilidad alcista %
      probabilityBear: 50,            // Probabilidad bajista %
      noiseLevel: 0,                  // Nivel de ruido del mercado
      lastSignals: [],                // Historial de se√±ales para backtesting
      predictionAccuracy: [],         // Tracking de precisi√≥n
      volumeProfile: [],              // Perfil de volumen
      lastDivergence: null,           // √öltima divergencia detectada (para evitar repetir alertas)
      priceAction: {                  // An√°lisis de price action
        higherHighs: 0,
        lowerLows: 0,
        swingHigh: 0,
        swingLow: 0
      }
    };

    // ============================================
    // 1. MARKET REGIME DETECTION
    // ============================================
    
    function detectMarketRegime(candles, closes) {
      if (candles.length < 50) return { regime: 'unknown', strength: 0, details: {} };
      
      // Calcular EMAs para tendencia
      const ema20 = calcEMA(closes, 20);
      const ema50 = calcEMA(closes, 50);
      const currentPrice = closes[closes.length - 1];
      
      // Calcular ATR para volatilidad
      const atr = calcATR(candles, 14);
      const avgPrice = closes.slice(-20).reduce((a,b) => a+b, 0) / 20;
      const atrPercent = (atr / avgPrice) * 100;
      
      // Calcular ADX para fuerza de tendencia
      const adx = calcADX(candles, 14);
      
      // Analizar estructura de precios (higher highs, lower lows)
      let higherHighs = 0, lowerLows = 0;
      const recentCandles = candles.slice(-20);
      
      for (let i = 2; i < recentCandles.length; i++) {
        if (recentCandles[i].high > recentCandles[i-1].high && recentCandles[i-1].high > recentCandles[i-2].high) {
          higherHighs++;
        }
        if (recentCandles[i].low < recentCandles[i-1].low && recentCandles[i-1].low < recentCandles[i-2].low) {
          lowerLows++;
        }
      }
      
      // Calcular pendiente de precio
      const priceSlope = (closes[closes.length-1] - closes[closes.length-20]) / closes[closes.length-20] * 100;
      
      // Determinar r√©gimen
      let regime = 'ranging';
      let strength = 0;
      let details = {
        emaAlignment: ema20 > ema50 ? 'bullish' : 'bearish',
        atrPercent: atrPercent.toFixed(2),
        adxValue: adx ? adx.adx.toFixed(1) : 0,
        priceSlope: priceSlope.toFixed(2),
        higherHighs,
        lowerLows
      };
      
      // Alta volatilidad = mercado vol√°til
      if (atrPercent > 3) {
        regime = 'volatile';
        strength = Math.min(100, atrPercent * 20);
      }
      // ADX alto + estructura clara = tendencia
      else if (adx && adx.adx > 25) {
        if (ema20 > ema50 && higherHighs >= 3 && currentPrice > ema20) {
          regime = 'trending_up';
          strength = Math.min(100, adx.adx * 2 + higherHighs * 10);
        } else if (ema20 < ema50 && lowerLows >= 3 && currentPrice < ema20) {
          regime = 'trending_down';
          strength = Math.min(100, adx.adx * 2 + lowerLows * 10);
        } else if (adx.plusDI > adx.minusDI + 10) {
          regime = 'trending_up';
          strength = Math.min(100, (adx.plusDI - adx.minusDI) * 3);
        } else if (adx.minusDI > adx.plusDI + 10) {
          regime = 'trending_down';
          strength = Math.min(100, (adx.minusDI - adx.plusDI) * 3);
        }
      }
      // ADX bajo = rango/consolidaci√≥n
      else {
        regime = 'ranging';
        strength = Math.max(0, 100 - (adx ? adx.adx * 3 : 50));
      }
      
      aiState.priceAction = { higherHighs, lowerLows, swingHigh: Math.max(...recentCandles.map(c => c.high)), swingLow: Math.min(...recentCandles.map(c => c.low)) };
      
      return { regime, strength, details };
    }

    // ============================================
    // 2. SUPPORT & RESISTANCE DETECTION
    // ============================================
    
    function detectSupportResistance(candles) {
      if (candles.length < 50) return { supports: [], resistances: [] };
      
      const supports = [];
      const resistances = [];
      const lookback = Math.min(candles.length, 100);
      const recentCandles = candles.slice(-lookback);
      
      // M√©todo 1: Pivot Points
      const pivotCandles = recentCandles.slice(-20);
      for (let i = 2; i < pivotCandles.length - 2; i++) {
        const candle = pivotCandles[i];
        const prevHigh = Math.max(pivotCandles[i-1].high, pivotCandles[i-2].high);
        const nextHigh = Math.max(pivotCandles[i+1].high, pivotCandles[i+2].high);
        const prevLow = Math.min(pivotCandles[i-1].low, pivotCandles[i-2].low);
        const nextLow = Math.min(pivotCandles[i+1].low, pivotCandles[i+2].low);
        
        if (candle.high > prevHigh && candle.high > nextHigh) {
          resistances.push({ price: candle.high, strength: 1, type: 'pivot' });
        }
        if (candle.low < prevLow && candle.low < nextLow) {
          supports.push({ price: candle.low, strength: 1, type: 'pivot' });
        }
      }
      
      // M√©todo 2: Volume Profile (zonas de alto volumen)
      const priceRange = Math.max(...recentCandles.map(c => c.high)) - Math.min(...recentCandles.map(c => c.low));
      const bucketSize = priceRange / 20;
      const volumeProfile = {};
      
      recentCandles.forEach(c => {
        const bucket = Math.floor((c.close - Math.min(...recentCandles.map(x => x.low))) / bucketSize);
        volumeProfile[bucket] = (volumeProfile[bucket] || 0) + c.volume;
      });
      
      // Encontrar High Volume Nodes (HVN)
      const avgVolume = Object.values(volumeProfile).reduce((a,b) => a+b, 0) / Object.keys(volumeProfile).length;
      Object.entries(volumeProfile).forEach(([bucket, vol]) => {
        if (vol > avgVolume * 1.5) {
          const price = Math.min(...recentCandles.map(c => c.low)) + (parseInt(bucket) + 0.5) * bucketSize;
          const currentPrice = candles[candles.length-1].close;
          if (price < currentPrice) {
            supports.push({ price, strength: vol / avgVolume, type: 'volume' });
          } else {
            resistances.push({ price, strength: vol / avgVolume, type: 'volume' });
          }
        }
      });
      
      // M√©todo 3: Round Numbers (niveles psicol√≥gicos)
      const currentPrice = candles[candles.length-1].close;
      const roundInterval = currentPrice > 1 ? 0.1 : currentPrice > 0.1 ? 0.01 : 0.001;
      const nearestRound = Math.round(currentPrice / roundInterval) * roundInterval;
      
      for (let i = -3; i <= 3; i++) {
        if (i === 0) continue;
        const level = nearestRound + (i * roundInterval);
        if (level < currentPrice) {
          supports.push({ price: level, strength: 0.5, type: 'psychological' });
        } else {
          resistances.push({ price: level, strength: 0.5, type: 'psychological' });
        }
      }
      
      // Consolidar niveles cercanos
      const consolidate = (levels) => {
        const consolidated = [];
        const sorted = levels.sort((a, b) => a.price - b.price);
        
        sorted.forEach(level => {
          const existing = consolidated.find(l => Math.abs(l.price - level.price) / level.price < 0.005);
          if (existing) {
            existing.strength += level.strength;
            existing.touches = (existing.touches || 1) + 1;
          } else {
            consolidated.push({ ...level, touches: 1 });
          }
        });
        
        return consolidated.sort((a, b) => b.strength - a.strength).slice(0, 5);
      };
      
      return {
        supports: consolidate(supports),
        resistances: consolidate(resistances)
      };
    }

    // ============================================
    // 3. CONFLUENCE ANALYSIS
    // ============================================
    
    function analyzeConfluence(indicators) {
      const bullishSignals = [];
      const bearishSignals = [];
      const neutralSignals = [];
      
      // RSI
      if (indicators.rsi !== null) {
        if (indicators.rsi < 30) bullishSignals.push({ name: 'RSI Oversold', weight: 1.5, value: indicators.rsi });
        else if (indicators.rsi > 70) bearishSignals.push({ name: 'RSI Overbought', weight: 1.5, value: indicators.rsi });
        else if (indicators.rsi > 50) bullishSignals.push({ name: 'RSI Bullish', weight: 0.5, value: indicators.rsi });
        else bearishSignals.push({ name: 'RSI Bearish', weight: 0.5, value: indicators.rsi });
      }
      
      // MACD
      if (indicators.macd) {
        if (indicators.macd.histogram > 0 && indicators.macd.macd > indicators.macd.signal) {
          bullishSignals.push({ name: 'MACD Bullish', weight: 1.3, value: indicators.macd.histogram });
        } else if (indicators.macd.histogram < 0 && indicators.macd.macd < indicators.macd.signal) {
          bearishSignals.push({ name: 'MACD Bearish', weight: 1.3, value: indicators.macd.histogram });
        }
        // MACD Crossover detection
        if (indicators.macdPrev && indicators.macd.macd > indicators.macd.signal && indicators.macdPrev.macd <= indicators.macdPrev.signal) {
          bullishSignals.push({ name: 'MACD Cross Up', weight: 2, value: 'crossover' });
        } else if (indicators.macdPrev && indicators.macd.macd < indicators.macd.signal && indicators.macdPrev.macd >= indicators.macdPrev.signal) {
          bearishSignals.push({ name: 'MACD Cross Down', weight: 2, value: 'crossover' });
        }
      }
      
      // EMA Cross
      if (indicators.emaFast && indicators.emaSlow) {
        if (indicators.emaFast > indicators.emaSlow) {
          bullishSignals.push({ name: 'EMA Bullish', weight: 1.2, value: (indicators.emaFast - indicators.emaSlow) / indicators.emaSlow * 100 });
        } else {
          bearishSignals.push({ name: 'EMA Bearish', weight: 1.2, value: (indicators.emaFast - indicators.emaSlow) / indicators.emaSlow * 100 });
        }
      }
      
      // Bollinger Bands
      if (indicators.bb) {
        if (indicators.currentPrice < indicators.bb.lower) {
          bullishSignals.push({ name: 'BB Oversold', weight: 1.4, value: 'below lower' });
        } else if (indicators.currentPrice > indicators.bb.upper) {
          bearishSignals.push({ name: 'BB Overbought', weight: 1.4, value: 'above upper' });
        }
      }
      
      // Stochastic RSI
      if (indicators.stochRSI !== null) {
        if (indicators.stochRSI < 20) bullishSignals.push({ name: 'StochRSI Oversold', weight: 1.1, value: indicators.stochRSI });
        else if (indicators.stochRSI > 80) bearishSignals.push({ name: 'StochRSI Overbought', weight: 1.1, value: indicators.stochRSI });
      }
      
      // Williams %R
      if (indicators.willR !== null) {
        if (indicators.willR < -80) bullishSignals.push({ name: 'Williams %R Oversold', weight: 0.9, value: indicators.willR });
        else if (indicators.willR > -20) bearishSignals.push({ name: 'Williams %R Overbought', weight: 0.9, value: indicators.willR });
      }
      
      // OBV Trend
      if (indicators.obv && indicators.obv.trend === 'bullish') {
        bullishSignals.push({ name: 'OBV Bullish', weight: 1.0, value: indicators.obv.obv });
      } else if (indicators.obv && indicators.obv.trend === 'bearish') {
        bearishSignals.push({ name: 'OBV Bearish', weight: 1.0, value: indicators.obv.obv });
      }
      
      // VWAP
      if (indicators.vwap) {
        if (indicators.currentPrice > indicators.vwap * 1.005) {
          bullishSignals.push({ name: 'Above VWAP', weight: 1.0, value: indicators.vwap });
        } else if (indicators.currentPrice < indicators.vwap * 0.995) {
          bearishSignals.push({ name: 'Below VWAP', weight: 1.0, value: indicators.vwap });
        }
      }
      
      // ADX Trend Strength
      if (indicators.adx && indicators.adx.adx > 25) {
        if (indicators.adx.plusDI > indicators.adx.minusDI) {
          bullishSignals.push({ name: 'ADX Bullish', weight: 1.3, value: indicators.adx.adx });
        } else {
          bearishSignals.push({ name: 'ADX Bearish', weight: 1.3, value: indicators.adx.adx });
        }
      }
      
      // RSI Divergence
      if (indicators.divergence === 'bullish') {
        bullishSignals.push({ name: 'RSI Bull Divergence', weight: 2.5, value: 'divergence' });
      } else if (indicators.divergence === 'bearish') {
        bearishSignals.push({ name: 'RSI Bear Divergence', weight: 2.5, value: 'divergence' });
      }
      
      // CVD
      if (indicators.cvd > 20000) bullishSignals.push({ name: 'CVD Bullish', weight: 0.8, value: indicators.cvd });
      else if (indicators.cvd < -20000) bearishSignals.push({ name: 'CVD Bearish', weight: 0.8, value: indicators.cvd });
      
      // Whale Flow
      if (indicators.whaleFlow > 100000) bullishSignals.push({ name: 'Whale Accumulation', weight: 1.5, value: indicators.whaleFlow });
      else if (indicators.whaleFlow < -100000) bearishSignals.push({ name: 'Whale Distribution', weight: 1.5, value: indicators.whaleFlow });
      
      // Candle Patterns
      if (indicators.patterns) {
        indicators.patterns.forEach(p => {
          if (p.type === 'bullish') bullishSignals.push({ name: p.name, weight: 0.7, value: 'pattern' });
          else if (p.type === 'bearish') bearishSignals.push({ name: p.name, weight: 0.7, value: 'pattern' });
        });
      }
      
      // Calcular peso total
      const bullWeight = bullishSignals.reduce((sum, s) => sum + s.weight, 0);
      const bearWeight = bearishSignals.reduce((sum, s) => sum + s.weight, 0);
      const totalWeight = bullWeight + bearWeight;
      
      // Calcular confluencia (se√±ales en la misma direcci√≥n)
      const maxConfluence = Math.max(bullishSignals.length, bearishSignals.length);
      const confluenceRatio = maxConfluence / (bullishSignals.length + bearishSignals.length + neutralSignals.length || 1);
      
      return {
        bullishSignals,
        bearishSignals,
        neutralSignals,
        bullWeight,
        bearWeight,
        totalWeight,
        confluenceCount: maxConfluence,
        confluenceRatio,
        dominantDirection: bullWeight > bearWeight ? 'bullish' : bearWeight > bullWeight ? 'bearish' : 'neutral'
      };
    }

    // ============================================
    // 4. PROBABILITY CALCULATION
    // ============================================
    
    function calculateProbability(confluence, regime, srLevels, currentPrice, atr) {
      let baseProbBull = 50;
      let baseProbBear = 50;
      
      // Ajuste por confluencia de indicadores
      const totalWeight = confluence.totalWeight || 1;
      const bullRatio = confluence.bullWeight / totalWeight;
      const bearRatio = confluence.bearWeight / totalWeight;
      
      baseProbBull = bullRatio * 100;
      baseProbBear = bearRatio * 100;
      
      // Ajuste por r√©gimen de mercado
      if (regime.regime === 'trending_up') {
        baseProbBull += regime.strength * 0.15;
        baseProbBear -= regime.strength * 0.1;
      } else if (regime.regime === 'trending_down') {
        baseProbBear += regime.strength * 0.15;
        baseProbBull -= regime.strength * 0.1;
      } else if (regime.regime === 'volatile') {
        // En mercado vol√°til, reducir certeza
        baseProbBull = 50 + (baseProbBull - 50) * 0.7;
        baseProbBear = 50 + (baseProbBear - 50) * 0.7;
      }
      
      // Ajuste por proximidad a S/R
      if (srLevels.supports.length > 0) {
        const nearestSupport = srLevels.supports.reduce((a, b) => 
          Math.abs(b.price - currentPrice) < Math.abs(a.price - currentPrice) ? b : a
        );
        const distanceToSupport = (currentPrice - nearestSupport.price) / atr;
        
        if (distanceToSupport > 0 && distanceToSupport < 1) {
          // Cerca del soporte - m√°s probable rebote alcista
          baseProbBull += (1 - distanceToSupport) * 10 * nearestSupport.strength;
        }
      }
      
      if (srLevels.resistances.length > 0) {
        const nearestResistance = srLevels.resistances.reduce((a, b) => 
          Math.abs(b.price - currentPrice) < Math.abs(a.price - currentPrice) ? b : a
        );
        const distanceToResistance = (nearestResistance.price - currentPrice) / atr;
        
        if (distanceToResistance > 0 && distanceToResistance < 1) {
          // Cerca de resistencia - m√°s probable rechazo bajista
          baseProbBear += (1 - distanceToResistance) * 10 * nearestResistance.strength;
        }
      }
      
      // Ajuste por n√∫mero de confluencias
      const confluenceBonus = Math.min(15, confluence.confluenceCount * 2);
      if (confluence.dominantDirection === 'bullish') {
        baseProbBull += confluenceBonus;
      } else if (confluence.dominantDirection === 'bearish') {
        baseProbBear += confluenceBonus;
      }
      
      // Normalizar a 100%
      const total = baseProbBull + baseProbBear;
      baseProbBull = (baseProbBull / total) * 100;
      baseProbBear = (baseProbBear / total) * 100;
      
      // Limitar extremos (nunca 100% o 0%)
      baseProbBull = Math.max(5, Math.min(95, baseProbBull));
      baseProbBear = 100 - baseProbBull;
      
      return {
        bullish: baseProbBull,
        bearish: baseProbBear,
        confidence: Math.abs(baseProbBull - 50) * 2 // 0-100, mayor = m√°s confianza
      };
    }

    // ============================================
    // 5. NOISE FILTER
    // ============================================
    
    function calculateNoiseLevel(candles, atr, volume) {
      if (candles.length < 20) return 50;
      
      const recentCandles = candles.slice(-20);
      
      // Factor 1: Relaci√≥n body/wick (muchas mechas = ruido)
      let wickRatio = 0;
      recentCandles.forEach(c => {
        const body = Math.abs(c.close - c.open);
        const totalRange = c.high - c.low;
        if (totalRange > 0) {
          wickRatio += (totalRange - body) / totalRange;
        }
      });
      wickRatio /= recentCandles.length;
      
      // Factor 2: Cambios de direcci√≥n frecuentes
      let directionChanges = 0;
      for (let i = 1; i < recentCandles.length; i++) {
        const prevDir = recentCandles[i-1].close > recentCandles[i-1].open ? 1 : -1;
        const currDir = recentCandles[i].close > recentCandles[i].open ? 1 : -1;
        if (prevDir !== currDir) directionChanges++;
      }
      const directionChangeRatio = directionChanges / (recentCandles.length - 1);
      
      // Factor 3: Volumen bajo = m√°s susceptible a ruido
      const avgVolume = recentCandles.reduce((sum, c) => sum + c.volume, 0) / recentCandles.length;
      const currentVolume = recentCandles[recentCandles.length - 1].volume;
      const volumeRatio = currentVolume / avgVolume;
      const lowVolumeNoise = volumeRatio < 0.5 ? 30 : volumeRatio < 0.8 ? 15 : 0;
      
      // Factor 4: ATR muy bajo = ruido de consolidaci√≥n
      const avgPrice = recentCandles.reduce((sum, c) => sum + c.close, 0) / recentCandles.length;
      const atrPercent = (atr / avgPrice) * 100;
      const lowVolatilityNoise = atrPercent < 0.5 ? 25 : atrPercent < 1 ? 10 : 0;
      
      // Calcular nivel de ruido total (0-100)
      const noiseLevel = Math.min(100, 
        (wickRatio * 40) + 
        (directionChangeRatio * 30) + 
        lowVolumeNoise + 
        lowVolatilityNoise
      );
      
      return {
        level: noiseLevel,
        isNoisy: noiseLevel > 50,
        factors: {
          wickRatio: (wickRatio * 100).toFixed(1) + '%',
          directionChanges: directionChangeRatio.toFixed(2),
          volumeRatio: volumeRatio.toFixed(2),
          atrPercent: atrPercent.toFixed(3) + '%'
        }
      };
    }

    // ============================================
    // 6. SIGNAL QUALITY SCORE
    // ============================================
    
    function calculateSignalQuality(confluence, regime, noise, probability) {
      let quality = 50;
      
      // +20 por alta confluencia
      if (confluence.confluenceCount >= 6) quality += 20;
      else if (confluence.confluenceCount >= 4) quality += 12;
      else if (confluence.confluenceCount >= 3) quality += 5;
      
      // +15 por r√©gimen claro
      if (regime.regime !== 'ranging' && regime.regime !== 'volatile' && regime.strength > 60) {
        quality += 15;
      } else if (regime.regime === 'volatile') {
        quality -= 10;
      }
      
      // -20 por ruido alto
      if (noise.level > 60) quality -= 20;
      else if (noise.level > 40) quality -= 10;
      else quality += 10;
      
      // +15 por probabilidad extrema
      if (probability.confidence > 70) quality += 15;
      else if (probability.confidence > 50) quality += 8;
      
      // +10 si hay divergencia RSI
      if (confluence.bullishSignals.some(s => s.name.includes('Divergence')) ||
          confluence.bearishSignals.some(s => s.name.includes('Divergence'))) {
        quality += 10;
      }
      
      return Math.max(0, Math.min(100, quality));
    }

    // ============================================
    // 7. PRICE TARGET CALCULATION
    // ============================================
    
    function calculatePriceTarget(currentPrice, atr, probability, regime, srLevels) {
      const direction = probability.bullish > probability.bearish ? 1 : -1;
      const confidence = probability.confidence / 100;
      
      // Base target: ATR-based
      let baseMove = atr * (0.5 + confidence);
      
      // Ajuste por r√©gimen
      if (regime.regime === 'trending_up' && direction > 0) {
        baseMove *= 1.3;
      } else if (regime.regime === 'trending_down' && direction < 0) {
        baseMove *= 1.3;
      } else if (regime.regime === 'ranging') {
        baseMove *= 0.6; // Movimientos m√°s peque√±os en rango
      }
      
      let target = currentPrice + (baseMove * direction);
      
      // Ajustar target a niveles S/R cercanos
      if (direction > 0 && srLevels.resistances.length > 0) {
        const nearestResistance = srLevels.resistances.find(r => r.price > currentPrice);
        if (nearestResistance && nearestResistance.price < target) {
          target = nearestResistance.price * 0.998; // Justo antes de la resistencia
        }
      } else if (direction < 0 && srLevels.supports.length > 0) {
        const nearestSupport = srLevels.supports.find(s => s.price < currentPrice);
        if (nearestSupport && nearestSupport.price > target) {
          target = nearestSupport.price * 1.002; // Justo antes del soporte
        }
      }
      
      return {
        target,
        direction: direction > 0 ? 'bullish' : 'bearish',
        expectedMove: Math.abs(target - currentPrice),
        expectedMovePercent: Math.abs((target - currentPrice) / currentPrice * 100)
      };
    }

    // ============================================
    // MAIN AI ENGINE v2
    // ============================================

    function runPredictionEngine(currentPrice) {
      if (state.candles.length < 30) {
        ui.aiTarget.innerText = 'Collecting data...';
        return;
      }

      const closes = state.candles.map(c => c.close);
      
      // Store price history for divergence detection
      state.priceHistory.push(currentPrice);
      if (state.priceHistory.length > 50) state.priceHistory.shift();

      // ==========================================
      // PHASE 1: Calculate All Indicators
      // ==========================================
      
      const rsi = calcRSI(closes, CONFIG.RSI_PERIOD);
      if (rsi !== null) {
        state.rsiHistory.push(rsi);
        if (state.rsiHistory.length > 50) state.rsiHistory.shift();
      }
      
      const macd = calcMACD(closes);
      const stochRSI = calcStochRSI(closes, CONFIG.STOCH_PERIOD);
      const willR = calcWilliamsR(state.candles, CONFIG.WILLR_PERIOD);
      const bb = calcBollingerBands(closes, CONFIG.BB_PERIOD, CONFIG.BB_STD);
      const emaFast = calcEMA(closes, CONFIG.EMA_FAST);
      const emaSlow = calcEMA(closes, CONFIG.EMA_SLOW);
      const adx = calcADX(state.candles, CONFIG.ADX_PERIOD);
      const vwap = calcVWAP(state.candles);
      const obv = calcOBV(state.candles);
      const momentum = calcMomentum(closes, 10);
      const atr = calcATR(state.candles, CONFIG.ATR_PERIOD);
      const divergence = detectRSIDivergence(state.priceHistory, state.rsiHistory);
      const patterns = detectCandlePatterns(state.candles);
      const whaleFlow = state.whaleBuyVol - state.whaleSellVol;

      // üî± GOD MODE INDICATORS
      const ichimoku = calcIchimoku(state.candles);
      const supertrend = calcSupertrend(state.candles, 10, 3);
      const squeeze = calcSqueezeMomentum(state.candles);
      const cmf = calcCMF(state.candles, 20);
      const volumeProfile = calcVolumeProfile(state.candles, 20);
      const orderFlowImbalance = calcOrderFlowImbalance(state.candles);
      const marketStructure = calcMarketStructure(state.candles);
      const smartMoney = calcSmartMoneyConcepts(state.candles);
      const autoFibo = calcAutoFibonacci(state.candles, 50);
      const mtfAnalysis = analyzeMultiTimeframe(state.candles);
      const whaleImpact = calculateWhaleImpact();

      // ==========================================
      // PHASE 2: AI Analysis
      // ==========================================
      
      // 2.1 Detect Market Regime
      const regime = detectMarketRegime(state.candles, closes);
      aiState.marketRegime = regime.regime;
      aiState.regimeStrength = regime.strength;
      
      // 2.2 Detect Support/Resistance
      const srLevels = detectSupportResistance(state.candles);
      aiState.supportLevels = srLevels.supports;
      aiState.resistanceLevels = srLevels.resistances;
      
      // 2.3 Calculate Confluence
      const indicators = {
        rsi, macd, stochRSI, willR, bb, emaFast, emaSlow, adx, vwap, obv,
        momentum, divergence, patterns, currentPrice,
        cvd: state.cvd, whaleFlow
      };
      const confluence = analyzeConfluence(indicators);
      aiState.confluenceScore = confluence.confluenceCount;
      
      // 2.4 Calculate Noise Level
      const avgVol = state.candles.slice(-20).reduce((s,c) => s + c.volume, 0) / 20;
      const noise = calculateNoiseLevel(state.candles, atr || 0.001, avgVol);
      aiState.noiseLevel = noise.level;
      
      // 2.5 Calculate Probability
      const probability = calculateProbability(confluence, regime, srLevels, currentPrice, atr || 0.001);
      aiState.probabilityBull = probability.bullish;
      aiState.probabilityBear = probability.bearish;
      
      // 2.6 Calculate Signal Quality
      const signalQuality = calculateSignalQuality(confluence, regime, noise, probability);
      aiState.signalQuality = signalQuality;
      
      // 2.7 Calculate Price Target
      const priceTarget = calculatePriceTarget(currentPrice, atr || 0.001, probability, regime, srLevels);

      // ==========================================
      // PHASE 3: Update UI - Indicators
      // ==========================================
      
      // RSI
      if (rsi !== null) {
        document.getElementById('rsiValue').innerText = rsi.toFixed(1);
        const rsiEl = document.getElementById('rsiSignal');
        if (rsi > 70) { rsiEl.className = 'indicator-signal signal-sell'; rsiEl.innerText = 'OVERBOUGHT'; }
        else if (rsi < 30) { rsiEl.className = 'indicator-signal signal-buy'; rsiEl.innerText = 'OVERSOLD'; }
        else { rsiEl.className = 'indicator-signal signal-neutral'; rsiEl.innerText = 'NEUTRAL'; }
      }

      // RSI Divergence
      const divEl = document.getElementById('divSignal');
      const divValEl = document.getElementById('divValue');
      if (divergence === 'bullish') {
        divEl.className = 'indicator-signal signal-buy'; divEl.innerText = 'BULLISH';
        divValEl.innerText = '‚Üó DETECTED';
        ui.divergenceBadge.style.display = 'block';
        ui.divergenceBadge.className = 'divergence-badge div-bullish';
        ui.divergenceBadge.innerText = '‚Üó BULL DIV';
        // Voice alert for divergence
        if (aiState.lastDivergence !== 'bullish') {
          voiceAlertDivergence('Bullish');
          aiState.lastDivergence = 'bullish';
        }
      } else if (divergence === 'bearish') {
        divEl.className = 'indicator-signal signal-sell'; divEl.innerText = 'BEARISH';
        divValEl.innerText = '‚Üò DETECTED';
        ui.divergenceBadge.style.display = 'block';
        ui.divergenceBadge.className = 'divergence-badge div-bearish';
        ui.divergenceBadge.innerText = '‚Üò BEAR DIV';
        // Voice alert for divergence
        if (aiState.lastDivergence !== 'bearish') {
          voiceAlertDivergence('Bearish');
          aiState.lastDivergence = 'bearish';
        }
      } else {
        divEl.className = 'indicator-signal signal-neutral'; divEl.innerText = 'NONE';
        divValEl.innerText = 'No signal';
        ui.divergenceBadge.style.display = 'none';
        aiState.lastDivergence = null;
      }

      // MACD
      if (macd.macd !== null) {
        document.getElementById('macdValue').innerText = macd.histogram.toFixed(5);
        const macdEl = document.getElementById('macdSignal');
        if (macd.histogram > 0 && macd.macd > macd.signal) {
          macdEl.className = 'indicator-signal signal-buy'; macdEl.innerText = 'BULLISH';
        } else if (macd.histogram < 0 && macd.macd < macd.signal) {
          macdEl.className = 'indicator-signal signal-sell'; macdEl.innerText = 'BEARISH';
        } else {
          macdEl.className = 'indicator-signal signal-neutral'; macdEl.innerText = 'CROSSING';
        }
      }

      // Stochastic RSI
      if (stochRSI !== null) {
        document.getElementById('stochValue').innerText = stochRSI.toFixed(1);
        const stochEl = document.getElementById('stochSignal');
        if (stochRSI > 80) { stochEl.className = 'indicator-signal signal-sell'; stochEl.innerText = 'OVERBOUGHT'; }
        else if (stochRSI < 20) { stochEl.className = 'indicator-signal signal-buy'; stochEl.innerText = 'OVERSOLD'; }
        else { stochEl.className = 'indicator-signal signal-neutral'; stochEl.innerText = 'NEUTRAL'; }
      }

      // Williams %R
      if (willR !== null) {
        document.getElementById('willrValue').innerText = willR.toFixed(1);
        const willEl = document.getElementById('willrSignal');
        if (willR > -20) { willEl.className = 'indicator-signal signal-sell'; willEl.innerText = 'OVERBOUGHT'; }
        else if (willR < -80) { willEl.className = 'indicator-signal signal-buy'; willEl.innerText = 'OVERSOLD'; }
        else { willEl.className = 'indicator-signal signal-neutral'; willEl.innerText = 'NEUTRAL'; }
      }

      // Bollinger Bands
      if (bb) {
        const bbPosition = ((currentPrice - bb.lower) / (bb.upper - bb.lower)) * 100;
        document.getElementById('bbValue').innerText = bbPosition.toFixed(0) + '%';
        const bbEl = document.getElementById('bbSignal');
        if (currentPrice > bb.upper) { bbEl.className = 'indicator-signal signal-sell'; bbEl.innerText = 'ABOVE'; }
        else if (currentPrice < bb.lower) { bbEl.className = 'indicator-signal signal-buy'; bbEl.innerText = 'BELOW'; }
        else { bbEl.className = 'indicator-signal signal-neutral'; bbEl.innerText = 'IN BAND'; }
      }

      // EMA Cross
      if (emaFast && emaSlow) {
        const emaDiff = ((emaFast - emaSlow) / emaSlow) * 100;
        document.getElementById('emaValue').innerText = emaDiff.toFixed(3) + '%';
        const emaEl = document.getElementById('emaSignal');
        if (emaFast > emaSlow && currentPrice > emaFast) {
          emaEl.className = 'indicator-signal signal-buy'; emaEl.innerText = 'BULLISH';
        } else if (emaFast < emaSlow && currentPrice < emaFast) {
          emaEl.className = 'indicator-signal signal-sell'; emaEl.innerText = 'BEARISH';
        } else {
          emaEl.className = 'indicator-signal signal-neutral'; emaEl.innerText = 'MIXED';
        }
      }

      // ADX
      if (adx) {
        document.getElementById('adxValue').innerText = adx.adx.toFixed(1);
        const adxEl = document.getElementById('adxSignal');
        if (adx.adx > 25) {
          if (adx.plusDI > adx.minusDI) { adxEl.className = 'indicator-signal signal-buy'; adxEl.innerText = 'STRONG ‚Üë'; }
          else { adxEl.className = 'indicator-signal signal-sell'; adxEl.innerText = 'STRONG ‚Üì'; }
        } else {
          adxEl.className = 'indicator-signal signal-neutral'; adxEl.innerText = 'WEAK';
        }
      }

      // VWAP
      if (vwap) {
        document.getElementById('vwapValue').innerText = vwap.toFixed(4);
        const vwapEl = document.getElementById('vwapSignal');
        if (currentPrice > vwap * 1.002) { vwapEl.className = 'indicator-signal signal-buy'; vwapEl.innerText = 'ABOVE'; }
        else if (currentPrice < vwap * 0.998) { vwapEl.className = 'indicator-signal signal-sell'; vwapEl.innerText = 'BELOW'; }
        else { vwapEl.className = 'indicator-signal signal-neutral'; vwapEl.innerText = 'AT VWAP'; }
      }

      // OBV
      document.getElementById('obvValue').innerText = (obv.obv / 1000000).toFixed(2) + 'M';
      const obvEl = document.getElementById('obvSignal');
      if (obv.trend === 'bullish') { obvEl.className = 'indicator-signal signal-buy'; obvEl.innerText = 'BULLISH'; }
      else if (obv.trend === 'bearish') { obvEl.className = 'indicator-signal signal-sell'; obvEl.innerText = 'BEARISH'; }
      else { obvEl.className = 'indicator-signal signal-neutral'; obvEl.innerText = 'NEUTRAL'; }

      // Momentum
      if (momentum !== null) {
        document.getElementById('momValue').innerText = momentum.toFixed(2) + '%';
        const momEl = document.getElementById('momSignal');
        if (momentum > 0.5) { momEl.className = 'indicator-signal signal-buy'; momEl.innerText = 'POSITIVE'; }
        else if (momentum < -0.5) { momEl.className = 'indicator-signal signal-sell'; momEl.innerText = 'NEGATIVE'; }
        else { momEl.className = 'indicator-signal signal-neutral'; momEl.innerText = 'FLAT'; }
      }

      // CVD
      const cvdEl = document.getElementById('cvdSignal');
      document.getElementById('cvdValue').innerText = (state.cvd / 1000).toFixed(1) + 'K';
      if (state.cvd > 10000) { cvdEl.className = 'indicator-signal signal-buy'; cvdEl.innerText = 'BUYING'; }
      else if (state.cvd < -10000) { cvdEl.className = 'indicator-signal signal-sell'; cvdEl.innerText = 'SELLING'; }
      else { cvdEl.className = 'indicator-signal signal-neutral'; cvdEl.innerText = 'NEUTRAL'; }

      // Whale Flow
      const whaleFlowEl = document.getElementById('whaleFlowSignal');
      document.getElementById('whaleFlowValue').innerText = (whaleFlow / 1000).toFixed(0) + 'K';
      if (whaleFlow > 100000) { whaleFlowEl.className = 'indicator-signal signal-buy'; whaleFlowEl.innerText = 'ACCUMULATING'; }
      else if (whaleFlow < -100000) { whaleFlowEl.className = 'indicator-signal signal-sell'; whaleFlowEl.innerText = 'DISTRIBUTING'; }
      else { whaleFlowEl.className = 'indicator-signal signal-neutral'; whaleFlowEl.innerText = 'NEUTRAL'; }

      // ATR Levels
      if (atr) {
        document.getElementById('r2').innerText = (currentPrice + atr * 2).toFixed(4);
        document.getElementById('r1').innerText = (currentPrice + atr).toFixed(4);
        document.getElementById('currentLevel').innerText = currentPrice.toFixed(4);
        document.getElementById('s1').innerText = (currentPrice - atr).toFixed(4);
        document.getElementById('s2').innerText = (currentPrice - atr * 2).toFixed(4);
      }

      // Candle Patterns
      if (patterns.length > 0) {
        ui.patternsContainer.innerHTML = patterns.map(p => 
          `<span class="pattern-tag" style="color:${p.type === 'bullish' ? 'var(--accent-green)' : (p.type === 'bearish' ? 'var(--accent-red)' : 'var(--accent-purple)')}">${p.name}</span>`
        ).join('');
      } else {
        ui.patternsContainer.innerHTML = '<span style="color:var(--text-dim); font-size:10px;">No patterns</span>';
      }

      // ==========================================
      // PHASE 4: Update AI Dashboard
      // ==========================================
      
      // Track prediction for accuracy
      trackPrediction(priceTarget.target, currentPrice);

      // Main Target Display
      ui.aiTarget.innerText = '$ ' + priceTarget.target.toFixed(4);
      ui.aiTarget.style.color = priceTarget.direction === 'bullish' ? 'var(--accent-green)' : 'var(--accent-red)';
      
      // Confidence (now based on probability)
      ui.conf.innerText = probability.confidence.toFixed(0) + '%';

      // Score Bar (based on probability)
      const normalizedScore = probability.bullish;
      const fillWidth = Math.abs(normalizedScore - 50);
      const fillColor = normalizedScore > 50 ? 'var(--accent-green)' : 'var(--accent-red)';
      const fillLeft = normalizedScore > 50 ? '50%' : (50 - fillWidth) + '%';
      
      ui.scoreFill.style.width = fillWidth + '%';
      ui.scoreFill.style.left = fillLeft;
      ui.scoreFill.style.background = fillColor;

      // Signal Counts
      ui.bullCount.innerText = confluence.bullishSignals.length;
      ui.neutCount.innerText = confluence.neutralSignals.length;
      ui.bearCount.innerText = confluence.bearishSignals.length;

      // Total Score (Signal Quality)
      ui.totalScore.innerText = signalQuality.toFixed(0) + '/100';
      ui.totalScore.style.color = signalQuality > 70 ? 'var(--accent-green)' : (signalQuality > 40 ? 'var(--accent-orange)' : 'var(--accent-red)');

      // Consensus with Probability
      const probBull = probability.bullish;
      if (probBull >= 70 && signalQuality >= 60) {
        ui.consensus.innerText = `STRONG BULL ${probBull.toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-green)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} signals aligned ‚Ä¢ ${regime.regime.replace('_', ' ').toUpperCase()}`;
      } else if (probBull >= 55) {
        ui.consensus.innerText = `BULLISH ${probBull.toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-green)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} confluences ‚Ä¢ Quality: ${signalQuality.toFixed(0)}%`;
      } else if (probBull <= 30 && signalQuality >= 60) {
        ui.consensus.innerText = `STRONG BEAR ${(100-probBull).toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-red)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} signals aligned ‚Ä¢ ${regime.regime.replace('_', ' ').toUpperCase()}`;
      } else if (probBull <= 45) {
        ui.consensus.innerText = `BEARISH ${(100-probBull).toFixed(0)}%`;
        ui.consensus.style.color = 'var(--accent-red)';
        ui.scoreLabel.innerText = `${confluence.confluenceCount} confluences ‚Ä¢ Quality: ${signalQuality.toFixed(0)}%`;
      } else {
        ui.consensus.innerText = 'NEUTRAL 50%';
        ui.consensus.style.color = 'var(--accent-orange)';
        ui.scoreLabel.innerText = noise.isNoisy ? '‚ö†Ô∏è Noisy market - wait for clarity' : 'Mixed signals - no clear direction';
      }

      // ==========================================
      // PHASE 5: Update AI v2 Dashboard Elements
      // ==========================================
      
      // Market Regime Display
      if (ui.marketRegime) {
        const regimeNames = {
          'trending_up': 'üìà TRENDING UP',
          'trending_down': 'üìâ TRENDING DOWN',
          'ranging': '‚ÜîÔ∏è RANGING',
          'volatile': '‚ö° VOLATILE',
          'unknown': '‚ùì ANALYZING'
        };
        const regimeColors = {
          'trending_up': 'var(--accent-green)',
          'trending_down': 'var(--accent-red)',
          'ranging': 'var(--accent-orange)',
          'volatile': 'var(--accent-purple)',
          'unknown': 'var(--text-dim)'
        };
        ui.marketRegime.innerText = regimeNames[regime.regime] || regime.regime.toUpperCase();
        ui.marketRegime.style.color = regimeColors[regime.regime] || 'var(--accent-cyan)';
      }
      
      // Signal Quality
      if (ui.signalQuality) {
        ui.signalQuality.innerText = signalQuality.toFixed(0) + '%';
        ui.signalQuality.style.color = signalQuality >= 70 ? 'var(--accent-green)' : signalQuality >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';
      }
      
      // Probability Display
      if (ui.probBull) {
        ui.probBull.innerText = probability.bullish.toFixed(0) + '%';
        ui.probBull.style.color = probability.bullish >= 60 ? 'var(--accent-green)' : 'var(--text-dim)';
      }
      if (ui.probBear) {
        ui.probBear.innerText = probability.bearish.toFixed(0) + '%';
        ui.probBear.style.color = probability.bearish >= 60 ? 'var(--accent-red)' : 'var(--text-dim)';
      }
      
      // Confluence Count
      if (ui.confluenceCount) {
        ui.confluenceCount.innerText = confluence.confluenceCount;
        ui.confluenceCount.style.color = confluence.confluenceCount >= 6 ? 'var(--accent-green)' : confluence.confluenceCount >= 4 ? 'var(--accent-cyan)' : 'var(--accent-purple)';
      }
      
      // Noise Level
      if (ui.noiseLevel) {
        ui.noiseLevel.innerText = noise.level.toFixed(0) + '%';
        ui.noiseLevel.style.color = noise.level > 60 ? 'var(--accent-red)' : noise.level > 40 ? 'var(--accent-orange)' : 'var(--accent-green)';
      }
      
      // ==========================================
      // üî± GOD MODE UI UPDATES
      // ==========================================
      
      // Multi-Timeframe Display
      const updateMTFBox = (id, data) => {
        const box = document.getElementById(id);
        if (box) {
          const valueSpan = box.querySelector('span:last-child');
          if (valueSpan) {
            if (data.signal === 'bullish') {
              valueSpan.innerText = '‚ñ≤';
              valueSpan.style.color = 'var(--accent-green)';
            } else if (data.signal === 'bearish') {
              valueSpan.innerText = '‚ñº';
              valueSpan.style.color = 'var(--accent-red)';
            } else {
              valueSpan.innerText = '‚Äî';
              valueSpan.style.color = 'var(--text-dim)';
            }
          }
        }
      };
      
      updateMTFBox('mtf1m', mtfAnalysis.tf1m);
      updateMTFBox('mtf5m', mtfAnalysis.tf5m);
      updateMTFBox('mtf15m', mtfAnalysis.tf15m);
      updateMTFBox('mtf1h', mtfAnalysis.tf1h);
      
      const mtfScoreBox = document.getElementById('mtfScore');
      if (mtfScoreBox) {
        const scoreSpan = mtfScoreBox.querySelector('span');
        if (scoreSpan) {
          scoreSpan.innerText = mtfAnalysis.confluence + '/4';
          scoreSpan.style.color = mtfAnalysis.confluence >= 3 ? 'var(--accent-green)' : mtfAnalysis.confluence >= 2 ? 'var(--accent-cyan)' : 'var(--accent-purple)';
        }
      }
      
      // Whale Impact
      const whaleImpactEl = document.getElementById('whaleImpact');
      if (whaleImpactEl) {
        whaleImpactEl.innerText = whaleImpact >= 0 ? '+' + whaleImpact : whaleImpact;
        whaleImpactEl.style.color = whaleImpact > 20 ? 'var(--accent-green)' : whaleImpact < -20 ? 'var(--accent-red)' : 'var(--accent-cyan)';
      }
      
      // Smart Money Concepts Display
      const smcOB = document.getElementById('smcOB');
      const smcFVG = document.getElementById('smcFVG');
      const smcLiq = document.getElementById('smcLiq');
      const smcStruct = document.getElementById('smcStruct');
      
      if (smcOB && smartMoney.nearestOB) {
        smcOB.innerText = smartMoney.nearestOB.type === 'bullish' ? '‚ñ≤ BUY' : '‚ñº SELL';
        smcOB.style.color = smartMoney.nearestOB.type === 'bullish' ? 'var(--accent-green)' : 'var(--accent-red)';
      } else if (smcOB) {
        smcOB.innerText = 'NONE';
        smcOB.style.color = 'var(--text-dim)';
      }
      
      if (smcFVG && smartMoney.nearestFVG) {
        smcFVG.innerText = smartMoney.nearestFVG.type === 'bullish' ? '‚ñ≤ GAP' : '‚ñº GAP';
        smcFVG.style.color = smartMoney.nearestFVG.type === 'bullish' ? 'var(--accent-green)' : 'var(--accent-red)';
      } else if (smcFVG) {
        smcFVG.innerText = 'NONE';
        smcFVG.style.color = 'var(--text-dim)';
      }
      
      if (smcLiq && smartMoney.liquidity.length > 0) {
        const nearestLiq = smartMoney.liquidity[0];
        smcLiq.innerText = nearestLiq.type === 'buy_side' ? 'BUY $' + nearestLiq.price.toFixed(3) : 'SELL $' + nearestLiq.price.toFixed(3);
        smcLiq.style.color = nearestLiq.type === 'buy_side' ? 'var(--accent-green)' : 'var(--accent-red)';
      } else if (smcLiq) {
        smcLiq.innerText = 'NONE';
        smcLiq.style.color = 'var(--text-dim)';
      }
      
      if (smcStruct && marketStructure) {
        const structNames = {
          'uptrend': '‚ñ≤ UPTREND',
          'downtrend': '‚ñº DOWNTREND',
          'ranging': '‚Üî RANGE',
          'expanding': '‚óá EXPAND',
          'contracting': '‚óÜ CONTRACT'
        };
        smcStruct.innerText = structNames[marketStructure.structure] || marketStructure.structure;
        smcStruct.style.color = marketStructure.structure === 'uptrend' ? 'var(--accent-green)' : 
                               marketStructure.structure === 'downtrend' ? 'var(--accent-red)' : 'var(--accent-orange)';
      }
      
      // Advanced Tab Indicators
      // Ichimoku
      const ichiValue = document.getElementById('ichiValue');
      const ichiSignal = document.getElementById('ichiSignal');
      if (ichiValue && ichiSignal && ichimoku) {
        ichiValue.innerText = ichimoku.signal === 'bullish' ? 'Above Cloud' : ichimoku.signal === 'bearish' ? 'Below Cloud' : 'In Cloud';
        ichiSignal.className = 'indicator-signal ' + (ichimoku.signal === 'bullish' ? 'signal-buy' : ichimoku.signal === 'bearish' ? 'signal-sell' : 'signal-neutral');
        ichiSignal.innerText = ichimoku.signal.toUpperCase();
      }
      
      // Fibonacci
      const fiboValue = document.getElementById('fiboValue');
      const fiboSignal = document.getElementById('fiboSignal');
      if (fiboValue && fiboSignal && autoFibo) {
        fiboValue.innerText = autoFibo.nearest.name;
        const nearSupport = autoFibo.nearest.name === '61.8%' || autoFibo.nearest.name === '78.6%';
        const nearResist = autoFibo.nearest.name === '23.6%' || autoFibo.nearest.name === '38.2%';
        fiboSignal.className = 'indicator-signal ' + (nearSupport ? 'signal-buy' : nearResist ? 'signal-sell' : 'signal-neutral');
        fiboSignal.innerText = nearSupport ? 'SUPPORT' : nearResist ? 'RESIST' : 'MID';
      }
      
      // Volume Profile
      const vpValue = document.getElementById('vpValue');
      const vpSignal = document.getElementById('vpSignal');
      if (vpValue && vpSignal && volumeProfile) {
        vpValue.innerText = volumeProfile.currentVsProfile === 'above_poc' ? 'Above POC' : 'Below POC';
        vpSignal.className = 'indicator-signal ' + (volumeProfile.currentVsProfile === 'above_poc' ? 'signal-buy' : 'signal-sell');
        vpSignal.innerText = volumeProfile.currentVsProfile === 'above_poc' ? 'BULLISH' : 'BEARISH';
      }
      
      // Order Flow Imbalance
      const ofiValue = document.getElementById('ofiValue');
      const ofiSignal = document.getElementById('ofiSignal');
      if (ofiValue && ofiSignal && orderFlowImbalance) {
        ofiValue.innerText = orderFlowImbalance.imbalance.toFixed(0) + '%';
        ofiSignal.className = 'indicator-signal ' + (orderFlowImbalance.signal === 'bullish' ? 'signal-buy' : orderFlowImbalance.signal === 'bearish' ? 'signal-sell' : 'signal-neutral');
        ofiSignal.innerText = orderFlowImbalance.signal.toUpperCase();
      }
      
      // Market Structure
      const structValue = document.getElementById('structValue');
      const structSignal = document.getElementById('structSignal');
      if (structValue && structSignal && marketStructure) {
        structValue.innerText = marketStructure.structure;
        structSignal.className = 'indicator-signal ' + (marketStructure.structure === 'uptrend' ? 'signal-buy' : marketStructure.structure === 'downtrend' ? 'signal-sell' : 'signal-neutral');
        structSignal.innerText = marketStructure.structure === 'uptrend' ? 'BULLISH' : marketStructure.structure === 'downtrend' ? 'BEARISH' : 'NEUTRAL';
      }
      
      // Whale Order Book
      const whaleOBValue = document.getElementById('whaleOBValue');
      const whaleOBSignal = document.getElementById('whaleOBSignal');
      if (whaleOBValue && whaleOBSignal) {
        const obDelta = state.bidWall - state.askWall;
        whaleOBValue.innerText = (obDelta / 1000).toFixed(0) + 'K';
        whaleOBSignal.className = 'indicator-signal ' + (obDelta > 50000 ? 'signal-buy' : obDelta < -50000 ? 'signal-sell' : 'signal-neutral');
        whaleOBSignal.innerText = obDelta > 50000 ? 'BID WALL' : obDelta < -50000 ? 'ASK WALL' : 'BALANCED';
      }
      
      // Squeeze Momentum
      const squeezeValue = document.getElementById('squeezeValue');
      const squeezeSignal = document.getElementById('squeezeSignal');
      if (squeezeValue && squeezeSignal && squeeze) {
        squeezeValue.innerText = squeeze.squeezeOn ? '‚è∫ ON' : '‚ñ∂ OFF';
        squeezeSignal.className = 'indicator-signal ' + (squeeze.signal.includes('bull') ? 'signal-buy' : squeeze.signal.includes('bear') ? 'signal-sell' : 'signal-neutral');
        squeezeSignal.innerText = squeeze.squeezeOn ? 'BUILDING' : squeeze.signal.includes('bull') ? 'BULLISH' : squeeze.signal.includes('bear') ? 'BEARISH' : 'NEUTRAL';
      }
      
      // Supertrend
      const strendValue = document.getElementById('strendValue');
      const strendSignal = document.getElementById('strendSignal');
      if (strendValue && strendSignal && supertrend) {
        strendValue.innerText = supertrend.value.toFixed(4);
        strendSignal.className = 'indicator-signal ' + (supertrend.trend === 'bullish' ? 'signal-buy' : 'signal-sell');
        strendSignal.innerText = supertrend.trend.toUpperCase();
      }
      
      // Chaikin Money Flow
      const cmfValue = document.getElementById('cmfValue');
      const cmfSignal = document.getElementById('cmfSignal');
      if (cmfValue && cmfSignal && cmf !== null) {
        cmfValue.innerText = (cmf * 100).toFixed(1) + '%';
        cmfSignal.className = 'indicator-signal ' + (cmf > 0.05 ? 'signal-buy' : cmf < -0.05 ? 'signal-sell' : 'signal-neutral');
        cmfSignal.innerText = cmf > 0.05 ? 'INFLOW' : cmf < -0.05 ? 'OUTFLOW' : 'NEUTRAL';
      }
      
      // ==========================================
      // üéØ TRADING SIGNAL BOX (Entry/SL/TP)
      // ==========================================
      
      const tradingSignalBox = document.getElementById('tradingSignalBox');
      const godModeConfluence = confluence.confluenceCount + mtfAnalysis.confluence;
      
      // Generate trading signal if conditions met
      if (signalQuality >= 65 && godModeConfluence >= 6 && tradingSignalBox) {
        const tradingSignal = generateTradingSignal(currentPrice, atr, probability.bullish > 50 ? probability.bullish : probability.bearish, regime.regime, { confluence: godModeConfluence });
        
        if (tradingSignal) {
          tradingSignalBox.style.display = 'block';
          
          const dirEl = document.getElementById('signalDirection');
          const entryEl = document.getElementById('signalEntry');
          const slEl = document.getElementById('signalSL');
          const tp1El = document.getElementById('signalTP1');
          const tp2El = document.getElementById('signalTP2');
          const rrEl = document.getElementById('signalRR');
          const riskEl = document.getElementById('signalRisk');
          const rewardEl = document.getElementById('signalReward');
          const winRateEl = document.getElementById('signalWinRate');
          
          if (dirEl) {
            dirEl.innerText = tradingSignal.direction === 'LONG' ? 'üéØ LONG SIGNAL' : 'üéØ SHORT SIGNAL';
            dirEl.style.color = tradingSignal.direction === 'LONG' ? 'var(--accent-green)' : 'var(--accent-red)';
            tradingSignalBox.style.borderColor = tradingSignal.direction === 'LONG' ? 'rgba(0,255,136,0.3)' : 'rgba(255,68,102,0.3)';
          }
          if (entryEl) entryEl.innerText = '$' + tradingSignal.entry.toFixed(4);
          if (slEl) slEl.innerText = '$' + tradingSignal.stopLoss.toFixed(4);
          if (tp1El) tp1El.innerText = '$' + tradingSignal.tp1.toFixed(4);
          if (tp2El) tp2El.innerText = '$' + tradingSignal.tp2.toFixed(4);
          if (rrEl) rrEl.innerText = 'R:R 1:' + tradingSignal.riskReward.toFixed(1);
          if (riskEl) riskEl.innerText = '-' + tradingSignal.risk.toFixed(2) + '%';
          if (rewardEl) rewardEl.innerText = '+' + tradingSignal.reward.toFixed(2) + '%';
          if (winRateEl) winRateEl.innerText = tradingSignal.estimatedWinRate.toFixed(0) + '%';
        }
      } else if (tradingSignalBox) {
        tradingSignalBox.style.display = 'none';
      }

      // Update S/R and Fibonacci on chart
      updateSROnChart();
      updateFibonacciLevels();

      // Alert and log high-quality signals
      if (signalQuality >= 70 && probability.confidence >= 55) {
        const direction = probability.bullish > 50 ? 'BULL' : 'BEAR';
        const alertType = probability.bullish > 50 ? 'bullish' : 'bearish';
        const prob = probability.bullish > 50 ? probability.bullish : probability.bearish;
        
        // Log signal to history
        logSignal(direction, prob, signalQuality, currentPrice, regime.regime);
        
        // Only alert on very high quality signals
        if (signalQuality >= 75 && probability.confidence >= 60) {
          addAlert(`üéØ HIGH QUALITY ${direction} SIGNAL: ${prob.toFixed(0)}% prob, ${signalQuality.toFixed(0)}% quality`, alertType);
          
          // üéôÔ∏è AI Voice Alert
          const voiceText = generateSignalVoiceText(direction, prob, signalQuality, regime.regime);
          speakAlert(voiceText, 'high');
        }
      }
      
      // Update Paper Trading UI
      updatePaperTradingUI();
      
      // Update AI Narrator
      updateNarratorUI();
    }

    // ============================================
    // API CALLS
    // ============================================

    async function fetchFearGreed() {
      try {
        const response = await fetch('https://api.alternative.me/fng/?limit=1');
        const data = await response.json();
        if (data?.data?.[0]) {
          const fng = data.data[0];
          ui.fg.innerText = fng.value;
          ui.fgLabel.innerText = fng.value_classification;
          const val = parseInt(fng.value);
          ui.fg.style.color = val <= 25 ? 'var(--accent-red)' : val <= 45 ? 'var(--accent-orange)' : val <= 55 ? 'var(--text-main)' : val <= 75 ? '#90EE90' : 'var(--accent-green)';
        }
      } catch (err) {
        console.error('Fear & Greed error:', err);
      }
    }

    async function fetchDerivativesData() {
      try {
        // Funding Rate
        const fundingRes = await fetch('https://fapi.binance.com/fapi/v1/fundingRate?symbol=XRPUSDT&limit=1');
        const fundingData = await fundingRes.json();
        if (fundingData?.[0]) {
          const rate = parseFloat(fundingData[0].fundingRate) * 100;
          ui.fundingRate.innerText = rate.toFixed(4) + '%';
          ui.fundingRate.style.color = rate > 0 ? 'var(--accent-green)' : 'var(--accent-red)';
          
          if (Math.abs(rate) > 0.1) {
            addAlert(`High Funding Rate: ${rate.toFixed(4)}% - ${rate > 0 ? 'Longs paying shorts' : 'Shorts paying longs'}`, rate > 0 ? 'warning' : 'info');
          }
        }

        // Open Interest
        const oiRes = await fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=XRPUSDT');
        const oiData = await oiRes.json();
        if (oiData?.openInterest) {
          const oi = parseFloat(oiData.openInterest);
          ui.openInterest.innerText = (oi / 1000000).toFixed(1) + 'M';
        }

        // Long/Short Ratio
        const lsRes = await fetch('https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=XRPUSDT&period=5m&limit=1');
        const lsData = await lsRes.json();
        if (lsData?.[0]) {
          const ratio = parseFloat(lsData[0].longShortRatio);
          document.getElementById('lsValue').innerText = ratio.toFixed(2);
          
          const lsEl = document.getElementById('lsSignal');
          if (ratio > 1.5) {
            lsEl.className = 'indicator-signal signal-warning'; lsEl.innerText = 'CROWDED LONG';
          } else if (ratio < 0.7) {
            lsEl.className = 'indicator-signal signal-warning'; lsEl.innerText = 'CROWDED SHORT';
          } else if (ratio > 1) {
            lsEl.className = 'indicator-signal signal-buy'; lsEl.innerText = 'LONG BIAS';
          } else {
            lsEl.className = 'indicator-signal signal-sell'; lsEl.innerText = 'SHORT BIAS';
          }
        }

      } catch (err) {
        console.error('Derivatives fetch error:', err);
      }
    }

    async function fetchBTCPrice() {
      try {
        const res = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');
        const data = await res.json();
        if (data?.price) {
          state.btcPrice = parseFloat(data.price);
          ui.btcPrice.innerText = '$' + (state.btcPrice / 1000).toFixed(1) + 'K';
        }
      } catch (err) {
        console.error('BTC price error:', err);
      }
    }

    async function fetchHistoricalData() {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=${state.currentTimeframe}&limit=100`);
        const data = await response.json();
        
        state.candles = data.map(k => ({
          time: k[0] / 1000,
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
        
        if (candleSeries) candleSeries.setData(state.candles);
        
        // Actualizar EMAs y l√≠neas de tendencia
        updateEMAs();
        updateTrendLines();
        
        if (state.candles.length > 0) {
          state.currentPrice = state.candles[state.candles.length - 1].close;
          runPredictionEngine(state.currentPrice);
        }
        
        // Ajustar zoom inicial - mostrar √∫ltimas 50 velas para mejor visibilidad
        if (chart && state.candles.length > 0) {
          const visibleBars = Math.min(50, state.candles.length);
          chart.timeScale().setVisibleLogicalRange({
            from: state.candles.length - visibleBars,
            to: state.candles.length
          });
        }
        
        console.log(`Historical data loaded (${state.currentTimeframe}):`, state.candles.length, 'candles');
      } catch (err) {
        console.error('Historical fetch error:', err);
      }
    }

    // ============================================
    // WEBSOCKET
    // ============================================

    let ws;

    function getWsUrl() {
      return `wss://stream.binance.com:9443/stream?streams=xrpusdt@kline_${state.currentTimeframe}/xrpusdt@depth20@100ms/xrpusdt@ticker/xrpusdt@aggTrade`;
    }

    function connectAPI() {
      ui.statusText.innerText = 'CONNECTING...';
      ui.statusPill.className = 'status-pill';
      
      const wsUrl = getWsUrl();
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        ui.statusText.innerText = 'LIVE';
        ui.statusPill.classList.add('status-live');
        addAlert('System connected to Binance streams', 'info');
      };

      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        const data = msg.data;
        const stream = msg.stream;

        if (stream.includes('kline') && candleSeries) {
          const k = data.k;
          const candle = {
            time: k.t / 1000,
            open: parseFloat(k.o),
            high: parseFloat(k.h),
            low: parseFloat(k.l),
            close: parseFloat(k.c),
            volume: parseFloat(k.v)
          };
          
          candleSeries.update(candle);

          if (k.x) {
            state.candles.push(candle);
            if (state.candles.length > CONFIG.HISTORY_SIZE) state.candles.shift();
            runPredictionEngine(candle.close);
            // Actualizar EMAs y l√≠neas de tendencia cuando se cierra una vela
            updateEMAs();
            updateTrendLines();
          }
        }

        if (stream.includes('ticker')) {
          const price = parseFloat(data.c);
          const change = parseFloat(data.P);
          const volume = parseFloat(data.q);

          state.currentPrice = price;
          state.price = price; // Mantener ambos para compatibilidad

          perf.latestTicker = { price, change, volume, ts: _now() };
          perf.tickerDirty = true;

          // Ejecutar el motor de predicci√≥n con limitaci√≥n temporal (evita hacerlo por cada tick)
          const now = _now();
          if (state.candles.length > 0 && (now - perf.lastPredictionRun) >= PERF.PREDICTION_MIN_MS) {
            perf.lastPredictionRun = now;
            runPredictionEngine(price);
          }

          scheduleUIFlush();
        }

        if (stream.includes('depth')) {
          // Spoof detection (limitado temporalmente para no quemar CPU)
          const now = _now();
          if ((now - perf.lastSpoofCheck) >= PERF.SPOOF_CHECK_MIN_MS) {
            perf.lastSpoofCheck = now;

            const spoofDetected = detectSpoofing(data.bids, data.asks);
            ui.spoofWarning.style.display = spoofDetected ? 'inline' : 'none';

            // Alertar solo en transiciones y con cooldown
            if (spoofDetected && (!perf.spoofLastState) && (now - perf.lastSpoofAlert) >= PERF.SPOOF_ALERT_COOLDOWN_MS) {
              perf.lastSpoofAlert = now;
              addAlert('Potential SPOOFING detected in order book!', 'warning');
            }
            perf.spoofLastState = spoofDetected;
          }

          // Coalescing de actualizaciones del order book
          perf.latestDepth = { bids: data.bids, asks: data.asks, ts: now };
          perf.depthDirty = true;
          scheduleOrderBookFlush();
        }

        if (stream.includes('aggtrade') || stream.includes('aggTrade')) {
          const qty = parseFloat(data.q);
          const price = parseFloat(data.p);
          const isBuy = !data.m;

          state.cvd += isBuy ? qty : -qty;
          perf.cvdDirty = true;

          if (qty >= CONFIG.WHALE_THRESHOLD) {
            addWhaleAlert(qty, price, isBuy, 'BINANCE');
            if (isBuy) state.whaleBuyVol += qty;
            else state.whaleSellVol += qty;
          }

          scheduleUIFlush();
        }
      };

      ws.onerror = () => {
        ui.statusText.innerText = 'ERROR';
        ui.statusPill.classList.add('status-err');
      };

      ws.onclose = () => {
        ui.statusText.innerText = 'RECONNECTING...';
        ui.statusPill.classList.remove('status-live');
        setTimeout(connectAPI, 3000);
      };
    }

    
function initOrderBookDOM() {
      if (ui._obInited) return;
      ui._obInited = true;

      // Cache OB elements
      ui.obValue = document.getElementById('obValue');
      ui.obSignal = document.getElementById('obSignal');

      // Pre-crear 7 filas para ASK y 7 para BID (evita innerHTML por tick)
      const makeRow = (cls) => {
        const row = document.createElement('div');
        row.className = `ob-row ${cls}`;
        const spPrice = document.createElement('span');
        const spVol = document.createElement('span');
        row.appendChild(spPrice);
        row.appendChild(spVol);
        return { row, spPrice, spVol };
      };

      ui._askRows = [];
      ui._bidRows = [];

      ui.asks.innerHTML = '';
      ui.bids.innerHTML = '';

      for (let i = 0; i < 7; i++) {
        const r = makeRow('ob-ask');
        ui.asks.appendChild(r.row);
        ui._askRows.push(r);
      }

      for (let i = 0; i < 7; i++) {
        const r = makeRow('ob-bid');
        ui.bids.appendChild(r.row);
        ui._bidRows.push(r);
      }

      // Pre-crear 2 indicadores de wall (evita crear nodos en cada update)
      ui._wallItems = [];
      if (ui.wallDetection) {
        ui.wallDetection.innerHTML = '';
        for (let i = 0; i < 2; i++) {
          const div = document.createElement('div');
          div.className = 'wall-indicator';
          const sp = document.createElement('span');
          div.appendChild(sp);
          const txt = document.createTextNode('');
          div.appendChild(txt);
          ui.wallDetection.appendChild(div);
          ui._wallItems.push({ div, sp, txt });
        }
      }
    }

    function updateOrderBook(bids, asks) {
      initOrderBookDOM();

      let totalBidVol = 0, totalAskVol = 0;
      const walls = [];

      // ASKS: mostrar las 7 primeras en orden inverso
      const aCount = Math.min(7, asks.length);
      for (let i = 0; i < 7; i++) {
        const rowObj = ui._askRows[i];
        const srcIdx = (aCount - 1) - i;
        if (srcIdx >= 0) {
          const price = parseFloat(asks[srcIdx][0]);
          const vol = parseFloat(asks[srcIdx][1]);
          totalAskVol += vol;
          if (vol >= CONFIG.WALL_THRESHOLD) walls.push({ type: 'SELL', price, vol });

          rowObj.spPrice.textContent = price.toFixed(4);
          rowObj.spVol.textContent = (vol / 1000).toFixed(1) + 'K';
          rowObj.row.style.background = (vol >= CONFIG.WALL_THRESHOLD) ? 'rgba(255,68,102,0.15)' : '';
          rowObj.row.style.display = '';
        } else {
          rowObj.row.style.display = 'none';
        }
      }

      // BIDS: mostrar las 7 primeras
      const bCount = Math.min(7, bids.length);
      for (let i = 0; i < 7; i++) {
        const rowObj = ui._bidRows[i];
        if (i < bCount) {
          const price = parseFloat(bids[i][0]);
          const vol = parseFloat(bids[i][1]);
          totalBidVol += vol;
          if (vol >= CONFIG.WALL_THRESHOLD) walls.push({ type: 'BUY', price, vol });

          rowObj.spPrice.textContent = price.toFixed(4);
          rowObj.spVol.textContent = (vol / 1000).toFixed(1) + 'K';
          rowObj.row.style.background = (vol >= CONFIG.WALL_THRESHOLD) ? 'rgba(0,255,136,0.15)' : '';
          rowObj.row.style.display = '';
        } else {
          rowObj.row.style.display = 'none';
        }
      }

      // Liquidity bars + signal
      const total = totalBidVol + totalAskVol;
      if (total > 0) {
        const bidPct = (totalBidVol / total) * 100;
        ui.liqBarBid.style.width = bidPct + '%';
        ui.liqBarAsk.style.width = (100 - bidPct) + '%';

        const dominant = bidPct > 55 ? 'BULLS' : (bidPct < 45 ? 'BEARS' : 'BALANCED');
        const domColor = bidPct > 55 ? 'c-green' : (bidPct < 45 ? 'c-red' : '');
        ui.liqText.innerHTML = `<span class="${domColor}"><strong>${dominant}</strong></span> ${bidPct.toFixed(0)}% / ${(100 - bidPct).toFixed(0)}%`;

        const imbalance = ((totalBidVol - totalAskVol) / total) * 100;
        if (ui.obValue) ui.obValue.innerText = imbalance.toFixed(1) + '%';

        if (ui.obSignal) {
          if (imbalance > 15) {
            ui.obSignal.className = 'indicator-signal signal-buy'; ui.obSignal.innerText = 'BUY WALL';
          } else if (imbalance < -15) {
            ui.obSignal.className = 'indicator-signal signal-sell'; ui.obSignal.innerText = 'SELL WALL';
          } else {
            ui.obSignal.className = 'indicator-signal signal-neutral'; ui.obSignal.innerText = 'BALANCED';
          }
        }
      }

      // Wall detection (solo 2 items, sin reconstruir el DOM)
      if (ui._wallItems && ui._wallItems.length) {
        for (let i = 0; i < ui._wallItems.length; i++) {
          const item = ui._wallItems[i];
          const wall = walls[i];
          if (!wall) {
            item.div.style.display = 'none';
            continue;
          }
          item.div.style.display = '';
          item.sp.className = (wall.type === 'BUY') ? 'c-green' : 'c-red';
          item.sp.textContent = wall.type;
          item.txt.nodeValue = ` @ ${wall.price.toFixed(4)} (${(wall.vol / 1000).toFixed(0)}K)`;
        }
      }
    }

function addWhaleAlert(qty, price, isBuy, exchange = 'BINANCE') {
      state.whaleCount++;
      ui.whaleCount.innerText = state.whaleCount;
      
      // Limpiar mensaje inicial si es el primer whale
      if (state.whaleCount === 1) {
        ui.whaleList.innerHTML = '';
      }
      
      const div = document.createElement('div');
      div.className = `whale-item ${isBuy ? 'buy' : 'sell'}`;
      
      const time = new Date().toLocaleTimeString();
      const value = (qty * price / 1000).toFixed(1);
      
      // Colores por exchange
      const exchangeColors = {
        'BINANCE': { bg: 'rgba(243,186,47,0.2)', color: '#f3ba2f' },
        'KRAKEN': { bg: 'rgba(113,84,255,0.2)', color: '#7154ff' },
        'BITSTAMP': { bg: 'rgba(57,181,74,0.2)', color: '#39b54a' },
        'BYBIT': { bg: 'rgba(247,147,26,0.2)', color: '#f7931a' },
        'COINBASE': { bg: 'rgba(0,82,255,0.2)', color: '#0052ff' },
        'CRYPTO.COM': { bg: 'rgba(17,60,92,0.3)', color: '#00b4e6' },
        'OKX': { bg: 'rgba(0,0,0,0.3)', color: '#ffffff' }
      };
      
      const exColor = exchangeColors[exchange] || exchangeColors['BINANCE'];
      
      div.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; width:100%;">
          <span>
            <span class="${isBuy ? 'c-green' : 'c-red'}">‚óè ${isBuy ? 'BUY' : 'SELL'}</span>
            <strong>${(qty/1000).toFixed(1)}K</strong>
          </span>
          <span style="font-size:8px; background:${exColor.bg}; color:${exColor.color}; padding:1px 4px; border-radius:2px; font-weight:600;">${exchange}</span>
          <span style="color:var(--text-dim); font-size:9px;">${value}K$ ${time}</span>
        </div>
      `;
      
      ui.whaleList.prepend(div);
      
      // Alert for big whales (>25K ahora que el threshold base es 5K)
      if (qty >= 25000) {
        addAlert(`üêã BIG WHALE: ${isBuy ? 'BUY' : 'SELL'} ${(qty/1000).toFixed(0)}K XRP ($${value}K) on ${exchange}`, isBuy ? 'bullish' : 'bearish');
        if (state.soundEnabled) playSound('whale');
      }
      
      // Check smart whale alerts
      if (typeof checkWhaleAlerts === 'function') {
        checkWhaleAlerts(isBuy ? 'BUY' : 'SELL', qty, price);
      }
      
      while (ui.whaleList.children.length > 15) {
        ui.whaleList.lastChild.remove();
      }
    }

    // ============================================
    // INIT
    // ============================================

    window.addEventListener('DOMContentLoaded', () => {
      console.log('ORACULUM OkrtSystem Labs - INITIALIZING...');
      
      // Clock
      setInterval(() => {
        ui.clock.innerText = new Date().toLocaleTimeString();
      }, 1000);
      
      // Timeframe selector
      const tfSelect = document.getElementById('timeframeSelect');
      if (tfSelect) {
        tfSelect.addEventListener('change', (e) => {
          changeTimeframe(e.target.value);
        });
      }
      
      // Initialize voice language selector
      const langSelect = document.getElementById('voiceLangSelect');
      if (langSelect) {
        const savedLang = localStorage.getItem('oraculum_voice_lang') || 'en';
        langSelect.value = savedLang;
        voiceState.lang = savedLang;
      }
      
      // Initialize audio context on first user interaction
      document.body.addEventListener('click', () => {
        initAudio();
      }, { once: true });
      
      setTimeout(() => {
        initChart();
        connectAPI();
        fetchHistoricalData();
        fetchFearGreed();
        fetchDerivativesData();
        fetchBTCPrice();
        updatePredictionHistoryChart();
        updateSessionDisplay(); // Session detector
        updatePaperTradingUI(); // Paper Trading
      }, 100);
      
      // Periodic updates
      setInterval(fetchFearGreed, 300000);
      setInterval(fetchDerivativesData, 60000);
      setInterval(fetchBTCPrice, 30000);
      
      // Reset CVD and whale flow hourly
      setInterval(() => {
        state.cvd = 0;
        state.whaleBuyVol = 0;
        state.whaleSellVol = 0;
        addAlert('Hourly reset: CVD and Whale Flow counters cleared', 'info');
      }, 3600000);

      // Cargar alertas guardadas
      loadCustomAlerts();
      
      // Actualizar Multi-TF cada 30 segundos
      setInterval(updateMultiTimeframe, 30000);
      
      // Actualizar l√≠neas de tendencia cada 30 segundos
      setInterval(updateTrendLines, 30000);
      
      // Actualizar S/R y Fibonacci cada 30 segundos
      setInterval(() => {
        updateSROnChart();
        updateFibonacciLevels();
      }, 30000);
      
      // Actualizar Session Display cada minuto
      setInterval(updateSessionDisplay, 60000);
      
      // Verificar resultados de se√±ales cada 5 minutos
      setInterval(verifySignalResults, 300000);
      
      // Conectar a otros exchanges para whale tracking
      connectKraken();
      connectBitstamp();
      connectBybit();
      connectCoinbase();
      connectCryptoCom();
    });

    // ============================================
    // MULTI-EXCHANGE WHALE TRACKING
    // ============================================

    // KRAKEN WebSocket
    let wsKraken;
    function connectKraken() {
      try {
        wsKraken = new WebSocket('wss://ws.kraken.com');
        
        wsKraken.onopen = () => {
          console.log('Kraken WebSocket connected');
          // Suscribirse a trades de XRP/USD
          wsKraken.send(JSON.stringify({
            event: 'subscribe',
            pair: ['XRP/USD'],
            subscription: { name: 'trade' }
          }));
        };
        
        wsKraken.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            // Los trades vienen como array: [channelID, [[price, volume, time, side, orderType, misc]], "trade", "XRP/USD"]
            if (Array.isArray(data) && data[2] === 'trade') {
              const trades = data[1];
              trades.forEach(trade => {
                const price = parseFloat(trade[0]);
                const qty = parseFloat(trade[1]);
                const isBuy = trade[3] === 'b';
                
                if (qty >= CONFIG.WHALE_THRESHOLD) {
                  addWhaleAlert(qty, price, isBuy, 'KRAKEN');
                  if (isBuy) state.whaleBuyVol += qty;
                  else state.whaleSellVol += qty;
                }
              });
            }
          } catch (e) {}
        };
        
        wsKraken.onerror = () => console.log('Kraken WebSocket error');
        wsKraken.onclose = () => setTimeout(connectKraken, 10000);
      } catch (e) {
        console.log('Kraken connection failed');
      }
    }

    // BITSTAMP WebSocket
    let wsBitstamp;
    function connectBitstamp() {
      try {
        wsBitstamp = new WebSocket('wss://ws.bitstamp.net');
        
        wsBitstamp.onopen = () => {
          console.log('Bitstamp WebSocket connected');
          // Suscribirse a live trades de XRP/USD
          wsBitstamp.send(JSON.stringify({
            event: 'bts:subscribe',
            data: { channel: 'live_trades_xrpusd' }
          }));
        };
        
        wsBitstamp.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            if (msg.event === 'trade' && msg.data) {
              const price = parseFloat(msg.data.price);
              const qty = parseFloat(msg.data.amount);
              const isBuy = msg.data.type === 0; // 0 = buy, 1 = sell
              
              if (qty >= CONFIG.WHALE_THRESHOLD) {
                addWhaleAlert(qty, price, isBuy, 'BITSTAMP');
                if (isBuy) state.whaleBuyVol += qty;
                else state.whaleSellVol += qty;
              }
            }
          } catch (e) {}
        };
        
        wsBitstamp.onerror = () => console.log('Bitstamp WebSocket error');
        wsBitstamp.onclose = () => setTimeout(connectBitstamp, 10000);
      } catch (e) {
        console.log('Bitstamp connection failed');
      }
    }

    // BYBIT WebSocket  
    let wsBybit;
    function connectBybit() {
      try {
        wsBybit = new WebSocket('wss://stream.bybit.com/v5/public/spot');
        
        wsBybit.onopen = () => {
          console.log('Bybit WebSocket connected');
          // Suscribirse a trades de XRPUSDT
          wsBybit.send(JSON.stringify({
            op: 'subscribe',
            args: ['publicTrade.XRPUSDT']
          }));
        };
        
        wsBybit.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            if (msg.topic === 'publicTrade.XRPUSDT' && msg.data) {
              msg.data.forEach(trade => {
                const price = parseFloat(trade.p);
                const qty = parseFloat(trade.v);
                const isBuy = trade.S === 'Buy';
                
                if (qty >= CONFIG.WHALE_THRESHOLD) {
                  addWhaleAlert(qty, price, isBuy, 'BYBIT');
                  if (isBuy) state.whaleBuyVol += qty;
                  else state.whaleSellVol += qty;
                }
              });
            }
          } catch (e) {}
        };
        
        wsBybit.onerror = () => console.log('Bybit WebSocket error');
        wsBybit.onclose = () => setTimeout(connectBybit, 10000);
      } catch (e) {
        console.log('Bybit connection failed');
      }
    }

    // COINBASE WebSocket
    let wsCoinbase;
    function connectCoinbase() {
      try {
        wsCoinbase = new WebSocket('wss://ws-feed.exchange.coinbase.com');
        
        wsCoinbase.onopen = () => {
          console.log('Coinbase WebSocket connected');
          // Suscribirse a trades de XRP-USD
          wsCoinbase.send(JSON.stringify({
            type: 'subscribe',
            product_ids: ['XRP-USD'],
            channels: ['matches']
          }));
        };
        
        wsCoinbase.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'match' || data.type === 'last_match') {
              const price = parseFloat(data.price);
              const qty = parseFloat(data.size);
              const isBuy = data.side === 'buy';
              
              if (qty >= CONFIG.WHALE_THRESHOLD) {
                addWhaleAlert(qty, price, isBuy, 'COINBASE');
                if (isBuy) state.whaleBuyVol += qty;
                else state.whaleSellVol += qty;
              }
            }
          } catch (e) {}
        };
        
        wsCoinbase.onerror = () => console.log('Coinbase WebSocket error');
        wsCoinbase.onclose = () => setTimeout(connectCoinbase, 10000);
      } catch (e) {
        console.log('Coinbase connection failed');
      }
    }

    // CRYPTO.COM WebSocket
    let wsCryptoCom;
    function connectCryptoCom() {
      try {
        wsCryptoCom = new WebSocket('wss://stream.crypto.com/v2/market');
        
        wsCryptoCom.onopen = () => {
          console.log('Crypto.com WebSocket connected');
          // Suscribirse a trades de XRP_USD
          wsCryptoCom.send(JSON.stringify({
            id: 1,
            method: 'subscribe',
            params: {
              channels: ['trade.XRP_USD']
            }
          }));
        };
        
        wsCryptoCom.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            if (msg.method === 'subscribe' && msg.result && msg.result.data) {
              msg.result.data.forEach(trade => {
                const price = parseFloat(trade.p);
                const qty = parseFloat(trade.q);
                const isBuy = trade.s === 'BUY';
                
                if (qty >= CONFIG.WHALE_THRESHOLD) {
                  addWhaleAlert(qty, price, isBuy, 'CRYPTO.COM');
                  if (isBuy) state.whaleBuyVol += qty;
                  else state.whaleSellVol += qty;
                }
              });
            }
          } catch (e) {}
        };
        
        wsCryptoCom.onerror = () => console.log('Crypto.com WebSocket error');
        wsCryptoCom.onclose = () => setTimeout(connectCryptoCom, 10000);
      } catch (e) {
        console.log('Crypto.com connection failed');
      }
    }

  </script>

  <!-- ============================================
       TOOLS PANEL OVERLAY
       ============================================ -->
  <div id="toolsOverlay" class="tools-overlay" onclick="closeToolsIfClickOutside(event)">
    <div class="tools-panel" onclick="event.stopPropagation()">
      <div class="tools-header">
        <h2>üõ†Ô∏è TRADING TOOLS</h2>
        <button class="tools-close" onclick="toggleToolsPanel()">√ó</button>
      </div>

      <div class="tools-tabs">
        <button class="tools-tab active" onclick="switchToolTab('mtf')">üìä Multi-TF</button>
        <button class="tools-tab" onclick="switchToolTab('backtest')">‚ö° Backtest</button>
        <button class="tools-tab" onclick="switchToolTab('alerts')">üîî Smart Alerts</button>
        <button class="tools-tab" onclick="switchToolTab('risk')">üéØ Risk Calc</button>
        <button class="tools-tab" onclick="switchToolTab('fibo')">üìê Fibonacci</button>
        <button class="tools-tab" onclick="switchToolTab('session')">üìà Session</button>
        <button class="tools-tab" onclick="switchToolTab('strategy')">ü§ñ Strategy</button>
        <button class="tools-tab" onclick="switchToolTab('corr')">üîó Correlation</button>
      </div>

      <div class="tools-content">
        <!-- MULTI-TIMEFRAME SECTION -->
        <div id="mtfSection" class="tool-section active">
          <div class="mtf-grid" id="mtfGrid">
            <div class="mtf-card" data-tf="1m">
              <div class="mtf-tf">1M</div>
              <div class="mtf-price" id="mtf-price-1m">--</div>
              <div class="mtf-signal neutral" id="mtf-signal-1m">LOADING</div>
              <div class="mtf-indicators">
                <div>RSI: <span class="mtf-rsi" id="mtf-rsi-1m">--</span></div>
                <div>MACD: <span id="mtf-macd-1m">--</span></div>
                <div>Trend: <span id="mtf-trend-1m">--</span></div>
              </div>
            </div>
            <div class="mtf-card" data-tf="5m">
              <div class="mtf-tf">5M</div>
              <div class="mtf-price" id="mtf-price-5m">--</div>
              <div class="mtf-signal neutral" id="mtf-signal-5m">LOADING</div>
              <div class="mtf-indicators">
                <div>RSI: <span class="mtf-rsi" id="mtf-rsi-5m">--</span></div>
                <div>MACD: <span id="mtf-macd-5m">--</span></div>
                <div>Trend: <span id="mtf-trend-5m">--</span></div>
              </div>
            </div>
            <div class="mtf-card" data-tf="15m">
              <div class="mtf-tf">15M</div>
              <div class="mtf-price" id="mtf-price-15m">--</div>
              <div class="mtf-signal neutral" id="mtf-signal-15m">LOADING</div>
              <div class="mtf-indicators">
                <div>RSI: <span class="mtf-rsi" id="mtf-rsi-15m">--</span></div>
                <div>MACD: <span id="mtf-macd-15m">--</span></div>
                <div>Trend: <span id="mtf-trend-15m">--</span></div>
              </div>
            </div>
            <div class="mtf-card" data-tf="1h">
              <div class="mtf-tf">1H</div>
              <div class="mtf-price" id="mtf-price-1h">--</div>
              <div class="mtf-signal neutral" id="mtf-signal-1h">LOADING</div>
              <div class="mtf-indicators">
                <div>RSI: <span class="mtf-rsi" id="mtf-rsi-1h">--</span></div>
                <div>MACD: <span id="mtf-macd-1h">--</span></div>
                <div>Trend: <span id="mtf-trend-1h">--</span></div>
              </div>
            </div>
            <div class="mtf-card" data-tf="4h">
              <div class="mtf-tf">4H</div>
              <div class="mtf-price" id="mtf-price-4h">--</div>
              <div class="mtf-signal neutral" id="mtf-signal-4h">LOADING</div>
              <div class="mtf-indicators">
                <div>RSI: <span class="mtf-rsi" id="mtf-rsi-4h">--</span></div>
                <div>MACD: <span id="mtf-macd-4h">--</span></div>
                <div>Trend: <span id="mtf-trend-4h">--</span></div>
              </div>
            </div>
          </div>
          <div style="margin-top:15px; padding:15px; background:rgba(0,212,255,0.05); border-radius:8px; border:1px solid rgba(0,212,255,0.2);">
            <div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;">üìà MTF CONSENSUS</div>
            <div style="display:flex; justify-content:space-around; text-align:center;">
              <div>
                <div style="font-size:24px; font-weight:bold; color:var(--accent-green);" id="mtf-bullish-count">0</div>
                <div style="font-size:10px; color:var(--text-dim);">BULLISH</div>
              </div>
              <div>
                <div style="font-size:24px; font-weight:bold; color:var(--text-dim);" id="mtf-neutral-count">0</div>
                <div style="font-size:10px; color:var(--text-dim);">NEUTRAL</div>
              </div>
              <div>
                <div style="font-size:24px; font-weight:bold; color:var(--accent-red);" id="mtf-bearish-count">0</div>
                <div style="font-size:10px; color:var(--text-dim);">BEARISH</div>
              </div>
            </div>
            <div style="text-align:center; margin-top:10px; font-size:14px; font-weight:bold;" id="mtf-verdict">ANALYZING...</div>
          </div>
        </div>

        <!-- ‚ö° BACKTESTING ENGINE SECTION -->
        <div id="backtestSection" class="tool-section">
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
            <!-- Backtesting Controls -->
            <div style="background:rgba(0,0,0,0.2); border-radius:10px; padding:15px;">
              <h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">‚öôÔ∏è BACKTEST SETTINGS</h3>
              
              <div class="input-group" style="margin-bottom:12px;">
                <label style="font-size:10px; color:var(--text-dim);">Period (Days)</label>
                <select id="btPeriod" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;">
                  <option value="1">Last 24 Hours</option>
                  <option value="3">Last 3 Days</option>
                  <option value="7" selected>Last 7 Days</option>
                  <option value="14">Last 14 Days</option>
                  <option value="30">Last 30 Days</option>
                </select>
              </div>
              
              <div class="input-group" style="margin-bottom:12px;">
                <label style="font-size:10px; color:var(--text-dim);">Timeframe</label>
                <select id="btTimeframe" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;">
                  <option value="5m">5 Minutes</option>
                  <option value="15m" selected>15 Minutes</option>
                  <option value="1h">1 Hour</option>
                  <option value="4h">4 Hours</option>
                </select>
              </div>
              
              <div class="input-group" style="margin-bottom:12px;">
                <label style="font-size:10px; color:var(--text-dim);">Signal Quality Threshold</label>
                <input type="range" id="btQualityThreshold" min="30" max="90" value="60" style="width:100%;">
                <div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);">
                  <span>Low (30)</span>
                  <span id="btQualityValue">60</span>
                  <span>High (90)</span>
                </div>
              </div>
              
              <div class="input-group" style="margin-bottom:12px;">
                <label style="font-size:10px; color:var(--text-dim);">Probability Threshold (%)</label>
                <input type="range" id="btProbThreshold" min="55" max="85" value="65" style="width:100%;">
                <div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);">
                  <span>55%</span>
                  <span id="btProbValue">65%</span>
                  <span>85%</span>
                </div>
              </div>
              
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
                <div class="input-group">
                  <label style="font-size:10px; color:var(--text-dim);">Take Profit (%)</label>
                  <input type="number" id="btTakeProfit" value="2" step="0.5" min="0.5" max="10" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;">
                </div>
                <div class="input-group">
                  <label style="font-size:10px; color:var(--text-dim);">Stop Loss (%)</label>
                  <input type="number" id="btStopLoss" value="1" step="0.5" min="0.5" max="10" style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:5px; color:#fff;">
                </div>
              </div>
              
              <button onclick="runBacktest()" style="width:100%; padding:12px; background:linear-gradient(135deg, var(--accent-cyan), var(--accent-purple)); border:none; border-radius:8px; color:#fff; font-family:var(--font-tech); font-size:12px; cursor:pointer; font-weight:bold;">
                ‚ö° RUN BACKTEST
              </button>
              
              <div id="btProgress" style="display:none; margin-top:10px;">
                <div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">Processing...</div>
                <div style="height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">
                  <div id="btProgressBar" style="height:100%; width:0%; background:var(--accent-cyan); transition:width 0.3s;"></div>
                </div>
              </div>
            </div>
            
            <!-- Backtesting Results -->
            <div style="background:rgba(0,0,0,0.2); border-radius:10px; padding:15px;">
              <h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-green); margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">üìä RESULTS</h3>
              
              <div id="btResults" style="display:none;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
                  <div style="background:rgba(0,255,136,0.1); padding:12px; border-radius:8px; text-align:center; border:1px solid rgba(0,255,136,0.2);">
                    <div style="font-size:9px; color:var(--accent-green);">WIN RATE</div>
                    <div id="btWinRate" style="font-size:24px; font-weight:bold; color:var(--accent-green);">--%</div>
                  </div>
                  <div style="background:rgba(0,212,255,0.1); padding:12px; border-radius:8px; text-align:center; border:1px solid rgba(0,212,255,0.2);">
                    <div style="font-size:9px; color:var(--accent-cyan);">PROFIT FACTOR</div>
                    <div id="btProfitFactor" style="font-size:24px; font-weight:bold; color:var(--accent-cyan);">--</div>
                  </div>
                </div>
                
                <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; margin-bottom:15px;">
                  <div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px; text-align:center;">
                    <div style="font-size:8px; color:var(--text-dim);">TOTAL TRADES</div>
                    <div id="btTotalTrades" style="font-size:16px; font-weight:bold;">0</div>
                  </div>
                  <div style="background:rgba(0,255,136,0.05); padding:10px; border-radius:6px; text-align:center;">
                    <div style="font-size:8px; color:var(--accent-green);">WINS</div>
                    <div id="btWins" style="font-size:16px; font-weight:bold; color:var(--accent-green);">0</div>
                  </div>
                  <div style="background:rgba(255,68,102,0.05); padding:10px; border-radius:6px; text-align:center;">
                    <div style="font-size:8px; color:var(--accent-red);">LOSSES</div>
                    <div id="btLosses" style="font-size:16px; font-weight:bold; color:var(--accent-red);">0</div>
                  </div>
                </div>
                
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
                  <div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px;">
                    <div style="font-size:8px; color:var(--text-dim);">TOTAL RETURN</div>
                    <div id="btTotalReturn" style="font-size:18px; font-weight:bold;">0%</div>
                  </div>
                  <div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px;">
                    <div style="font-size:8px; color:var(--text-dim);">MAX DRAWDOWN</div>
                    <div id="btMaxDrawdown" style="font-size:18px; font-weight:bold; color:var(--accent-red);">0%</div>
                  </div>
                </div>
                
                <div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px; margin-bottom:15px;">
                  <div style="font-size:8px; color:var(--text-dim); margin-bottom:8px;">EQUITY CURVE</div>
                  <div id="btEquityChart" style="height:80px; display:flex; align-items:flex-end; gap:2px;"></div>
                </div>
                
                <div style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px;">
                  <div style="font-size:8px; color:var(--text-dim); margin-bottom:8px;">TRADE LOG (Last 10)</div>
                  <div id="btTradeLog" style="max-height:100px; overflow-y:auto; font-size:9px;"></div>
                </div>
              </div>
              
              <div id="btNoResults" style="text-align:center; padding:40px 20px; color:var(--text-dim);">
                <div style="font-size:40px; margin-bottom:10px;">üìà</div>
                <div style="font-size:12px;">Configure settings and run backtest</div>
                <div style="font-size:10px; margin-top:5px;">to see AI Engine performance</div>
              </div>
            </div>
          </div>
        </div>

        <!-- RISK CALCULATOR SECTION -->
        <div id="riskSection" class="tool-section">
          <div class="risk-grid">
            <div class="risk-inputs">
              <h3>üìù PARAMETERS</h3>
              <div class="input-group">
                <label>Account Balance (USDT)</label>
                <input type="number" id="riskBalance" value="1000" placeholder="1000">
              </div>
              <div class="input-group">
                <label>Risk per Trade (%)</label>
                <input type="number" id="riskPercent" value="2" step="0.5" placeholder="2">
              </div>
              <div class="input-row">
                <div class="input-group">
                  <label>Entry Price</label>
                  <input type="number" id="riskEntry" step="0.0001" placeholder="Current price">
                </div>
                <div class="input-group">
                  <label>Leverage (1-125x)</label>
                  <input type="number" id="riskLeverage" value="1" min="1" max="125" placeholder="1">
                </div>
              </div>
              <div class="input-row">
                <div class="input-group">
                  <label>Stop Loss Price</label>
                  <input type="number" id="riskSL" step="0.0001" placeholder="SL price">
                </div>
                <div class="input-group">
                  <label>Take Profit Price</label>
                  <input type="number" id="riskTP" step="0.0001" placeholder="TP price">
                </div>
              </div>
              <button class="add-alert-btn" onclick="calculateRisk()" style="margin-top:10px;">
                ‚ö° CALCULATE
              </button>
              <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="control-btn" onclick="setCurrentPriceAsEntry()" style="flex:1; padding:8px;">
                  üìç Use Current Price
                </button>
                <button class="control-btn" onclick="suggestSLTP()" style="flex:1; padding:8px;">
                  üéØ Auto SL/TP
                </button>
              </div>
            </div>

            <div class="risk-results">
              <h3>üìä RESULTS</h3>
              <div class="result-item">
                <span class="result-label">Risk Amount</span>
                <span class="result-value red" id="riskAmount">$0.00</span>
              </div>
              <div class="result-item">
                <span class="result-label">Position Size</span>
                <span class="result-value cyan" id="positionSize">0 XRP</span>
              </div>
              <div class="result-item">
                <span class="result-label">Position Value</span>
                <span class="result-value cyan" id="positionValue">$0.00</span>
              </div>
              <div class="result-item">
                <span class="result-label">Distance to SL</span>
                <span class="result-value red" id="slDistance">0%</span>
              </div>
              <div class="result-item">
                <span class="result-label">Distance to TP</span>
                <span class="result-value green" id="tpDistance">0%</span>
              </div>
              <div class="result-item">
                <span class="result-label">Potential Loss</span>
                <span class="result-value red" id="potentialLoss">-$0.00</span>
              </div>
              <div class="result-item">
                <span class="result-label">Potential Profit</span>
                <span class="result-value green" id="potentialProfit">+$0.00</span>
              </div>
              <div class="result-item">
                <span class="result-label">Liquidation Price</span>
                <span class="result-value red" id="liqPrice">$0.00</span>
              </div>
              <div class="risk-ratio">
                <div class="risk-ratio-value" id="rrRatio">0:0</div>
                <div class="risk-ratio-label">RISK:REWARD RATIO</div>
              </div>
            </div>
          </div>
        </div>

        <!-- üîî SMART ALERTS SECTION -->
        <div id="alertsSection" class="tool-section">
          <div class="alerts-container">
            <div class="alerts-form">
              <h3>‚ûï CREATE SMART ALERT</h3>
              
              <!-- Alert Type Selection -->
              <div style="margin-bottom:15px;">
                <label style="font-size:10px; color:var(--text-dim); display:block; margin-bottom:8px;">Alert Type</label>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                  <button class="alert-type-btn active" id="alertTypePrice" onclick="setSmartAlertType('price')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(0,212,255,0.2); border:1px solid var(--accent-cyan); color:var(--accent-cyan);">
                    üí∞ Price Level
                  </button>
                  <button class="alert-type-btn" id="alertTypeRSI" onclick="setSmartAlertType('rsi')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-dim);">
                    üìä RSI Level
                  </button>
                  <button class="alert-type-btn" id="alertTypeWhale" onclick="setSmartAlertType('whale')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-dim);">
                    üêã Whale Trade
                  </button>
                  <button class="alert-type-btn" id="alertTypeSignal" onclick="setSmartAlertType('signal')" style="padding:8px; font-size:9px; border-radius:5px; cursor:pointer; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-dim);">
                    üéØ AI Signal
                  </button>
                </div>
              </div>
              
              <!-- Price Alert Config -->
              <div id="priceAlertConfig">
                <div class="alert-type-btns" style="margin-bottom:10px;">
                  <button class="alert-type-btn active above" id="alertAboveBtn" onclick="setAlertType('above')" style="flex:1; padding:8px; font-size:10px;">
                    üìà Above
                  </button>
                  <button class="alert-type-btn below" id="alertBelowBtn" onclick="setAlertType('below')" style="flex:1; padding:8px; font-size:10px;">
                    üìâ Below
                  </button>
                </div>
                <div class="input-group">
                  <label>Alert Price (USDT)</label>
                  <input type="number" id="customAlertPrice" step="0.0001" placeholder="Enter price...">
                </div>
              </div>
              
              <!-- RSI Alert Config -->
              <div id="rsiAlertConfig" style="display:none;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px;">
                  <button id="rsiOversoldBtn" onclick="setRSIAlertType('oversold')" class="control-btn active" style="padding:10px; background:rgba(0,255,136,0.2); border-color:var(--accent-green); color:var(--accent-green);">
                    üìâ Oversold (&lt;30)
                  </button>
                  <button id="rsiOverboughtBtn" onclick="setRSIAlertType('overbought')" class="control-btn" style="padding:10px;">
                    üìà Overbought (&gt;70)
                  </button>
                </div>
                <div class="input-group">
                  <label>Custom RSI Level (optional)</label>
                  <input type="number" id="customRSILevel" min="1" max="99" placeholder="e.g., 25 or 75">
                </div>
              </div>
              
              <!-- Whale Alert Config -->
              <div id="whaleAlertConfig" style="display:none;">
                <div class="input-group">
                  <label>Minimum Trade Size (USDT)</label>
                  <input type="number" id="whaleMinSize" value="50000" step="10000" placeholder="50000">
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="whaleBuyAlert" checked> üü¢ Buy Orders
                  </label>
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="whaleSellAlert" checked> üî¥ Sell Orders
                  </label>
                </div>
              </div>
              
              <!-- AI Signal Alert Config -->
              <div id="signalAlertConfig" style="display:none;">
                <div class="input-group">
                  <label>Minimum Signal Quality</label>
                  <input type="range" id="signalQualityMin" min="50" max="95" value="75" style="width:100%;">
                  <div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);">
                    <span>50</span>
                    <span id="signalQualityDisplay">75</span>
                    <span>95</span>
                  </div>
                </div>
                <div class="input-group" style="margin-top:10px;">
                  <label>Minimum Probability</label>
                  <input type="range" id="signalProbMin" min="60" max="90" value="70" style="width:100%;">
                  <div style="display:flex; justify-content:space-between; font-size:9px; color:var(--text-dim);">
                    <span>60%</span>
                    <span id="signalProbDisplay">70%</span>
                    <span>90%</span>
                  </div>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="signalBullAlert" checked> üü¢ Bullish
                  </label>
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="signalBearAlert" checked> üî¥ Bearish
                  </label>
                </div>
              </div>
              
              <div class="input-group" style="margin-top:10px;">
                <label>Note (optional)</label>
                <input type="text" id="customAlertNote" placeholder="e.g., Resistance level" maxlength="50">
              </div>
              
              <!-- Notification Options -->
              <div style="margin:15px 0; padding:10px; background:rgba(255,255,255,0.03); border-radius:6px;">
                <div style="font-size:9px; color:var(--text-dim); margin-bottom:8px;">NOTIFICATION OPTIONS</div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="alertSound" checked> üîä Sound
                  </label>
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="alertVoice"> üéôÔ∏è Voice
                  </label>
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="alertBrowser"> üåê Browser
                  </label>
                  <label style="display:flex; align-items:center; gap:5px; font-size:10px; color:var(--text-dim);">
                    <input type="checkbox" id="alertRepeat"> üîÑ Repeat
                  </label>
                </div>
              </div>
              
              <button class="add-alert-btn" onclick="addSmartAlert()" style="width:100%; padding:12px; background:linear-gradient(135deg, var(--accent-cyan), var(--accent-purple)); border:none; border-radius:8px; color:#fff; font-family:var(--font-tech); cursor:pointer;">
                üîî CREATE ALERT
              </button>
              
              <div style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px;">
                <div style="font-size:10px; color:var(--text-dim); margin-bottom:8px;">QUICK PRICE ALERTS</div>
                <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:6px;">
                  <button class="control-btn" onclick="addQuickAlert(1)" style="font-size:9px; padding:6px;">+1%</button>
                  <button class="control-btn" onclick="addQuickAlert(2)" style="font-size:9px; padding:6px;">+2%</button>
                  <button class="control-btn" onclick="addQuickAlert(5)" style="font-size:9px; padding:6px;">+5%</button>
                  <button class="control-btn" onclick="addQuickAlert(-1)" style="font-size:9px; padding:6px;">-1%</button>
                  <button class="control-btn" onclick="addQuickAlert(-2)" style="font-size:9px; padding:6px;">-2%</button>
                  <button class="control-btn" onclick="addQuickAlert(-5)" style="font-size:9px; padding:6px;">-5%</button>
                </div>
              </div>
            </div>

            <div class="alerts-list-panel">
              <h3>üìã ACTIVE ALERTS <span id="alertsCount" style="opacity:0.5; font-weight:normal;">(0)</span></h3>
              <div class="custom-alerts-list" id="customAlertsList">
                <div class="no-alerts">No alerts configured. Create your first alert!</div>
              </div>
              
              <!-- Alert History -->
              <div style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:15px;">
                <h3 style="font-size:11px; color:var(--text-dim); margin-bottom:10px;">üìú TRIGGERED HISTORY</h3>
                <div id="alertHistory" style="max-height:120px; overflow-y:auto; font-size:9px;">
                  <div style="color:var(--text-dim); text-align:center; padding:10px;">No alerts triggered yet</div>
                </div>
              </div>
              
              <button class="control-btn" onclick="clearAllAlerts()" style="width:100%; margin-top:10px; padding:10px; color:var(--accent-red);">
                üóëÔ∏è Clear All Alerts
              </button>
            </div>
          </div>
        </div>

        <!-- FIBONACCI SECTION -->
        <div id="fiboSection" class="tool-section">
          <div class="fibo-container">
            <div class="fibo-levels">
              <h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);">üìê FIBONACCI RETRACEMENT</h3>
              <div class="fibo-level-row">
                <span class="fibo-label">0% (High)</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:100%; background:var(--accent-green);"></div></div>
                <span class="fibo-price c-green" id="fibo-0">--</span>
              </div>
              <div class="fibo-level-row">
                <span class="fibo-label">23.6%</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:76.4%; background:var(--accent-cyan);"></div></div>
                <span class="fibo-price c-cyan" id="fibo-236">--</span>
              </div>
              <div class="fibo-level-row">
                <span class="fibo-label">38.2%</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:61.8%; background:var(--accent-purple);"></div></div>
                <span class="fibo-price c-purple" id="fibo-382">--</span>
              </div>
              <div class="fibo-level-row">
                <span class="fibo-label">50%</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:50%; background:var(--accent-orange);"></div></div>
                <span class="fibo-price c-orange" id="fibo-50">--</span>
              </div>
              <div class="fibo-level-row">
                <span class="fibo-label">61.8%</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:38.2%; background:var(--accent-yellow);"></div></div>
                <span class="fibo-price" style="color:var(--accent-yellow);" id="fibo-618">--</span>
              </div>
              <div class="fibo-level-row">
                <span class="fibo-label">78.6%</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:21.4%; background:var(--accent-red);"></div></div>
                <span class="fibo-price c-red" id="fibo-786">--</span>
              </div>
              <div class="fibo-level-row">
                <span class="fibo-label">100% (Low)</span>
                <div class="fibo-bar"><div class="fibo-bar-fill" style="width:0%; background:var(--accent-red);"></div></div>
                <span class="fibo-price c-red" id="fibo-100">--</span>
              </div>
              <div style="margin-top:15px; padding:12px; background:rgba(0,212,255,0.05); border-radius:8px; text-align:center;">
                <div style="font-size:10px; color:var(--text-dim);">CURRENT PRICE</div>
                <div style="font-family:var(--font-data); font-size:20px; color:var(--accent-cyan);" id="fibo-current">--</div>
                <div style="font-size:10px; color:var(--text-dim);" id="fibo-zone">--</div>
              </div>
            </div>
            <div class="fibo-info">
              <h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);">‚ÑπÔ∏è SWING DETECTION</h3>
              <div style="margin-bottom:15px;">
                <div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">SWING HIGH (24H)</div>
                <div style="font-family:var(--font-data); font-size:18px; color:var(--accent-green);" id="swing-high">--</div>
              </div>
              <div style="margin-bottom:15px;">
                <div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">SWING LOW (24H)</div>
                <div style="font-family:var(--font-data); font-size:18px; color:var(--accent-red);" id="swing-low">--</div>
              </div>
              <div style="margin-bottom:15px;">
                <div style="font-size:10px; color:var(--text-dim); margin-bottom:5px;">RANGE</div>
                <div style="font-family:var(--font-data); font-size:16px; color:var(--text-main);" id="fibo-range">--</div>
              </div>
              <div style="padding:15px; background:rgba(168,85,247,0.1); border-radius:8px; border:1px solid rgba(168,85,247,0.2);">
                <div style="font-size:11px; font-weight:600; color:var(--accent-purple); margin-bottom:8px;">üí° KEY LEVELS</div>
                <div style="font-size:10px; color:var(--text-dim); line-height:1.6;">
                  <div>‚Ä¢ <strong>38.2% & 61.8%</strong>: Strongest retracement zones</div>
                  <div>‚Ä¢ <strong>50%</strong>: Psychological level</div>
                  <div>‚Ä¢ <strong>78.6%</strong>: Last defense before trend reversal</div>
                </div>
              </div>
              <button class="add-alert-btn" onclick="updateFibonacci()" style="margin-top:15px;">üîÑ Refresh Levels</button>
            </div>
          </div>
        </div>

        <!-- SESSION STATS SECTION -->
        <div id="sessionSection" class="tool-section">
          <div class="session-grid">
            <div class="session-stat">
              <div class="session-stat-value c-cyan" id="session-duration">00:00:00</div>
              <div class="session-stat-label">Session Time</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value" id="session-high">--</div>
              <div class="session-stat-label">Session High</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value" id="session-low">--</div>
              <div class="session-stat-label">Session Low</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value" id="session-range">--</div>
              <div class="session-stat-label">Range %</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value c-green" id="session-signals-bull">0</div>
              <div class="session-stat-label">Bullish Signals</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value c-red" id="session-signals-bear">0</div>
              <div class="session-stat-label">Bearish Signals</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value c-purple" id="session-patterns">0</div>
              <div class="session-stat-label">Patterns Detected</div>
            </div>
            <div class="session-stat">
              <div class="session-stat-value c-orange" id="session-whales">0</div>
              <div class="session-stat-label">Whale Trades</div>
            </div>
          </div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
            <div class="session-timeline">
              <div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;">üìä PRICE ACTION</div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Open Price</span>
                <span id="session-open" style="font-family:var(--font-data);">--</span>
              </div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Current Price</span>
                <span id="session-current" style="font-family:var(--font-data);">--</span>
              </div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Change</span>
                <span id="session-change" style="font-family:var(--font-data);">--</span>
              </div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Volatility (ATR)</span>
                <span id="session-volatility" style="font-family:var(--font-data);">--</span>
              </div>
            </div>
            <div class="session-timeline">
              <div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;">üéØ PREDICTIONS</div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Total Predictions</span>
                <span id="session-predictions" style="font-family:var(--font-data);">0</span>
              </div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Correct</span>
                <span id="session-correct" style="font-family:var(--font-data); color:var(--accent-green);">0</span>
              </div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Incorrect</span>
                <span id="session-incorrect" style="font-family:var(--font-data); color:var(--accent-red);">0</span>
              </div>
              <div class="timeline-row">
                <span style="color:var(--text-dim);">Session Accuracy</span>
                <span id="session-accuracy" style="font-family:var(--font-data); color:var(--accent-cyan);">--%</span>
              </div>
            </div>
          </div>
          <button class="add-alert-btn" onclick="resetSessionStats()" style="margin-top:15px;">üîÑ Reset Session Stats</button>
        </div>

        <!-- STRATEGY BUILDER SECTION -->
        <div id="strategySection" class="tool-section">
          <div class="strategy-container">
            <div class="strategy-builder">
              <h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);">ü§ñ CREATE STRATEGY</h3>
              <div class="input-group">
                <label>Strategy Name</label>
                <input type="text" id="strategyName" placeholder="e.g., RSI Oversold Buy" maxlength="30">
              </div>
              <div style="font-size:10px; color:var(--text-dim); margin:10px 0 5px;">CONDITION 1</div>
              <div class="condition-row">
                <select id="strategy-ind-1">
                  <option value="rsi">RSI</option>
                  <option value="stochRsi">Stoch RSI</option>
                  <option value="macd">MACD</option>
                  <option value="price">Price</option>
                  <option value="volume">Volume 24h</option>
                  <option value="funding">Funding Rate</option>
                </select>
                <select id="strategy-op-1">
                  <option value="<">&lt; Less than</option>
                  <option value=">">&gt; Greater than</option>
                  <option value="cross_up">‚Üó Cross Up</option>
                  <option value="cross_down">‚Üò Cross Down</option>
                </select>
                <input type="number" id="strategy-val-1" placeholder="Value">
              </div>
              <div class="logic-connector">
                <select id="strategy-logic" style="background:rgba(168,85,247,0.2); border-color:var(--accent-purple); color:var(--accent-purple);">
                  <option value="AND">AND</option>
                  <option value="OR">OR</option>
                </select>
              </div>
              <div style="font-size:10px; color:var(--text-dim); margin:5px 0;">CONDITION 2 (optional)</div>
              <div class="condition-row">
                <select id="strategy-ind-2">
                  <option value="">-- None --</option>
                  <option value="rsi">RSI</option>
                  <option value="stochRsi">Stoch RSI</option>
                  <option value="macd">MACD</option>
                  <option value="price">Price</option>
                  <option value="volume">Volume 24h</option>
                  <option value="funding">Funding Rate</option>
                </select>
                <select id="strategy-op-2">
                  <option value="<">&lt; Less than</option>
                  <option value=">">&gt; Greater than</option>
                  <option value="cross_up">‚Üó Cross Up</option>
                  <option value="cross_down">‚Üò Cross Down</option>
                </select>
                <input type="number" id="strategy-val-2" placeholder="Value">
              </div>
              <div class="input-group" style="margin-top:15px;">
                <label>Alert Type</label>
                <select id="strategy-alert-type" style="width:100%; padding:10px;">
                  <option value="bullish">üü¢ Bullish Signal</option>
                  <option value="bearish">üî¥ Bearish Signal</option>
                  <option value="warning">üü† Warning</option>
                </select>
              </div>
              <button class="add-alert-btn" onclick="createStrategy()" style="margin-top:15px;">‚ûï Create Strategy</button>
            </div>
            <div class="strategy-list">
              <h3 style="font-family:var(--font-tech); font-size:12px; color:var(--accent-cyan); margin-bottom:15px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.05);">üìã MY STRATEGIES <span id="strategiesCount" style="opacity:0.5;">(0)</span></h3>
              <div id="strategiesList">
                <div class="no-alerts">No strategies created yet. Build your first strategy!</div>
              </div>
            </div>
          </div>
        </div>

        <!-- CORRELATION SECTION -->
        <div id="corrSection" class="tool-section">
          <div class="corr-grid">
            <div class="corr-card">
              <div class="corr-pair">XRP / BTC</div>
              <div class="corr-value positive" id="corr-btc">0.00</div>
              <div class="corr-label">24H CORRELATION</div>
              <div class="corr-bar"><div class="corr-bar-fill" id="corr-btc-bar" style="width:50%; background:var(--accent-green);"></div></div>
              <div style="margin-top:10px; font-size:10px; color:var(--text-dim);">
                BTC: <span id="corr-btc-price" style="color:var(--accent-cyan);">--</span>
                <span id="corr-btc-change">--</span>
              </div>
            </div>
            <div class="corr-card">
              <div class="corr-pair">XRP / ETH</div>
              <div class="corr-value positive" id="corr-eth">0.00</div>
              <div class="corr-label">24H CORRELATION</div>
              <div class="corr-bar"><div class="corr-bar-fill" id="corr-eth-bar" style="width:50%; background:var(--accent-green);"></div></div>
              <div style="margin-top:10px; font-size:10px; color:var(--text-dim);">
                ETH: <span id="corr-eth-price" style="color:var(--accent-cyan);">--</span>
                <span id="corr-eth-change">--</span>
              </div>
            </div>
            <div class="corr-card">
              <div class="corr-pair">XRP / SOL</div>
              <div class="corr-value positive" id="corr-sol">0.00</div>
              <div class="corr-label">24H CORRELATION</div>
              <div class="corr-bar"><div class="corr-bar-fill" id="corr-sol-bar" style="width:50%; background:var(--accent-green);"></div></div>
              <div style="margin-top:10px; font-size:10px; color:var(--text-dim);">
                SOL: <span id="corr-sol-price" style="color:var(--accent-cyan);">--</span>
                <span id="corr-sol-change">--</span>
              </div>
            </div>
          </div>
          <div style="margin-top:20px; padding:15px; background:rgba(0,212,255,0.05); border-radius:8px; border:1px solid rgba(0,212,255,0.2);">
            <div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;">üìä CORRELATION GUIDE</div>
            <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:15px; text-align:center; font-size:10px;">
              <div>
                <div style="color:var(--accent-green); font-weight:bold;">+0.7 to +1.0</div>
                <div style="color:var(--text-dim);">Strong Positive</div>
                <div style="color:var(--text-dim); font-size:9px;">Move together</div>
              </div>
              <div>
                <div style="color:var(--accent-orange); font-weight:bold;">-0.3 to +0.3</div>
                <div style="color:var(--text-dim);">Weak/None</div>
                <div style="color:var(--text-dim); font-size:9px;">Independent</div>
              </div>
              <div>
                <div style="color:var(--accent-red); font-weight:bold;">-0.7 to -1.0</div>
                <div style="color:var(--text-dim);">Strong Negative</div>
                <div style="color:var(--text-dim); font-size:9px;">Move opposite</div>
              </div>
            </div>
          </div>
          <button class="add-alert-btn" onclick="updateCorrelations()" style="margin-top:15px;">üîÑ Refresh Correlations</button>
        </div>

        <!-- WATCHLIST SECTION -->
        <div id="watchlistSection" class="tool-section">
          <div class="watchlist-grid" id="watchlistGrid">
            <div class="watchlist-card" data-symbol="BTCUSDT">
              <div class="watchlist-icon">‚Çø</div>
              <div class="watchlist-info">
                <div class="watchlist-symbol">BTC</div>
                <div class="watchlist-name">Bitcoin</div>
              </div>
              <div class="watchlist-mini-chart" id="chart-btc"></div>
              <div class="watchlist-price">
                <div class="watchlist-price-value" id="watch-btc-price">--</div>
                <div class="watchlist-change" id="watch-btc-change">--</div>
              </div>
            </div>
            <div class="watchlist-card" data-symbol="ETHUSDT">
              <div class="watchlist-icon">Œû</div>
              <div class="watchlist-info">
                <div class="watchlist-symbol">ETH</div>
                <div class="watchlist-name">Ethereum</div>
              </div>
              <div class="watchlist-mini-chart" id="chart-eth"></div>
              <div class="watchlist-price">
                <div class="watchlist-price-value" id="watch-eth-price">--</div>
                <div class="watchlist-change" id="watch-eth-change">--</div>
              </div>
            </div>
            <div class="watchlist-card" data-symbol="SOLUSDT">
              <div class="watchlist-icon">‚óé</div>
              <div class="watchlist-info">
                <div class="watchlist-symbol">SOL</div>
                <div class="watchlist-name">Solana</div>
              </div>
              <div class="watchlist-mini-chart" id="chart-sol"></div>
              <div class="watchlist-price">
                <div class="watchlist-price-value" id="watch-sol-price">--</div>
                <div class="watchlist-change" id="watch-sol-change">--</div>
              </div>
            </div>
            <div class="watchlist-card" data-symbol="XRPUSDT">
              <div class="watchlist-icon" style="background:rgba(0,212,255,0.2);">‚úï</div>
              <div class="watchlist-info">
                <div class="watchlist-symbol" style="color:var(--accent-cyan);">XRP</div>
                <div class="watchlist-name">Ripple</div>
              </div>
              <div class="watchlist-mini-chart" id="chart-xrp"></div>
              <div class="watchlist-price">
                <div class="watchlist-price-value" id="watch-xrp-price" style="color:var(--accent-cyan);">--</div>
                <div class="watchlist-change" id="watch-xrp-change">--</div>
              </div>
            </div>
            <div class="watchlist-card" data-symbol="ADAUSDT">
              <div class="watchlist-icon">‚Ç≥</div>
              <div class="watchlist-info">
                <div class="watchlist-symbol">ADA</div>
                <div class="watchlist-name">Cardano</div>
              </div>
              <div class="watchlist-mini-chart" id="chart-ada"></div>
              <div class="watchlist-price">
                <div class="watchlist-price-value" id="watch-ada-price">--</div>
                <div class="watchlist-change" id="watch-ada-change">--</div>
              </div>
            </div>
            <div class="watchlist-card" data-symbol="DOGEUSDT">
              <div class="watchlist-icon">√ê</div>
              <div class="watchlist-info">
                <div class="watchlist-symbol">DOGE</div>
                <div class="watchlist-name">Dogecoin</div>
              </div>
              <div class="watchlist-mini-chart" id="chart-doge"></div>
              <div class="watchlist-price">
                <div class="watchlist-price-value" id="watch-doge-price">--</div>
                <div class="watchlist-change" id="watch-doge-change">--</div>
              </div>
            </div>
          </div>
          <div style="margin-top:20px; padding:15px; background:rgba(0,0,0,0.2); border-radius:8px;">
            <div style="font-family:var(--font-tech); font-size:11px; color:var(--accent-cyan); margin-bottom:10px;">üìà MARKET OVERVIEW</div>
            <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:15px; text-align:center;">
              <div>
                <div style="font-size:10px; color:var(--text-dim);">TOTAL MARKET CAP</div>
                <div style="font-family:var(--font-data); font-size:16px; color:var(--text-main);" id="total-mcap">--</div>
              </div>
              <div>
                <div style="font-size:10px; color:var(--text-dim);">BTC DOMINANCE</div>
                <div style="font-family:var(--font-data); font-size:16px; color:var(--accent-orange);" id="btc-dom">--</div>
              </div>
              <div>
                <div style="font-size:10px; color:var(--text-dim);">24H VOLUME</div>
                <div style="font-family:var(--font-data); font-size:16px; color:var(--accent-purple);" id="total-vol">--</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // TOOLS PANEL FUNCTIONALITY
    // ============================================

    // State for tools
    const toolsState = {
      alertType: 'above',
      customAlerts: [],
      mtfData: {}
    };

    // Toggle tools panel
    function toggleToolsPanel() {
      const overlay = document.getElementById('toolsOverlay');
      overlay.classList.toggle('active');
      if (overlay.classList.contains('active')) {
        updateMultiTimeframe();
        setCurrentPriceAsEntry();
      }
    }

    function closeToolsIfClickOutside(e) {
      if (e.target.id === 'toolsOverlay') {
        toggleToolsPanel();
      }
    }

    // Switch between tool tabs
    function switchToolTab(tab) {
      document.querySelectorAll('.tools-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tool-section').forEach(s => s.classList.remove('active'));
      
      document.querySelector(`[onclick="switchToolTab('${tab}')"]`).classList.add('active');
      document.getElementById(tab + 'Section').classList.add('active');
    }

    // ============================================
    // 1. MULTI-TIMEFRAME ANALYSIS
    // ============================================

    async function fetchTimeframeData(tf) {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=${tf}&limit=100`);
        const data = await response.json();
        return data.map(k => ({
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
      } catch (e) {
        console.error('Error fetching ' + tf, e);
        return null;
      }
    }

    function calculateTFIndicators(candles) {
      if (!candles || candles.length < 26) return null;
      
      const closes = candles.map(c => c.close);
      const currentPrice = closes[closes.length - 1];
      
      // RSI
      let gains = 0, losses = 0;
      for (let i = closes.length - 14; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / 14;
      const avgLoss = losses / 14;
      const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
      const rsi = 100 - (100 / (1 + rs));

      // EMA helper
      const ema = (data, period) => {
        const k = 2 / (period + 1);
        let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < data.length; i++) {
          ema = data[i] * k + ema * (1 - k);
        }
        return ema;
      };

      // MACD
      const ema12 = ema(closes, 12);
      const ema26 = ema(closes, 26);
      const macdLine = ema12 - ema26;

      // Trend (EMA 9 vs 21)
      const ema9 = ema(closes, 9);
      const ema21 = ema(closes, 21);
      const trend = ema9 > ema21 ? 'UP' : ema9 < ema21 ? 'DOWN' : 'FLAT';

      // Signal
      let signal = 'NEUTRAL';
      let bullScore = 0, bearScore = 0;
      
      if (rsi < 30) bullScore += 2;
      else if (rsi > 70) bearScore += 2;
      
      if (macdLine > 0) bullScore++;
      else if (macdLine < 0) bearScore++;
      
      if (trend === 'UP') bullScore++;
      else if (trend === 'DOWN') bearScore++;

      if (bullScore >= 3) signal = 'BULLISH';
      else if (bearScore >= 3) signal = 'BEARISH';

      return { price: currentPrice, rsi, macd: macdLine, trend, signal };
    }

    async function updateMultiTimeframe() {
      const timeframes = ['1m', '5m', '15m', '1h', '4h'];
      let bullish = 0, bearish = 0, neutral = 0;

      for (const tf of timeframes) {
        const candles = await fetchTimeframeData(tf);
        const indicators = calculateTFIndicators(candles);
        
        if (indicators) {
          toolsState.mtfData[tf] = indicators;
          
          // Update card
          const card = document.querySelector(`.mtf-card[data-tf="${tf}"]`);
          document.getElementById(`mtf-price-${tf}`).textContent = '$' + indicators.price.toFixed(4);
          
          const signalEl = document.getElementById(`mtf-signal-${tf}`);
          signalEl.textContent = indicators.signal;
          signalEl.className = 'mtf-signal ' + indicators.signal.toLowerCase();
          
          const rsiEl = document.getElementById(`mtf-rsi-${tf}`);
          rsiEl.textContent = indicators.rsi.toFixed(1);
          rsiEl.className = 'mtf-rsi ' + (indicators.rsi < 30 ? 'oversold' : indicators.rsi > 70 ? 'overbought' : 'neutral');
          
          document.getElementById(`mtf-macd-${tf}`).textContent = indicators.macd > 0 ? 'üìà' : indicators.macd < 0 ? 'üìâ' : '‚û°Ô∏è';
          document.getElementById(`mtf-trend-${tf}`).textContent = indicators.trend;

          // Update card border
          card.className = 'mtf-card ' + (indicators.signal === 'BULLISH' ? 'bullish' : indicators.signal === 'BEARISH' ? 'bearish' : '');

          // Count signals
          if (indicators.signal === 'BULLISH') bullish++;
          else if (indicators.signal === 'BEARISH') bearish++;
          else neutral++;
        }
      }

      // Update consensus
      document.getElementById('mtf-bullish-count').textContent = bullish;
      document.getElementById('mtf-neutral-count').textContent = neutral;
      document.getElementById('mtf-bearish-count').textContent = bearish;

      const verdict = document.getElementById('mtf-verdict');
      if (bullish >= 4) {
        verdict.textContent = 'üöÄ STRONG BULLISH';
        verdict.style.color = 'var(--accent-green)';
      } else if (bearish >= 4) {
        verdict.textContent = 'üîª STRONG BEARISH';
        verdict.style.color = 'var(--accent-red)';
      } else if (bullish > bearish) {
        verdict.textContent = 'üìà BULLISH BIAS';
        verdict.style.color = 'var(--accent-green)';
      } else if (bearish > bullish) {
        verdict.textContent = 'üìâ BEARISH BIAS';
        verdict.style.color = 'var(--accent-red)';
      } else {
        verdict.textContent = '‚öñÔ∏è MIXED SIGNALS';
        verdict.style.color = 'var(--accent-orange)';
      }
    }

    // ============================================
    // 2. RISK CALCULATOR
    // ============================================

    function setCurrentPriceAsEntry() {
      const currentPrice = state.price || 0;
      document.getElementById('riskEntry').value = currentPrice.toFixed(4);
    }

    function suggestSLTP() {
      const entry = parseFloat(document.getElementById('riskEntry').value);
      if (!entry) {
        alert('Please set entry price first');
        return;
      }
      // 2% SL, 4% TP (1:2 ratio)
      document.getElementById('riskSL').value = (entry * 0.98).toFixed(4);
      document.getElementById('riskTP').value = (entry * 1.04).toFixed(4);
      calculateRisk();
    }

    function calculateRisk() {
      const balance = parseFloat(document.getElementById('riskBalance').value) || 0;
      const riskPct = parseFloat(document.getElementById('riskPercent').value) || 0;
      const entry = parseFloat(document.getElementById('riskEntry').value) || 0;
      const sl = parseFloat(document.getElementById('riskSL').value) || 0;
      const tp = parseFloat(document.getElementById('riskTP').value) || 0;
      const leverage = parseFloat(document.getElementById('riskLeverage').value) || 1;

      if (!entry || !sl) {
        alert('Please fill Entry and Stop Loss prices');
        return;
      }

      // Calculations
      const riskAmount = balance * (riskPct / 100);
      const slDistancePct = Math.abs((entry - sl) / entry) * 100;
      const tpDistancePct = tp ? Math.abs((tp - entry) / entry) * 100 : 0;
      
      // Position size based on risk
      const positionValue = riskAmount / (slDistancePct / 100);
      const positionSize = positionValue / entry;
      
      // Actual position with leverage
      const leveragedPosition = positionValue * leverage;
      const actualXRP = leveragedPosition / entry;

      // P&L
      const potentialLoss = riskAmount;
      const potentialProfit = tp ? positionValue * (tpDistancePct / 100) : 0;

      // Risk:Reward ratio
      const rr = potentialProfit > 0 ? (potentialProfit / potentialLoss).toFixed(2) : 0;

      // Liquidation price (simplified)
      const liqPrice = entry > sl 
        ? entry * (1 - (1 / leverage) + 0.005) // Long
        : entry * (1 + (1 / leverage) - 0.005); // Short

      // Update UI
      document.getElementById('riskAmount').textContent = '$' + riskAmount.toFixed(2);
      document.getElementById('positionSize').textContent = actualXRP.toFixed(2) + ' XRP';
      document.getElementById('positionValue').textContent = '$' + leveragedPosition.toFixed(2);
      document.getElementById('slDistance').textContent = slDistancePct.toFixed(2) + '%';
      document.getElementById('tpDistance').textContent = tp ? tpDistancePct.toFixed(2) + '%' : '--';
      document.getElementById('potentialLoss').textContent = '-$' + potentialLoss.toFixed(2);
      document.getElementById('potentialProfit').textContent = tp ? '+$' + potentialProfit.toFixed(2) : '--';
      document.getElementById('liqPrice').textContent = leverage > 1 ? '$' + liqPrice.toFixed(4) : 'N/A (Spot)';
      document.getElementById('rrRatio').textContent = '1:' + rr;

      // Color code RR ratio
      const rrEl = document.getElementById('rrRatio');
      if (rr >= 2) rrEl.style.color = 'var(--accent-green)';
      else if (rr >= 1) rrEl.style.color = 'var(--accent-orange)';
      else rrEl.style.color = 'var(--accent-red)';
    }

    // ============================================
    // 3. CUSTOM PRICE ALERTS
    // ============================================

    function setAlertType(type) {
      toolsState.alertType = type;
      document.getElementById('alertAboveBtn').classList.remove('active');
      document.getElementById('alertBelowBtn').classList.remove('active');
      document.getElementById('alert' + type.charAt(0).toUpperCase() + type.slice(1) + 'Btn').classList.add('active');
    }

    function addCustomAlert() {
      const price = parseFloat(document.getElementById('customAlertPrice').value);
      const note = document.getElementById('customAlertNote').value || '';
      
      if (!price) {
        alert('Please enter a valid price');
        return;
      }

      const alert = {
        id: Date.now(),
        price: price,
        type: toolsState.alertType,
        note: note,
        triggered: false,
        createdAt: new Date().toISOString()
      };

      toolsState.customAlerts.push(alert);
      saveCustomAlerts();
      renderCustomAlerts();
      
      document.getElementById('customAlertPrice').value = '';
      document.getElementById('customAlertNote').value = '';
      
      addAlert(`Price alert set: ${toolsState.alertType === 'above' ? 'üìà' : 'üìâ'} $${price.toFixed(4)}`, 'info');
    }

    function addQuickAlert(pct) {
      const currentPrice = state.price || 0;
      if (!currentPrice) return;
      
      const alertPrice = currentPrice * (1 + pct / 100);
      const alert = {
        id: Date.now(),
        price: alertPrice,
        type: pct > 0 ? 'above' : 'below',
        note: `${pct > 0 ? '+' : ''}${pct}% from $${currentPrice.toFixed(4)}`,
        triggered: false,
        createdAt: new Date().toISOString()
      };

      toolsState.customAlerts.push(alert);
      saveCustomAlerts();
      renderCustomAlerts();
      
      addAlert(`Quick alert set: ${pct > 0 ? 'üìà' : 'üìâ'} $${alertPrice.toFixed(4)} (${pct > 0 ? '+' : ''}${pct}%)`, 'info');
    }

    function deleteCustomAlert(id) {
      toolsState.customAlerts = toolsState.customAlerts.filter(a => a.id !== id);
      saveCustomAlerts();
      renderCustomAlerts();
    }

    function clearAllAlerts() {
      if (confirm('Are you sure you want to delete all alerts?')) {
        toolsState.customAlerts = [];
        saveCustomAlerts();
        renderCustomAlerts();
      }
    }

    function renderCustomAlerts() {
      const container = document.getElementById('customAlertsList');
      const activeAlerts = toolsState.customAlerts.filter(a => !a.triggered);
      
      document.getElementById('alertsCount').textContent = `(${activeAlerts.length})`;

      if (activeAlerts.length === 0) {
        container.innerHTML = '<div class="no-alerts">No alerts configured. Create your first alert!</div>';
        return;
      }

      container.innerHTML = activeAlerts
        .sort((a, b) => b.price - a.price)
        .map(alert => `
          <div class="custom-alert-item ${alert.type} ${alert.triggered ? 'triggered' : ''}">
            <div class="alert-info">
              <div class="alert-price">${alert.type === 'above' ? 'üìà' : 'üìâ'} $${alert.price.toFixed(4)}</div>
              <div class="alert-condition">${alert.type === 'above' ? 'When price goes above' : 'When price goes below'}${alert.note ? ' ‚Ä¢ ' + alert.note : ''}</div>
            </div>
            <button class="alert-delete" onclick="deleteCustomAlert(${alert.id})">‚úï</button>
          </div>
        `).join('');
    }

    function checkCustomAlerts(currentPrice) {
      if (!currentPrice || toolsState.customAlerts.length === 0) return;

      toolsState.customAlerts.forEach(alert => {
        if (alert.triggered) return;

        const triggered = (alert.type === 'above' && currentPrice >= alert.price) ||
                         (alert.type === 'below' && currentPrice <= alert.price);

        if (triggered) {
          alert.triggered = true;
          saveCustomAlerts();
          renderCustomAlerts();
          
          // Play sound and add alert
          const msg = `üîî PRICE ALERT: XRP ${alert.type === 'above' ? 'reached' : 'dropped to'} $${alert.price.toFixed(4)}${alert.note ? ' (' + alert.note + ')' : ''}`;
          addAlert(msg, alert.type === 'above' ? 'bullish' : 'bearish');
          
          // Browser notification
          if (Notification.permission === 'granted') {
            new Notification('XRP ORACULUM Alert', { body: msg, icon: 'üîî' });
          }
        }
      });
    }

    function saveCustomAlerts() {
      try {
        localStorage.setItem('xrp_oraculum_alerts', JSON.stringify(toolsState.customAlerts));
      } catch (e) {}
    }

    function loadCustomAlerts() {
      try {
        const saved = localStorage.getItem('xrp_oraculum_alerts');
        if (saved) {
          toolsState.customAlerts = JSON.parse(saved);
          renderCustomAlerts();
        }
      } catch (e) {}
      
      // Request notification permission
      if (Notification.permission === 'default') {
        Notification.requestPermission();
      }
    }

    // Hook into price updates to check alerts
    const originalUpdatePrice = window.updateUI || function(){};
    const checkAlertsInterval = setInterval(() => {
      if (state.price) {
        checkCustomAlerts(state.price);
        checkStrategies();
        checkSmartAlerts(); // NEW: Smart alerts check
      }
    }, 1000);

    // ============================================
    // ‚ö° BACKTESTING ENGINE
    // ============================================
    
    const backtestState = {
      running: false,
      results: null,
      historicalData: []
    };
    
    // UI event listeners for backtest sliders
    document.addEventListener('DOMContentLoaded', () => {
      const qualitySlider = document.getElementById('btQualityThreshold');
      const probSlider = document.getElementById('btProbThreshold');
      
      if (qualitySlider) {
        qualitySlider.addEventListener('input', (e) => {
          document.getElementById('btQualityValue').textContent = e.target.value;
        });
      }
      if (probSlider) {
        probSlider.addEventListener('input', (e) => {
          document.getElementById('btProbValue').textContent = e.target.value + '%';
        });
      }
      
      // Signal alert sliders
      const sigQualSlider = document.getElementById('signalQualityMin');
      const sigProbSlider = document.getElementById('signalProbMin');
      
      if (sigQualSlider) {
        sigQualSlider.addEventListener('input', (e) => {
          document.getElementById('signalQualityDisplay').textContent = e.target.value;
        });
      }
      if (sigProbSlider) {
        sigProbSlider.addEventListener('input', (e) => {
          document.getElementById('signalProbDisplay').textContent = e.target.value + '%';
        });
      }
    });
    
    async function runBacktest() {
      if (backtestState.running) return;
      
      const period = parseInt(document.getElementById('btPeriod').value) || 7;
      const timeframe = document.getElementById('btTimeframe').value || '15m';
      const qualityThreshold = parseInt(document.getElementById('btQualityThreshold').value) || 60;
      const probThreshold = parseInt(document.getElementById('btProbThreshold').value) || 65;
      const takeProfit = parseFloat(document.getElementById('btTakeProfit').value) || 2;
      const stopLoss = parseFloat(document.getElementById('btStopLoss').value) || 1;
      
      backtestState.running = true;
      document.getElementById('btProgress').style.display = 'block';
      document.getElementById('btResults').style.display = 'none';
      document.getElementById('btNoResults').style.display = 'none';
      
      try {
        // Calculate limit based on period and timeframe
        const tfMinutes = { '5m': 5, '15m': 15, '1h': 60, '4h': 240 };
        const minutes = tfMinutes[timeframe] || 15;
        const limit = Math.min(1000, Math.floor((period * 24 * 60) / minutes));
        
        // Fetch historical data
        updateProgress(10);
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=${timeframe}&limit=${limit}`);
        const data = await response.json();
        
        if (!data || data.length < 50) {
          throw new Error('Insufficient data');
        }
        
        updateProgress(30);
        
        // Process candles
        const candles = data.map(k => ({
          time: k[0] / 1000,
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
        
        // Run backtest simulation
        const results = simulateBacktest(candles, qualityThreshold, probThreshold, takeProfit, stopLoss);
        
        updateProgress(90);
        
        // Display results
        displayBacktestResults(results);
        
        updateProgress(100);
        
      } catch (error) {
        console.error('Backtest error:', error);
        addAlert('Backtest failed: ' + error.message, 'warning');
        document.getElementById('btNoResults').style.display = 'block';
      } finally {
        backtestState.running = false;
        setTimeout(() => {
          document.getElementById('btProgress').style.display = 'none';
        }, 500);
      }
    }
    
    function updateProgress(pct) {
      const bar = document.getElementById('btProgressBar');
      if (bar) bar.style.width = pct + '%';
    }
    
    function simulateBacktest(candles, qualityThreshold, probThreshold, tpPct, slPct) {
      const trades = [];
      const equity = [100]; // Start with $100
      let currentEquity = 100;
      let maxEquity = 100;
      let maxDrawdown = 0;
      
      // Need at least 50 candles for indicators
      for (let i = 50; i < candles.length - 1; i++) {
        const slice = candles.slice(0, i + 1);
        const closes = slice.map(c => c.close);
        const currentPrice = slice[slice.length - 1].close;
        
        // Calculate indicators (simplified version of AI Engine)
        const rsi = calcRSI(closes, 14);
        const ema9 = calcEMA(closes, 9);
        const ema21 = calcEMA(closes, 21);
        const macd = calcMACD(closes);
        
        if (!rsi || !ema9 || !ema21) continue;
        
        // Calculate signal quality and probability (simplified)
        let bullPoints = 0, bearPoints = 0;
        
        // RSI signals
        if (rsi < 35) bullPoints += 2;
        else if (rsi > 65) bearPoints += 2;
        
        // EMA trend
        if (ema9 > ema21) bullPoints += 2;
        else bearPoints += 2;
        
        // MACD
        if (macd && macd.histogram > 0) bullPoints += 1;
        else if (macd && macd.histogram < 0) bearPoints += 1;
        
        // Price vs EMAs
        if (currentPrice > ema21) bullPoints += 1;
        else bearPoints += 1;
        
        const totalPoints = bullPoints + bearPoints;
        const probBull = totalPoints > 0 ? (bullPoints / totalPoints * 100) : 50;
        const signalQuality = Math.min(100, (totalPoints * 15) + (Math.abs(rsi - 50)));
        
        // Check if we should take a trade
        const shouldTrade = signalQuality >= qualityThreshold;
        const isBullish = probBull >= probThreshold;
        const isBearish = (100 - probBull) >= probThreshold;
        
        if (shouldTrade && (isBullish || isBearish)) {
          const direction = isBullish ? 'LONG' : 'SHORT';
          const entry = currentPrice;
          
          // Simulate trade outcome using future candles
          let result = simulateTrade(candles.slice(i + 1), entry, direction, tpPct, slPct);
          
          if (result) {
            trades.push({
              index: i,
              time: slice[slice.length - 1].time,
              direction,
              entry,
              exit: result.exit,
              pnl: result.pnl,
              result: result.result
            });
            
            currentEquity *= (1 + result.pnl / 100);
            equity.push(currentEquity);
            
            if (currentEquity > maxEquity) maxEquity = currentEquity;
            const dd = ((maxEquity - currentEquity) / maxEquity) * 100;
            if (dd > maxDrawdown) maxDrawdown = dd;
          }
        }
      }
      
      // Calculate statistics
      const wins = trades.filter(t => t.result === 'WIN').length;
      const losses = trades.filter(t => t.result === 'LOSS').length;
      const totalTrades = trades.length;
      const winRate = totalTrades > 0 ? (wins / totalTrades * 100) : 0;
      
      const grossProfit = trades.filter(t => t.pnl > 0).reduce((a, b) => a + b.pnl, 0);
      const grossLoss = Math.abs(trades.filter(t => t.pnl < 0).reduce((a, b) => a + b.pnl, 0));
      const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss) : grossProfit > 0 ? 999 : 0;
      
      const totalReturn = ((currentEquity - 100) / 100) * 100;
      
      return {
        trades,
        equity,
        totalTrades,
        wins,
        losses,
        winRate,
        profitFactor,
        totalReturn,
        maxDrawdown
      };
    }
    
    function simulateTrade(futureCandles, entry, direction, tpPct, slPct) {
      if (futureCandles.length === 0) return null;
      
      const tp = direction === 'LONG' ? entry * (1 + tpPct / 100) : entry * (1 - tpPct / 100);
      const sl = direction === 'LONG' ? entry * (1 - slPct / 100) : entry * (1 + slPct / 100);
      
      // Max hold 20 candles
      const maxCandles = Math.min(20, futureCandles.length);
      
      for (let i = 0; i < maxCandles; i++) {
        const candle = futureCandles[i];
        
        if (direction === 'LONG') {
          if (candle.high >= tp) return { exit: tp, pnl: tpPct, result: 'WIN' };
          if (candle.low <= sl) return { exit: sl, pnl: -slPct, result: 'LOSS' };
        } else {
          if (candle.low <= tp) return { exit: tp, pnl: tpPct, result: 'WIN' };
          if (candle.high >= sl) return { exit: sl, pnl: -slPct, result: 'LOSS' };
        }
      }
      
      // Exit at last candle if no TP/SL hit
      const lastClose = futureCandles[maxCandles - 1].close;
      const pnl = direction === 'LONG' 
        ? ((lastClose - entry) / entry) * 100 
        : ((entry - lastClose) / entry) * 100;
      
      return { exit: lastClose, pnl, result: pnl > 0 ? 'WIN' : 'LOSS' };
    }
    
    function displayBacktestResults(results) {
      document.getElementById('btResults').style.display = 'block';
      document.getElementById('btNoResults').style.display = 'none';
      
      // Main stats
      document.getElementById('btWinRate').textContent = results.winRate.toFixed(1) + '%';
      document.getElementById('btWinRate').style.color = results.winRate >= 50 ? 'var(--accent-green)' : 'var(--accent-red)';
      
      document.getElementById('btProfitFactor').textContent = results.profitFactor.toFixed(2);
      document.getElementById('btProfitFactor').style.color = results.profitFactor >= 1 ? 'var(--accent-cyan)' : 'var(--accent-red)';
      
      document.getElementById('btTotalTrades').textContent = results.totalTrades;
      document.getElementById('btWins').textContent = results.wins;
      document.getElementById('btLosses').textContent = results.losses;
      
      document.getElementById('btTotalReturn').textContent = (results.totalReturn >= 0 ? '+' : '') + results.totalReturn.toFixed(2) + '%';
      document.getElementById('btTotalReturn').style.color = results.totalReturn >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
      
      document.getElementById('btMaxDrawdown').textContent = '-' + results.maxDrawdown.toFixed(2) + '%';
      
      // Equity curve
      renderEquityCurve(results.equity);
      
      // Trade log
      renderTradeLog(results.trades);
    }
    
    function renderEquityCurve(equity) {
      const container = document.getElementById('btEquityChart');
      if (!equity || equity.length === 0) {
        container.innerHTML = '<div style="color:var(--text-dim);">No data</div>';
        return;
      }
      
      const max = Math.max(...equity);
      const min = Math.min(...equity);
      const range = max - min || 1;
      
      // Sample to max 50 bars
      const step = Math.max(1, Math.floor(equity.length / 50));
      const sampled = equity.filter((_, i) => i % step === 0);
      
      container.innerHTML = sampled.map((val, i) => {
        const height = ((val - min) / range) * 100;
        const color = val >= 100 ? 'var(--accent-green)' : 'var(--accent-red)';
        return `<div style="flex:1; min-width:3px; background:${color}; height:${Math.max(5, height)}%; border-radius:1px;"></div>`;
      }).join('');
    }
    
    function renderTradeLog(trades) {
      const container = document.getElementById('btTradeLog');
      const recent = trades.slice(-10).reverse();
      
      if (recent.length === 0) {
        container.innerHTML = '<div style="color:var(--text-dim); text-align:center;">No trades</div>';
        return;
      }
      
      container.innerHTML = recent.map(t => {
        const time = new Date(t.time * 1000).toLocaleString();
        const color = t.result === 'WIN' ? 'var(--accent-green)' : 'var(--accent-red)';
        return `
          <div style="display:flex; justify-content:space-between; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
            <span>${t.direction === 'LONG' ? 'üü¢' : 'üî¥'} ${t.direction}</span>
            <span>$${t.entry.toFixed(4)}</span>
            <span style="color:${color};">${t.pnl >= 0 ? '+' : ''}${t.pnl.toFixed(2)}%</span>
          </div>
        `;
      }).join('');
    }

    // ============================================
    // üîî SMART ALERTS SYSTEM
    // ============================================
    
    const smartAlertsState = {
      currentType: 'price', // price, rsi, whale, signal
      rsiType: 'oversold',
      alerts: JSON.parse(localStorage.getItem('smart_alerts') || '[]'),
      history: JSON.parse(localStorage.getItem('smart_alerts_history') || '[]'),
      lastChecked: {}
    };
    
    function setSmartAlertType(type) {
      smartAlertsState.currentType = type;
      
      // Update button styles
      ['price', 'rsi', 'whale', 'signal'].forEach(t => {
        const btn = document.getElementById('alertType' + t.charAt(0).toUpperCase() + t.slice(1));
        if (btn) {
          btn.style.background = t === type ? 'rgba(0,212,255,0.2)' : 'rgba(255,255,255,0.05)';
          btn.style.borderColor = t === type ? 'var(--accent-cyan)' : 'rgba(255,255,255,0.1)';
          btn.style.color = t === type ? 'var(--accent-cyan)' : 'var(--text-dim)';
        }
      });
      
      // Show/hide config sections
      document.getElementById('priceAlertConfig').style.display = type === 'price' ? 'block' : 'none';
      document.getElementById('rsiAlertConfig').style.display = type === 'rsi' ? 'block' : 'none';
      document.getElementById('whaleAlertConfig').style.display = type === 'whale' ? 'block' : 'none';
      document.getElementById('signalAlertConfig').style.display = type === 'signal' ? 'block' : 'none';
    }
    
    function setRSIAlertType(type) {
      smartAlertsState.rsiType = type;
      const oversoldBtn = document.getElementById('rsiOversoldBtn');
      const overboughtBtn = document.getElementById('rsiOverboughtBtn');
      
      if (type === 'oversold') {
        oversoldBtn.classList.add('active');
        oversoldBtn.style.background = 'rgba(0,255,136,0.2)';
        oversoldBtn.style.borderColor = 'var(--accent-green)';
        oversoldBtn.style.color = 'var(--accent-green)';
        overboughtBtn.classList.remove('active');
        overboughtBtn.style.background = 'transparent';
        overboughtBtn.style.borderColor = 'rgba(255,255,255,0.1)';
        overboughtBtn.style.color = 'var(--text-dim)';
      } else {
        overboughtBtn.classList.add('active');
        overboughtBtn.style.background = 'rgba(255,68,102,0.2)';
        overboughtBtn.style.borderColor = 'var(--accent-red)';
        overboughtBtn.style.color = 'var(--accent-red)';
        oversoldBtn.classList.remove('active');
        oversoldBtn.style.background = 'transparent';
        oversoldBtn.style.borderColor = 'rgba(255,255,255,0.1)';
        oversoldBtn.style.color = 'var(--text-dim)';
      }
    }
    
    function addSmartAlert() {
      const type = smartAlertsState.currentType;
      const note = document.getElementById('customAlertNote').value || '';
      const options = {
        sound: document.getElementById('alertSound')?.checked ?? true,
        voice: document.getElementById('alertVoice')?.checked ?? false,
        browser: document.getElementById('alertBrowser')?.checked ?? false,
        repeat: document.getElementById('alertRepeat')?.checked ?? false
      };
      
      let alertConfig = {
        id: Date.now(),
        type,
        note,
        options,
        triggered: false,
        triggerCount: 0,
        createdAt: new Date().toISOString()
      };
      
      // Type-specific config
      switch (type) {
        case 'price':
          const price = parseFloat(document.getElementById('customAlertPrice').value);
          if (!price) { addAlert('‚ö†Ô∏è Enter a valid price', 'warning'); return; }
          alertConfig.price = price;
          alertConfig.direction = toolsState.alertType;
          break;
          
        case 'rsi':
          const customRSI = document.getElementById('customRSILevel').value;
          alertConfig.rsiType = smartAlertsState.rsiType;
          alertConfig.rsiLevel = customRSI ? parseFloat(customRSI) : (smartAlertsState.rsiType === 'oversold' ? 30 : 70);
          break;
          
        case 'whale':
          alertConfig.minSize = parseFloat(document.getElementById('whaleMinSize').value) || 50000;
          alertConfig.buyAlert = document.getElementById('whaleBuyAlert')?.checked ?? true;
          alertConfig.sellAlert = document.getElementById('whaleSellAlert')?.checked ?? true;
          break;
          
        case 'signal':
          alertConfig.qualityMin = parseInt(document.getElementById('signalQualityMin').value) || 75;
          alertConfig.probMin = parseInt(document.getElementById('signalProbMin').value) || 70;
          alertConfig.bullAlert = document.getElementById('signalBullAlert')?.checked ?? true;
          alertConfig.bearAlert = document.getElementById('signalBearAlert')?.checked ?? true;
          break;
      }
      
      smartAlertsState.alerts.push(alertConfig);
      saveSmartAlerts();
      renderSmartAlerts();
      
      // Clear form
      if (document.getElementById('customAlertPrice')) document.getElementById('customAlertPrice').value = '';
      if (document.getElementById('customAlertNote')) document.getElementById('customAlertNote').value = '';
      
      addAlert(`‚úÖ Smart alert created: ${getAlertDescription(alertConfig)}`, 'info');
    }
    
    function getAlertDescription(alert) {
      switch (alert.type) {
        case 'price':
          return `${alert.direction === 'above' ? 'üìà' : 'üìâ'} Price ${alert.direction} $${alert.price.toFixed(4)}`;
        case 'rsi':
          return `üìä RSI ${alert.rsiType} ${alert.rsiLevel}`;
        case 'whale':
          return `üêã Whale trade > $${(alert.minSize/1000).toFixed(0)}K`;
        case 'signal':
          return `üéØ AI Signal Q>${alert.qualityMin} P>${alert.probMin}%`;
        default:
          return 'Unknown alert';
      }
    }
    
    function renderSmartAlerts() {
      const container = document.getElementById('customAlertsList');
      const activeAlerts = smartAlertsState.alerts.filter(a => !a.triggered || a.options?.repeat);
      
      // Also update for the original system
      const count = document.getElementById('alertsCount');
      if (count) count.textContent = `(${activeAlerts.length})`;
      
      if (activeAlerts.length === 0) {
        container.innerHTML = '<div class="no-alerts">No alerts configured. Create your first alert!</div>';
        return;
      }
      
      container.innerHTML = activeAlerts.map(alert => {
        const icon = { price: 'üí∞', rsi: 'üìä', whale: 'üêã', signal: 'üéØ' }[alert.type] || 'üîî';
        const desc = getAlertDescription(alert);
        
        return `
          <div class="custom-alert-item" style="display:flex; justify-content:space-between; align-items:center; padding:8px; margin-bottom:6px; background:rgba(255,255,255,0.03); border-radius:6px; border-left:3px solid var(--accent-cyan);">
            <div>
              <div style="font-size:11px; font-weight:bold;">${icon} ${desc}</div>
              <div style="font-size:9px; color:var(--text-dim);">${alert.note || 'No note'} ‚Ä¢ ${alert.options?.repeat ? 'üîÑ' : '1x'}</div>
            </div>
            <button onclick="deleteSmartAlert(${alert.id})" style="background:none; border:none; color:var(--accent-red); cursor:pointer; font-size:14px;">‚úï</button>
          </div>
        `;
      }).join('');
    }
    
    function deleteSmartAlert(id) {
      smartAlertsState.alerts = smartAlertsState.alerts.filter(a => a.id !== id);
      saveSmartAlerts();
      renderSmartAlerts();
    }
    
    function saveSmartAlerts() {
      try {
        localStorage.setItem('smart_alerts', JSON.stringify(smartAlertsState.alerts));
        localStorage.setItem('smart_alerts_history', JSON.stringify(smartAlertsState.history.slice(-50)));
      } catch (e) {}
    }
    
    function checkSmartAlerts() {
      if (smartAlertsState.alerts.length === 0) return;
      
      const currentPrice = state.currentPrice || state.price;
      const currentRSI = state.rsiHistory?.length > 0 ? state.rsiHistory[state.rsiHistory.length - 1] : null;
      
      smartAlertsState.alerts.forEach(alert => {
        if (alert.triggered && !alert.options?.repeat) return;
        
        // Cooldown check (don't trigger same alert within 60s)
        const lastCheck = smartAlertsState.lastChecked[alert.id] || 0;
        if (Date.now() - lastCheck < 60000) return;
        
        let triggered = false;
        let message = '';
        
        switch (alert.type) {
          case 'price':
            if (currentPrice) {
              triggered = (alert.direction === 'above' && currentPrice >= alert.price) ||
                         (alert.direction === 'below' && currentPrice <= alert.price);
              message = `Price ${alert.direction === 'above' ? 'reached' : 'dropped to'} $${currentPrice.toFixed(4)}`;
            }
            break;
            
          case 'rsi':
            if (currentRSI !== null) {
              triggered = (alert.rsiType === 'oversold' && currentRSI <= alert.rsiLevel) ||
                         (alert.rsiType === 'overbought' && currentRSI >= alert.rsiLevel);
              message = `RSI ${alert.rsiType}: ${currentRSI.toFixed(1)}`;
            }
            break;
            
          case 'signal':
            const quality = aiState.signalQuality || 0;
            const prob = Math.max(aiState.probabilityBull || 50, aiState.probabilityBear || 50);
            const isBull = (aiState.probabilityBull || 50) > 50;
            
            if (quality >= alert.qualityMin && prob >= alert.probMin) {
              if ((isBull && alert.bullAlert) || (!isBull && alert.bearAlert)) {
                triggered = true;
                message = `AI Signal: ${isBull ? 'BULL' : 'BEAR'} Q:${quality} P:${prob.toFixed(0)}%`;
              }
            }
            break;
        }
        
        if (triggered) {
          smartAlertsState.lastChecked[alert.id] = Date.now();
          alert.triggered = true;
          alert.triggerCount++;
          
          // Fire the alert
          fireSmartAlert(alert, message);
          
          // Add to history
          smartAlertsState.history.unshift({
            ...alert,
            message,
            triggeredAt: new Date().toISOString()
          });
          
          saveSmartAlerts();
          renderSmartAlerts();
          renderAlertHistory();
        }
      });
    }
    
    function fireSmartAlert(alert, message) {
      const fullMessage = `üîî ${getAlertDescription(alert)}: ${message}`;
      
      // Add to alerts panel
      addAlert(fullMessage, 'info');
      
      // Sound
      if (alert.options?.sound) {
        playSound('alert');
      }
      
      // Voice
      if (alert.options?.voice && voiceState.enabled) {
        speakAlert(fullMessage, 'high');
      }
      
      // Browser notification
      if (alert.options?.browser && Notification.permission === 'granted') {
        new Notification('ORACULUM Alert', { body: message, icon: 'üîî' });
      }
    }
    
    function renderAlertHistory() {
      const container = document.getElementById('alertHistory');
      if (!container) return;
      
      const recent = smartAlertsState.history.slice(0, 10);
      
      if (recent.length === 0) {
        container.innerHTML = '<div style="color:var(--text-dim); text-align:center; padding:10px;">No alerts triggered yet</div>';
        return;
      }
      
      container.innerHTML = recent.map(h => {
        const time = new Date(h.triggeredAt).toLocaleTimeString();
        const icon = { price: 'üí∞', rsi: 'üìä', whale: 'üêã', signal: 'üéØ' }[h.type] || 'üîî';
        return `
          <div style="display:flex; justify-content:space-between; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
            <span>${icon} ${h.message || getAlertDescription(h)}</span>
            <span style="color:var(--text-dim);">${time}</span>
          </div>
        `;
      }).join('');
    }
    
    // Whale alert hook (called from whale tracking system)
    function checkWhaleAlerts(side, amount, price) {
      smartAlertsState.alerts.forEach(alert => {
        if (alert.type !== 'whale') return;
        if (alert.triggered && !alert.options?.repeat) return;
        
        const value = amount * price;
        if (value < alert.minSize) return;
        
        if ((side === 'BUY' && !alert.buyAlert) || (side === 'SELL' && !alert.sellAlert)) return;
        
        const lastCheck = smartAlertsState.lastChecked[alert.id] || 0;
        if (Date.now() - lastCheck < 30000) return; // 30s cooldown for whales
        
        smartAlertsState.lastChecked[alert.id] = Date.now();
        alert.triggered = true;
        alert.triggerCount++;
        
        const message = `üêã Whale ${side}: $${(value/1000).toFixed(0)}K @ $${price.toFixed(4)}`;
        fireSmartAlert(alert, message);
        
        smartAlertsState.history.unshift({
          ...alert,
          message,
          triggeredAt: new Date().toISOString()
        });
        
        saveSmartAlerts();
        renderSmartAlerts();
        renderAlertHistory();
      });
    }
    
    // Initialize smart alerts on load
    setTimeout(() => {
      renderSmartAlerts();
      renderAlertHistory();
    }, 1000);

    // ============================================
    // 4. FIBONACCI AUTO-LEVELS
    // ============================================

    async function updateFibonacci() {
      try {
        // Fetch 24h klines for swing detection
        const response = await fetch('https://api.binance.com/api/v3/klines?symbol=XRPUSDT&interval=1h&limit=24');
        const data = await response.json();
        
        if (!data || data.length === 0) return;

        // Find swing high and low
        let high = 0, low = Infinity;
        data.forEach(k => {
          const h = parseFloat(k[2]);
          const l = parseFloat(k[3]);
          if (h > high) high = h;
          if (l < low) low = l;
        });

        const range = high - low;
        const currentPrice = state.price || parseFloat(data[data.length - 1][4]);

        // Calculate Fibonacci levels
        const levels = {
          '0': high,
          '236': high - (range * 0.236),
          '382': high - (range * 0.382),
          '50': high - (range * 0.5),
          '618': high - (range * 0.618),
          '786': high - (range * 0.786),
          '100': low
        };

        // Update UI
        document.getElementById('fibo-0').textContent = '$' + levels['0'].toFixed(4);
        document.getElementById('fibo-236').textContent = '$' + levels['236'].toFixed(4);
        document.getElementById('fibo-382').textContent = '$' + levels['382'].toFixed(4);
        document.getElementById('fibo-50').textContent = '$' + levels['50'].toFixed(4);
        document.getElementById('fibo-618').textContent = '$' + levels['618'].toFixed(4);
        document.getElementById('fibo-786').textContent = '$' + levels['786'].toFixed(4);
        document.getElementById('fibo-100').textContent = '$' + levels['100'].toFixed(4);
        
        document.getElementById('swing-high').textContent = '$' + high.toFixed(4);
        document.getElementById('swing-low').textContent = '$' + low.toFixed(4);
        document.getElementById('fibo-range').textContent = '$' + range.toFixed(4) + ' (' + ((range/low)*100).toFixed(2) + '%)';
        document.getElementById('fibo-current').textContent = '$' + currentPrice.toFixed(4);

        // Determine zone
        let zone = '';
        if (currentPrice > levels['236']) zone = 'Above 23.6% - Strong bullish zone';
        else if (currentPrice > levels['382']) zone = 'Between 23.6% - 38.2%';
        else if (currentPrice > levels['50']) zone = 'Between 38.2% - 50% - Key support zone';
        else if (currentPrice > levels['618']) zone = 'Between 50% - 61.8% - Critical zone';
        else if (currentPrice > levels['786']) zone = 'Between 61.8% - 78.6% - Danger zone';
        else zone = 'Below 78.6% - Potential reversal';
        
        document.getElementById('fibo-zone').textContent = zone;

      } catch (e) {
        console.error('Fibonacci error:', e);
      }
    }

    // ============================================
    // 5. SESSION STATS
    // ============================================

    const sessionStats = {
      startTime: Date.now(),
      startPrice: null,
      high: 0,
      low: Infinity,
      bullishSignals: 0,
      bearishSignals: 0,
      patternsDetected: 0,
      whaleTrades: 0,
      predictions: 0,
      correct: 0,
      incorrect: 0
    };

    function updateSessionStats() {
      const now = Date.now();
      const elapsed = now - sessionStats.startTime;
      const hours = Math.floor(elapsed / 3600000);
      const mins = Math.floor((elapsed % 3600000) / 60000);
      const secs = Math.floor((elapsed % 60000) / 1000);
      
      document.getElementById('session-duration').textContent = 
        String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');

      if (state.price) {
        if (sessionStats.startPrice === null) sessionStats.startPrice = state.price;
        if (state.price > sessionStats.high) sessionStats.high = state.price;
        if (state.price < sessionStats.low) sessionStats.low = state.price;

        document.getElementById('session-high').textContent = '$' + sessionStats.high.toFixed(4);
        document.getElementById('session-high').style.color = 'var(--accent-green)';
        document.getElementById('session-low').textContent = '$' + sessionStats.low.toFixed(4);
        document.getElementById('session-low').style.color = 'var(--accent-red)';
        
        const range = ((sessionStats.high - sessionStats.low) / sessionStats.low * 100);
        document.getElementById('session-range').textContent = range.toFixed(2) + '%';
        document.getElementById('session-range').style.color = range > 2 ? 'var(--accent-orange)' : 'var(--text-main)';
        
        document.getElementById('session-open').textContent = '$' + sessionStats.startPrice.toFixed(4);
        document.getElementById('session-current').textContent = '$' + state.price.toFixed(4);
        
        const change = ((state.price - sessionStats.startPrice) / sessionStats.startPrice * 100);
        document.getElementById('session-change').textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
        document.getElementById('session-change').style.color = change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
      }

      document.getElementById('session-signals-bull').textContent = sessionStats.bullishSignals;
      document.getElementById('session-signals-bear').textContent = sessionStats.bearishSignals;
      document.getElementById('session-patterns').textContent = sessionStats.patternsDetected;
      document.getElementById('session-whales').textContent = sessionStats.whaleTrades;
      
      document.getElementById('session-predictions').textContent = sessionStats.predictions;
      document.getElementById('session-correct').textContent = sessionStats.correct;
      document.getElementById('session-incorrect').textContent = sessionStats.incorrect;
      
      const accuracy = sessionStats.predictions > 0 ? (sessionStats.correct / sessionStats.predictions * 100) : 0;
      document.getElementById('session-accuracy').textContent = accuracy.toFixed(1) + '%';
    }

    function resetSessionStats() {
      if (confirm('Reset all session statistics?')) {
        sessionStats.startTime = Date.now();
        sessionStats.startPrice = state.price;
        sessionStats.high = state.price || 0;
        sessionStats.low = state.price || Infinity;
        sessionStats.bullishSignals = 0;
        sessionStats.bearishSignals = 0;
        sessionStats.patternsDetected = 0;
        sessionStats.whaleTrades = 0;
        sessionStats.predictions = 0;
        sessionStats.correct = 0;
        sessionStats.incorrect = 0;
        updateSessionStats();
        addAlert('Session stats reset', 'info');
      }
    }

    // Track signals for session
    const originalAddAlert = window.addAlert;
    window.addAlert = function(msg, type) {
      if (type === 'bullish') sessionStats.bullishSignals++;
      if (type === 'bearish') sessionStats.bearishSignals++;
      if (msg.includes('pattern') || msg.includes('Pattern')) sessionStats.patternsDetected++;
      if (msg.includes('Whale') || msg.includes('whale')) sessionStats.whaleTrades++;
      originalAddAlert(msg, type);
    };

    // Update session stats every second
    setInterval(updateSessionStats, 1000);

    // ============================================
    // 6. STRATEGY BUILDER
    // ============================================

    let customStrategies = [];

    function createStrategy() {
      const name = document.getElementById('strategyName').value.trim();
      if (!name) {
        alert('Please enter a strategy name');
        return;
      }

      const ind1 = document.getElementById('strategy-ind-1').value;
      const op1 = document.getElementById('strategy-op-1').value;
      const val1 = document.getElementById('strategy-val-1').value;
      const logic = document.getElementById('strategy-logic').value;
      const ind2 = document.getElementById('strategy-ind-2').value;
      const op2 = document.getElementById('strategy-op-2').value;
      const val2 = document.getElementById('strategy-val-2').value;
      const alertType = document.getElementById('strategy-alert-type').value;

      if (!val1) {
        alert('Please enter a value for condition 1');
        return;
      }

      const strategy = {
        id: Date.now(),
        name: name,
        condition1: { indicator: ind1, operator: op1, value: parseFloat(val1) },
        logic: logic,
        condition2: ind2 ? { indicator: ind2, operator: op2, value: parseFloat(val2) } : null,
        alertType: alertType,
        active: true,
        triggered: false,
        lastTriggered: null
      };

      customStrategies.push(strategy);
      saveStrategies();
      renderStrategies();
      
      // Clear form
      document.getElementById('strategyName').value = '';
      document.getElementById('strategy-val-1').value = '';
      document.getElementById('strategy-val-2').value = '';
      document.getElementById('strategy-ind-2').value = '';
      
      addAlert(`Strategy created: ${name}`, 'info');
    }

    function getIndicatorValue(indicator) {
      switch(indicator) {
        case 'rsi': return state.indicators?.rsi || 50;
        case 'stochRsi': return state.indicators?.stochRsi || 50;
        case 'macd': return state.indicators?.macd || 0;
        case 'price': return state.price || 0;
        case 'volume': return state.volume24h || 0;
        case 'funding': return state.fundingRate || 0;
        default: return 0;
      }
    }

    function evaluateCondition(condition, prevValue) {
      const currentValue = getIndicatorValue(condition.indicator);
      switch(condition.operator) {
        case '<': return currentValue < condition.value;
        case '>': return currentValue > condition.value;
        case 'cross_up': return prevValue < condition.value && currentValue >= condition.value;
        case 'cross_down': return prevValue > condition.value && currentValue <= condition.value;
        default: return false;
      }
    }

    const prevIndicatorValues = {};

    function checkStrategies() {
      customStrategies.forEach(strategy => {
        if (!strategy.active) return;
        
        // Cooldown: don't trigger same strategy within 60 seconds
        if (strategy.lastTriggered && Date.now() - strategy.lastTriggered < 60000) return;

        const cond1Met = evaluateCondition(strategy.condition1, prevIndicatorValues[strategy.condition1.indicator]);
        let result = cond1Met;

        if (strategy.condition2) {
          const cond2Met = evaluateCondition(strategy.condition2, prevIndicatorValues[strategy.condition2.indicator]);
          result = strategy.logic === 'AND' ? (cond1Met && cond2Met) : (cond1Met || cond2Met);
        }

        if (result) {
          strategy.lastTriggered = Date.now();
          const msg = `ü§ñ Strategy "${strategy.name}" triggered!`;
          addAlert(msg, strategy.alertType);
          
          if (Notification.permission === 'granted') {
            new Notification('XRP ORACULUM Strategy', { body: msg });
          }
        }
      });

      // Store previous values for cross detection
      prevIndicatorValues.rsi = state.indicators?.rsi || 50;
      prevIndicatorValues.stochRsi = state.indicators?.stochRsi || 50;
      prevIndicatorValues.macd = state.indicators?.macd || 0;
      prevIndicatorValues.price = state.price || 0;
    }

    function toggleStrategy(id) {
      const strategy = customStrategies.find(s => s.id === id);
      if (strategy) {
        strategy.active = !strategy.active;
        saveStrategies();
        renderStrategies();
      }
    }

    function deleteStrategy(id) {
      customStrategies = customStrategies.filter(s => s.id !== id);
      saveStrategies();
      renderStrategies();
    }

    function renderStrategies() {
      const container = document.getElementById('strategiesList');
      document.getElementById('strategiesCount').textContent = `(${customStrategies.length})`;

      if (customStrategies.length === 0) {
        container.innerHTML = '<div class="no-alerts">No strategies created yet. Build your first strategy!</div>';
        return;
      }

      container.innerHTML = customStrategies.map(s => {
        const cond1Text = `${s.condition1.indicator.toUpperCase()} ${s.condition1.operator} ${s.condition1.value}`;
        const cond2Text = s.condition2 ? ` ${s.logic} ${s.condition2.indicator.toUpperCase()} ${s.condition2.operator} ${s.condition2.value}` : '';
        
        return `
          <div class="strategy-item ${s.active ? 'active' : ''}">
            <div class="strategy-item-header">
              <span class="strategy-item-name">${s.name}</span>
              <div style="display:flex; align-items:center; gap:10px;">
                <div class="strategy-item-toggle ${s.active ? 'active' : ''}" onclick="toggleStrategy(${s.id})"></div>
                <button class="alert-delete" onclick="deleteStrategy(${s.id})">‚úï</button>
              </div>
            </div>
            <div class="strategy-conditions">
              IF ${cond1Text}${cond2Text} ‚Üí ${s.alertType.toUpperCase()} alert
            </div>
          </div>
        `;
      }).join('');
    }

    function saveStrategies() {
      try {
        localStorage.setItem('xrp_oraculum_strategies', JSON.stringify(customStrategies));
      } catch(e) {}
    }

    function loadStrategies() {
      try {
        const saved = localStorage.getItem('xrp_oraculum_strategies');
        if (saved) {
          customStrategies = JSON.parse(saved);
          renderStrategies();
        }
      } catch(e) {}
    }

    // ============================================
    // 7. CORRELATION TRACKER
    // ============================================

    async function updateCorrelations() {
      const pairs = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      const xrpData = await fetchPriceHistory('XRPUSDT');
      
      for (const pair of pairs) {
        const pairData = await fetchPriceHistory(pair);
        if (xrpData && pairData) {
          const corr = calculateCorrelation(xrpData.returns, pairData.returns);
          const symbol = pair.replace('USDT', '').toLowerCase();
          
          const corrEl = document.getElementById(`corr-${symbol}`);
          corrEl.textContent = corr.toFixed(2);
          corrEl.className = 'corr-value ' + (corr > 0.3 ? 'positive' : corr < -0.3 ? 'negative' : 'neutral');
          
          const barEl = document.getElementById(`corr-${symbol}-bar`);
          barEl.style.width = (Math.abs(corr) * 100) + '%';
          barEl.style.background = corr > 0 ? 'var(--accent-green)' : 'var(--accent-red)';
          
          document.getElementById(`corr-${symbol}-price`).textContent = '$' + pairData.price.toFixed(symbol === 'btc' ? 0 : 2);
          const changeEl = document.getElementById(`corr-${symbol}-change`);
          changeEl.textContent = (pairData.change >= 0 ? '+' : '') + pairData.change.toFixed(2) + '%';
          changeEl.style.color = pairData.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
        }
      }
    }

    async function fetchPriceHistory(symbol) {
      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=24`);
        const data = await response.json();
        
        const closes = data.map(k => parseFloat(k[4]));
        const returns = [];
        for (let i = 1; i < closes.length; i++) {
          returns.push((closes[i] - closes[i-1]) / closes[i-1]);
        }
        
        const price = closes[closes.length - 1];
        const change = ((closes[closes.length - 1] - closes[0]) / closes[0]) * 100;
        
        return { returns, price, change };
      } catch(e) {
        return null;
      }
    }

    function calculateCorrelation(arr1, arr2) {
      const n = Math.min(arr1.length, arr2.length);
      if (n === 0) return 0;
      
      const mean1 = arr1.reduce((a, b) => a + b, 0) / n;
      const mean2 = arr2.reduce((a, b) => a + b, 0) / n;
      
      let num = 0, den1 = 0, den2 = 0;
      for (let i = 0; i < n; i++) {
        const d1 = arr1[i] - mean1;
        const d2 = arr2[i] - mean2;
        num += d1 * d2;
        den1 += d1 * d1;
        den2 += d2 * d2;
      }
      
      return den1 && den2 ? num / Math.sqrt(den1 * den2) : 0;
    }

    // ============================================
    // 8. WATCHLIST
    // ============================================

    const watchlistSymbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'DOGEUSDT'];

    const miniChartCache = Object.create(null);
    const MINI_CHART_TTL_MS = 30000; // 30s: reduce fetch load without perder utilidad


        async function updateWatchlist() {
      try {
        // Batch request: reduce llamadas y latencia
        const url = `https://api.binance.com/api/v3/ticker/24hr?symbols=${encodeURIComponent(JSON.stringify(watchlistSymbols))}`;
        const response = await fetch(url);
        const arr = await response.json();

        if (!Array.isArray(arr)) throw new Error('Unexpected response');

        for (const data of arr) {
          const symbol = data.symbol;
          const shortSymbol = symbol.replace('USDT', '').toLowerCase();
          const price = parseFloat(data.lastPrice);
          const change = parseFloat(data.priceChangePercent);

          const priceEl = document.getElementById(`watch-${shortSymbol}-price`);
          const changeEl = document.getElementById(`watch-${shortSymbol}-change`);

          if (priceEl) {
            priceEl.textContent = price.toFixed(4);
          }

          if (changeEl) {
            changeEl.textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
            changeEl.className = 'watchlist-change ' + (change >= 0 ? 'up' : 'down');
          }

          // Mini chart
          updateMiniChart(shortSymbol, symbol);
        }
      } catch (e) {
        // Fallback por s√≠mbolo para mantener compatibilidad (si el batch falla)
        for (const symbol of watchlistSymbols) {
          try {
            const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
            const data = await response.json();

            const shortSymbol = symbol.replace('USDT', '').toLowerCase();
            const price = parseFloat(data.lastPrice);
            const change = parseFloat(data.priceChangePercent);

            const priceEl = document.getElementById(`watch-${shortSymbol}-price`);
            const changeEl = document.getElementById(`watch-${shortSymbol}-change`);

            if (priceEl) {
              priceEl.textContent = price.toFixed(4);
            }

            if (changeEl) {
              changeEl.textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
              changeEl.className = 'watchlist-change ' + (change >= 0 ? 'up' : 'down');
            }

            // Mini chart
            updateMiniChart(shortSymbol, symbol);
          } catch (err) {}
        }
      }
    }

async function updateMiniChart(shortSymbol, symbol) {
      try {
        const now = _now();
        const cache = miniChartCache[shortSymbol] || (miniChartCache[shortSymbol] = { lastFetch: 0, bars: null });

        // TTL para reducir llamadas (sin perder comportamiento general)
        if (cache.bars && (now - cache.lastFetch) < MINI_CHART_TTL_MS) return;

        cache.lastFetch = now;

        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=8`);
        const data = await response.json();
        if (!Array.isArray(data) || data.length < 8) return;

        const container = document.getElementById(`chart-${shortSymbol}`);
        if (!container) return;

        // Crear barras una sola vez y reutilizar (evita innerHTML por actualizaci√≥n)
        if (!cache.bars || cache.bars.length !== 8 || container.childElementCount !== 8) {
          container.innerHTML = '';
          const bars = [];
          const frag = document.createDocumentFragment();
          for (let i = 0; i < 8; i++) {
            const bar = document.createElement('div');
            bar.className = 'mini-bar';
            frag.appendChild(bar);
            bars.push(bar);
          }
          container.appendChild(frag);
          cache.bars = bars;
        }

        // Calcular cierres + min/max sin spreads (menos GC)
        const closes = new Array(8);
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < 8; i++) {
          const c = parseFloat(data[i][4]);
          closes[i] = c;
          if (c < min) min = c;
          if (c > max) max = c;
        }
        const range = (max - min) || 1;

        for (let i = 0; i < 8; i++) {
          const c = closes[i];
          const height = ((c - min) / range * 100);
          const isUp = (i > 0 && closes[i] >= closes[i - 1]);
          const color = isUp ? 'var(--accent-green)' : 'var(--accent-red)';

          const bar = cache.bars[i];
          bar.style.height = Math.max(10, height) + '%';
          bar.style.background = color;
        }
      } catch (e) {}
    }

    // ============================================
    // INITIALIZATION FOR NEW TOOLS
    // ============================================

    // Load saved data and start updates
    loadStrategies();
    
    // Update watchlist every 10 seconds
    setInterval(updateWatchlist, 10000);
    updateWatchlist();
    
    // Update correlations every 2 minutes
    setInterval(updateCorrelations, 120000);
    
    // Update Fibonacci when tools panel opens
    const origToggleToolsPanel = toggleToolsPanel;
    toggleToolsPanel = function() {
      origToggleToolsPanel();
      if (document.getElementById('toolsOverlay').classList.contains('active')) {
        updateFibonacci();
        updateCorrelations();
        updateWatchlist();
      }
    };

  </script>

  <!-- ============================================
       MULTI-CHART MODE OVERLAY
       ============================================ -->
  <div id="multiChartOverlay" class="multichart-overlay">
    <div class="multichart-container">
      <div class="multichart-header">
        <h2>üìä MULTI-CHART MODE</h2>
        <span style="color:var(--text-dim); font-size:12px;">Real-time 4-Asset View</span>
        <button class="multichart-close" onclick="toggleMultiChart()">√ó</button>
      </div>
      
      <div class="multichart-grid">
        <!-- XRP Chart -->
        <div class="mini-chart-card" id="miniChart-XRP">
          <div class="mini-chart-header">
            <span class="mini-chart-symbol">XRP/USDT</span>
            <span class="mini-chart-price" id="mc-price-XRP">--</span>
            <span class="mini-chart-change" id="mc-change-XRP">--%</span>
          </div>
          <div class="mini-chart-container" id="mc-chart-XRP"></div>
          <div class="mini-chart-footer">
            <span>RSI: <span id="mc-rsi-XRP">--</span></span>
            <span>Vol: <span id="mc-vol-XRP">--</span></span>
            <span class="mini-chart-signal" id="mc-signal-XRP">--</span>
          </div>
        </div>
        
        <!-- XLM Chart -->
        <div class="mini-chart-card" id="miniChart-XLM">
          <div class="mini-chart-header">
            <span class="mini-chart-symbol">XLM/USDT</span>
            <span class="mini-chart-price" id="mc-price-XLM">--</span>
            <span class="mini-chart-change" id="mc-change-XLM">--%</span>
          </div>
          <div class="mini-chart-container" id="mc-chart-XLM"></div>
          <div class="mini-chart-footer">
            <span>RSI: <span id="mc-rsi-XLM">--</span></span>
            <span>Vol: <span id="mc-vol-XLM">--</span></span>
            <span class="mini-chart-signal" id="mc-signal-XLM">--</span>
          </div>
        </div>
        
        <!-- JASMY Chart -->
        <div class="mini-chart-card" id="miniChart-JASMY">
          <div class="mini-chart-header">
            <span class="mini-chart-symbol">JASMY/USDT</span>
            <span class="mini-chart-price" id="mc-price-JASMY">--</span>
            <span class="mini-chart-change" id="mc-change-JASMY">--%</span>
          </div>
          <div class="mini-chart-container" id="mc-chart-JASMY"></div>
          <div class="mini-chart-footer">
            <span>RSI: <span id="mc-rsi-JASMY">--</span></span>
            <span>Vol: <span id="mc-vol-JASMY">--</span></span>
            <span class="mini-chart-signal" id="mc-signal-JASMY">--</span>
          </div>
        </div>
        
        <!-- HBAR Chart -->
        <div class="mini-chart-card" id="miniChart-HBAR">
          <div class="mini-chart-header">
            <span class="mini-chart-symbol">HBAR/USDT</span>
            <span class="mini-chart-price" id="mc-price-HBAR">--</span>
            <span class="mini-chart-change" id="mc-change-HBAR">--%</span>
          </div>
          <div class="mini-chart-container" id="mc-chart-HBAR"></div>
          <div class="mini-chart-footer">
            <span>RSI: <span id="mc-rsi-HBAR">--</span></span>
            <span>Vol: <span id="mc-vol-HBAR">--</span></span>
            <span class="mini-chart-signal" id="mc-signal-HBAR">--</span>
          </div>
        </div>
      </div>
      
      <!-- Summary Bar -->
      <div class="multichart-summary">
        <div class="summary-item">
          <span class="summary-label">STRONGEST</span>
          <span class="summary-value" id="mc-strongest" style="color:var(--accent-green)">--</span>
        </div>
        <div class="summary-item">
          <span class="summary-label">WEAKEST</span>
          <span class="summary-value" id="mc-weakest" style="color:var(--accent-red)">--</span>
        </div>
        <div class="summary-item">
          <span class="summary-label">MARKET MOOD</span>
          <span class="summary-value" id="mc-mood">--</span>
        </div>
        <div class="summary-item">
          <span class="summary-label">CORRELATION</span>
          <span class="summary-value" id="mc-correlation">--</span>
        </div>
      </div>
    </div>
  </div>

  <style>
    /* Multi-Chart Mode Styles */
    .multichart-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(2, 6, 12, 0.95);
      z-index: 9999;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
    }
    
    .multichart-overlay.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    .multichart-container {
      max-width: 1600px;
      margin: 0 auto;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .multichart-header {
      display: flex;
      align-items: center;
      gap: 15px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 15px;
    }
    
    .multichart-header h2 {
      margin: 0;
      color: var(--accent-cyan);
      font-size: 20px;
    }
    
    .multichart-close {
      margin-left: auto;
      background: rgba(255, 68, 102, 0.2);
      border: 1px solid var(--accent-red);
      color: var(--accent-red);
      width: 36px;
      height: 36px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.3s;
    }
    
    .multichart-close:hover {
      background: var(--accent-red);
      color: #fff;
    }
    
    .multichart-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      flex: 1;
      min-height: 0;
    }
    
    .mini-chart-card {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: all 0.3s;
    }
    
    .mini-chart-card:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.1);
    }
    
    .mini-chart-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 15px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .mini-chart-symbol {
      font-weight: bold;
      font-size: 14px;
      color: var(--accent-cyan);
    }
    
    .mini-chart-price {
      font-family: var(--font-data);
      font-size: 16px;
      font-weight: bold;
    }
    
    .mini-chart-change {
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0, 255, 136, 0.1);
    }
    
    .mini-chart-change.positive { color: var(--accent-green); background: rgba(0, 255, 136, 0.1); }
    .mini-chart-change.negative { color: var(--accent-red); background: rgba(255, 68, 102, 0.1); }
    
    .mini-chart-container {
      flex: 1;
      min-height: 200px;
      background: rgba(0,0,0,0.2);
    }
    
    .mini-chart-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 15px;
      font-size: 11px;
      color: var(--text-dim);
      background: rgba(0,0,0,0.3);
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    
    .mini-chart-signal {
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 10px;
    }
    
    .mini-chart-signal.bullish { background: rgba(0, 255, 136, 0.2); color: var(--accent-green); }
    .mini-chart-signal.bearish { background: rgba(255, 68, 102, 0.2); color: var(--accent-red); }
    .mini-chart-signal.neutral { background: rgba(255, 255, 255, 0.1); color: var(--text-dim); }
    
    .multichart-summary {
      display: flex;
      justify-content: space-around;
      padding: 15px;
      background: rgba(0, 212, 255, 0.05);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 10px;
      margin-top: 15px;
    }
    
    .summary-item {
      text-align: center;
    }
    
    .summary-label {
      display: block;
      font-size: 9px;
      color: var(--text-dim);
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .summary-value {
      font-size: 14px;
      font-weight: bold;
      color: var(--accent-cyan);
    }
    
    @media (max-width: 900px) {
      .multichart-grid {
        grid-template-columns: 1fr;
      }
      .mini-chart-container {
        min-height: 150px;
      }
    }
  </style>

  <script>
    // ============================================
    // MULTI-CHART MODE FUNCTIONALITY
    // ============================================
    
    const multiChartAssets = {
      XRP: { symbol: 'XRPUSDT', name: 'XRP', decimals: 4 },
      XLM: { symbol: 'XLMUSDT', name: 'XLM', decimals: 5 },
      JASMY: { symbol: 'JASMYUSDT', name: 'JASMY', decimals: 6 },
      HBAR: { symbol: 'HBARUSDT', name: 'HBAR', decimals: 5 }
    };
    
    const multiChartState = {
      active: false,
      charts: {},
      data: {},
      ws: null
    };
    
    function toggleMultiChart() {
      const overlay = document.getElementById('multiChartOverlay');
      multiChartState.active = !multiChartState.active;
      
      if (multiChartState.active) {
        overlay.classList.add('active');
        initMultiCharts();
        connectMultiChartWS();
      } else {
        overlay.classList.remove('active');
        if (multiChartState.ws) {
          multiChartState.ws.close();
          multiChartState.ws = null;
        }
      }
    }
    
    function initMultiCharts() {
      Object.keys(multiChartAssets).forEach(asset => {
        const container = document.getElementById(`mc-chart-${asset}`);
        if (!container || multiChartState.charts[asset]) return;
        
        const chart = LightweightCharts.createChart(container, {
          width: container.clientWidth,
          height: container.clientHeight,
          layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#94a3b8' },
          grid: { vertLines: { color: 'rgba(255,255,255,0.02)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
          rightPriceScale: { borderColor: 'rgba(255,255,255,0.05)', scaleMargins: { top: 0.1, bottom: 0.1 } },
          timeScale: { borderColor: 'rgba(255,255,255,0.05)', timeVisible: true, visible: false },
          crosshair: { mode: 0 },
          localization: {
            timeFormatter: (timestamp) => {
              const date = new Date(timestamp * 1000);
              return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
          }
        });
        
        const candleSeries = chart.addCandlestickSeries({
          upColor: '#00ff88', downColor: '#ff4466',
          borderUpColor: '#00ff88', borderDownColor: '#ff4466',
          wickUpColor: '#00ff88', wickDownColor: '#ff4466'
        });
        
        multiChartState.charts[asset] = { chart, candleSeries };
        multiChartState.data[asset] = { candles: [], price: 0, change: 0 };
        
        // Fetch historical data
        fetchMultiChartData(asset);
        
        // Resize observer
        new ResizeObserver(() => {
          chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
        }).observe(container);
      });
    }
    
    async function fetchMultiChartData(asset) {
      try {
        const symbol = multiChartAssets[asset].symbol;
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=5m&limit=50`);
        const data = await response.json();
        
        const candles = data.map(d => ({
          time: d[0] / 1000,
          open: parseFloat(d[1]),
          high: parseFloat(d[2]),
          low: parseFloat(d[3]),
          close: parseFloat(d[4]),
          volume: parseFloat(d[5])
        }));
        
        multiChartState.data[asset].candles = candles;
        
        if (multiChartState.charts[asset]) {
          multiChartState.charts[asset].candleSeries.setData(candles);
        }
        
        // Calculate RSI
        const closes = candles.map(c => c.close);
        const rsi = calcRSI(closes, 14);
        document.getElementById(`mc-rsi-${asset}`).innerText = rsi ? rsi.toFixed(0) : '--';
        
        // Update signal
        updateMiniChartSignal(asset, rsi, closes);
        
      } catch (e) {
        console.error(`Error fetching ${asset} data:`, e);
      }
    }
    
    function connectMultiChartWS() {
      const streams = Object.values(multiChartAssets)
        .map(a => `${a.symbol.toLowerCase()}@ticker`)
        .join('/');
      
      const wsUrl = `wss://stream.binance.com:9443/stream?streams=${streams}`;
      
      multiChartState.ws = new WebSocket(wsUrl);
      
      multiChartState.ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (!msg.data) return;
        
        const ticker = msg.data;
        const symbol = ticker.s;
        const asset = Object.keys(multiChartAssets).find(a => multiChartAssets[a].symbol === symbol);
        
        if (!asset) return;
        
        const price = parseFloat(ticker.c);
        const change = parseFloat(ticker.P);
        const volume = parseFloat(ticker.v);
        const decimals = multiChartAssets[asset].decimals;
        
        multiChartState.data[asset].price = price;
        multiChartState.data[asset].change = change;
        
        // Update UI
        document.getElementById(`mc-price-${asset}`).innerText = price.toFixed(decimals);
        
        const changeEl = document.getElementById(`mc-change-${asset}`);
        changeEl.innerText = (change >= 0 ? '+' : '') + change.toFixed(2) + '%';
        changeEl.className = 'mini-chart-change ' + (change >= 0 ? 'positive' : 'negative');
        
        document.getElementById(`mc-vol-${asset}`).innerText = (volume / 1000000).toFixed(1) + 'M';
      };
      
      multiChartState.ws.onerror = (e) => console.error('MultiChart WS error:', e);
    }
    
    function updateMiniChartSignal(asset, rsi, closes) {
      const signalEl = document.getElementById(`mc-signal-${asset}`);
      if (!signalEl) return;
      
      // Simple signal based on RSI and trend
      const sma = closes.slice(-10).reduce((a,b) => a+b, 0) / 10;
      const currentPrice = closes[closes.length - 1];
      const trend = currentPrice > sma ? 'up' : 'down';
      
      let signal = 'NEUTRAL';
      let signalClass = 'neutral';
      
      if (rsi < 30 && trend === 'down') {
        signal = 'OVERSOLD';
        signalClass = 'bullish';
      } else if (rsi > 70 && trend === 'up') {
        signal = 'OVERBOUGHT';
        signalClass = 'bearish';
      } else if (rsi > 50 && trend === 'up') {
        signal = 'BULLISH';
        signalClass = 'bullish';
      } else if (rsi < 50 && trend === 'down') {
        signal = 'BEARISH';
        signalClass = 'bearish';
      }
      
      signalEl.innerText = signal;
      signalEl.className = 'mini-chart-signal ' + signalClass;
    }
    
    function updateMultiChartSummary() {
      const assets = Object.keys(multiChartAssets);
      let strongest = { asset: '--', change: -Infinity };
      let weakest = { asset: '--', change: Infinity };
      let bullCount = 0;
      
      assets.forEach(asset => {
        const data = multiChartState.data[asset];
        if (!data) return;
        
        if (data.change > strongest.change) {
          strongest = { asset, change: data.change };
        }
        if (data.change < weakest.change) {
          weakest = { asset, change: data.change };
        }
        if (data.change > 0) bullCount++;
      });
      
      document.getElementById('mc-strongest').innerText = `${strongest.asset} (${strongest.change >= 0 ? '+' : ''}${strongest.change.toFixed(2)}%)`;
      document.getElementById('mc-weakest').innerText = `${weakest.asset} (${weakest.change.toFixed(2)}%)`;
      
      const mood = bullCount >= 3 ? 'BULLISH' : bullCount >= 2 ? 'MIXED' : 'BEARISH';
      const moodEl = document.getElementById('mc-mood');
      moodEl.innerText = mood;
      moodEl.style.color = mood === 'BULLISH' ? 'var(--accent-green)' : mood === 'BEARISH' ? 'var(--accent-red)' : 'var(--accent-orange)';
      
      // Simple correlation (all moving same direction)
      const sameDirection = assets.filter(a => multiChartState.data[a]?.change > 0).length;
      const corr = sameDirection === 4 || sameDirection === 0 ? 'HIGH' : sameDirection === 3 || sameDirection === 1 ? 'MEDIUM' : 'LOW';
      document.getElementById('mc-correlation').innerText = corr;
    }
    
    // Update summary every 5 seconds when active
    setInterval(() => {
      if (multiChartState.active) {
        updateMultiChartSummary();
      }
    }, 5000);
    
    // Keyboard shortcut: M for Multi-Chart
    document.addEventListener('keydown', (e) => {
      if (e.key === 'm' || e.key === 'M') {
        if (!e.target.matches('input, textarea, select')) {
          toggleMultiChart();
        }
      }
    });
  </script>

  <!-- PWA INSTALL BANNER -->
  <div id="pwaInstallBanner" class="pwa-install-banner">
    <div class="pwa-install-content">
      <div class="pwa-install-icon"><span>X</span></div>
      <div class="pwa-install-text">
        <h4>Install XRP ORACULUM</h4>
        <p>Add to home screen for the best experience</p>
      </div>
    </div>
    <button class="pwa-install-btn" id="pwaInstallBtn">
      üì≤ INSTALL APP
    </button>
    <button class="pwa-install-close" id="pwaInstallClose">‚úï</button>
  </div>

  <!-- iOS INSTALL INSTRUCTIONS MODAL -->
  <div id="iosInstallModal" class="ios-install-modal">
    <div class="ios-install-content">
      <h3>üì± Install on iPhone/iPad</h3>
      <div class="ios-step">
        <div class="ios-step-num">1</div>
        <div class="ios-step-text">Tap the <span class="ios-step-icon">‚¨ÜÔ∏è</span> Share button in Safari</div>
      </div>
      <div class="ios-step">
        <div class="ios-step-num">2</div>
        <div class="ios-step-text">Scroll down and tap <strong>"Add to Home Screen"</strong></div>
      </div>
      <div class="ios-step">
        <div class="ios-step-num">3</div>
        <div class="ios-step-text">Tap <strong>"Add"</strong> to install the app</div>
      </div>
      <button class="add-alert-btn" onclick="closeIosModal()" style="margin-top:20px;">Got it!</button>
    </div>
  </div>

  <script>
    // ============================================
    // PWA INSTALLATION LOGIC
    // ============================================

    let deferredPrompt = null;
    const pwaInstallBanner = document.getElementById('pwaInstallBanner');
    const pwaInstallBtn = document.getElementById('pwaInstallBtn');
    const pwaInstallClose = document.getElementById('pwaInstallClose');
    const iosInstallModal = document.getElementById('iosInstallModal');

    // Detect if running as installed PWA
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                         window.navigator.standalone === true;

    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // Detect if already dismissed
    const pwaDismissed = localStorage.getItem('pwa_install_dismissed');
    const pwaDismissedTime = pwaDismissed ? parseInt(pwaDismissed) : 0;
    const daysSinceDismiss = (Date.now() - pwaDismissedTime) / (1000 * 60 * 60 * 24);

    // Show banner after delay if not installed and not recently dismissed
    function checkShowInstallBanner() {
      if (isStandalone) return; // Already installed
      if (daysSinceDismiss < 7 && pwaDismissed) return; // Dismissed within 7 days
      
      setTimeout(() => {
        if (isIOS) {
          // Show iOS-specific banner
          pwaInstallBanner.classList.add('show');
          pwaInstallBtn.textContent = 'üì≤ HOW TO INSTALL';
        } else if (deferredPrompt) {
          // Show Android/Desktop banner
          pwaInstallBanner.classList.add('show');
        }
      }, 5000); // Show after 5 seconds
    }

    // Listen for beforeinstallprompt (Android/Desktop)
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      checkShowInstallBanner();
    });

    // Handle install button click
    pwaInstallBtn.addEventListener('click', async () => {
      if (isIOS) {
        // Show iOS instructions
        iosInstallModal.classList.add('show');
        pwaInstallBanner.classList.remove('show');
      } else if (deferredPrompt) {
        // Trigger native install prompt
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        
        if (outcome === 'accepted') {
          console.log('PWA installed');
          addAlert('üéâ App installed successfully!', 'bullish');
        }
        
        deferredPrompt = null;
        pwaInstallBanner.classList.remove('show');
      }
    });

    // Handle close button
    pwaInstallClose.addEventListener('click', () => {
      pwaInstallBanner.classList.remove('show');
      localStorage.setItem('pwa_install_dismissed', Date.now().toString());
    });

    // Close iOS modal
    function closeIosModal() {
      iosInstallModal.classList.add('show');
      iosInstallModal.classList.remove('show');
      localStorage.setItem('pwa_install_dismissed', Date.now().toString());
    }

    // Close iOS modal on outside click
    iosInstallModal.addEventListener('click', (e) => {
      if (e.target === iosInstallModal) {
        closeIosModal();
      }
    });

    // Listen for successful installation
    window.addEventListener('appinstalled', () => {
      console.log('XRP ORACULUM installed');
      pwaInstallBanner.classList.remove('show');
      deferredPrompt = null;
    });

    // Check on load
    if (!isStandalone) {
      checkShowInstallBanner();
    }

    // ============================================
    // SERVICE WORKER REGISTRATION
    // ============================================

    // Create and register Service Worker inline
    const swCode = `
      const CACHE_NAME = 'xrp-oraculum-v3-cache';
      const OFFLINE_URL = '/offline.html';
      
      // Assets to cache immediately
      const PRECACHE_ASSETS = [
        './',
        './index.html'
      ];
      
      // Install event
      self.addEventListener('install', (event) => {
        console.log('[SW] Installing...');
        self.skipWaiting();
      });
      
      // Activate event
      self.addEventListener('activate', (event) => {
        console.log('[SW] Activated');
        event.waitUntil(clients.claim());
      });
      
      // Fetch event - Network first, fallback to cache
      self.addEventListener('fetch', (event) => {
        // Skip non-GET requests
        if (event.request.method !== 'GET') return;
        
        // Skip API requests (always fetch from network)
        if (event.request.url.includes('api.binance.com') || 
            event.request.url.includes('api.alternative.me')) {
          return;
        }
        
        event.respondWith(
          fetch(event.request)
            .then((response) => {
              // Clone and cache successful responses
              if (response.ok) {
                const responseClone = response.clone();
                caches.open(CACHE_NAME).then((cache) => {
                  cache.put(event.request, responseClone);
                });
              }
              return response;
            })
            .catch(() => {
              // Fallback to cache
              return caches.match(event.request);
            })
        );
      });
    `;

    // Register Service Worker
    if ('serviceWorker' in navigator) {
      // Create blob URL for inline SW
      const swBlob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(swBlob);
      
      // Try to register
      navigator.serviceWorker.register(swUrl, { scope: '.' })
        .then((registration) => {
          console.log('[PWA] Service Worker registered:', registration.scope);
        })
        .catch((error) => {
          // SW registration may fail on file:// or some hosting
          console.log('[PWA] Service Worker registration skipped:', error.message);
        });
    }

    // ============================================
    // ONLINE/OFFLINE STATUS
    // ============================================

    function updateOnlineStatus() {
      if (!navigator.onLine) {
        addAlert('‚ö†Ô∏è You are offline. Some features may be limited.', 'warning');
        document.getElementById('apiStatusText').textContent = 'OFFLINE';
        document.getElementById('statusPill').classList.remove('status-live');
        document.getElementById('statusPill').classList.add('status-err');
      }
    }

    window.addEventListener('online', () => {
      addAlert('‚úÖ Back online! Reconnecting...', 'bullish');
      // Reconnect WebSocket
      if (typeof connectWebSocket === 'function') {
        connectWebSocket();
      }
    });

    window.addEventListener('offline', updateOnlineStatus);

    // Check initial status
    if (!navigator.onLine) {
      updateOnlineStatus();
    }

    // ============================================
    // MOBILE TOUCH OPTIMIZATIONS
    // ============================================

    // Prevent double-tap zoom on buttons
    document.addEventListener('touchend', (e) => {
      if (e.target.tagName === 'BUTTON' || e.target.classList.contains('control-btn')) {
        e.preventDefault();
        e.target.click();
      }
    }, { passive: false });

    // Improve scroll performance
    document.addEventListener('touchstart', () => {}, { passive: true });
    document.addEventListener('touchmove', () => {}, { passive: true });

    // Handle viewport height on mobile (fixes 100vh issue)
    function setVH() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    setVH();
    window.addEventListener('resize', setVH);

    // ============================================
    // KEYBOARD SHORTCUTS
    // ============================================

    document.addEventListener('keydown', (e) => {
      // T = Toggle Tools
      if (e.key === 't' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        toggleToolsPanel();
      }
      // Escape = Close modals
      if (e.key === 'Escape') {
        document.getElementById('toolsOverlay').classList.remove('active');
        iosInstallModal.classList.remove('show');
      }
      // S = Toggle sound
      if (e.key === 's' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        toggleSound();
      }
      // D = Toggle dark/light mode
      if (e.key === 'd' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
        toggleTheme();
      }
    });

    console.log('%c ‚óÜ XRP ORACULUM ', 'background: linear-gradient(135deg, #00d4ff, #a855f7); color: #000; font-size: 20px; font-weight: bold; padding: 10px 20px; border-radius: 5px;');
    console.log('%c OkrtSystem Labs ', 'color: #00d4ff; font-size: 14px; font-weight: bold;');
    console.log('%c Keyboard shortcuts: T=Tools, S=Sound, D=Dark mode, ESC=Close ', 'color: #94a3b8; font-size: 10px;');

  </script>
</body>
</html>
